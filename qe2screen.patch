diff --git a/EPW/src/bcast_epw_input.f90 b/EPW/src/bcast_epw_input.f90
index 847190887..a2631d376 100644
--- a/EPW/src/bcast_epw_input.f90
+++ b/EPW/src/bcast_epw_input.f90
@@ -53,7 +53,10 @@
                             wannier_plot_supercell, wannier_plot_radius,      &
                             fixsym, epw_no_t_rev, epw_tr, epw_nosym, epw_noinv, &
                             epw_crysym, bfieldx, bfieldy, bfieldz, tc_linear, &
-                            tc_linear_solver
+                            tc_linear_solver, bare, cdfpt_dir, cdfpt_max,     &
+                            cdfpt_min, corr, eig_plot, L, lcdfpt, lpolarc,    &
+                            lpolarx, lxdfpt, perp, phlabel, prtgkkc, prtgkkx, &
+                            temp_inf, type_inf, types, unscreen_fine, xdfpt_dir
   USE elph2,         ONLY : elph
   USE mp,            ONLY : mp_bcast
   USE mp_world,      ONLY : world_comm
@@ -88,6 +91,7 @@
   CALL mp_bcast(plselfen        , meta_ionode_id, world_comm)
   CALL mp_bcast(ephwrite        , meta_ionode_id, world_comm)
   CALL mp_bcast(band_plot       , meta_ionode_id, world_comm)
+  CALL mp_bcast(eig_plot        , meta_ionode_id, world_comm)
   CALL mp_bcast(fermi_plot      , meta_ionode_id, world_comm)
   CALL mp_bcast(vme             , meta_ionode_id, world_comm)
   CALL mp_bcast(epbread         , meta_ionode_id, world_comm)
@@ -122,6 +126,8 @@
   CALL mp_bcast(tc_linear       , meta_ionode_id, world_comm)
   CALL mp_bcast(tc_linear_solver, meta_ionode_id, world_comm)
   CALL mp_bcast(lpolar          , meta_ionode_id, world_comm)
+  CALL mp_bcast(lpolarc         , meta_ionode_id, world_comm)
+  CALL mp_bcast(lpolarx         , meta_ionode_id, world_comm)
   CALL mp_bcast(lifc            , meta_ionode_id, world_comm)
   CALL mp_bcast(lscreen         , meta_ionode_id, world_comm)
   CALL mp_bcast(cumulant        , meta_ionode_id, world_comm)
@@ -147,6 +153,8 @@
   CALL mp_bcast(carrier         , meta_ionode_id, world_comm)
   CALL mp_bcast(restart         , meta_ionode_id, world_comm)
   CALL mp_bcast(prtgkk          , meta_ionode_id, world_comm)
+  CALL mp_bcast(prtgkkc         , meta_ionode_id, world_comm)
+  CALL mp_bcast(prtgkkx         , meta_ionode_id, world_comm)
   CALL mp_bcast(lphase          , meta_ionode_id, world_comm)
   CALL mp_bcast(lindabs         , meta_ionode_id, world_comm)
   CALL mp_bcast(use_ws          , meta_ionode_id, world_comm)
@@ -161,6 +169,11 @@
   CALL mp_bcast(epw_nosym       , meta_ionode_id, world_comm)
   CALL mp_bcast(epw_noinv       , meta_ionode_id, world_comm)
   CALL mp_bcast(epw_crysym      , meta_ionode_id, world_comm)
+  CALL mp_bcast(lcdfpt          , meta_ionode_id, world_comm)
+  CALL mp_bcast(lxdfpt          , meta_ionode_id, world_comm)
+  CALL mp_bcast(unscreen_fine   , meta_ionode_id, world_comm)
+  CALL mp_bcast(bare            , meta_ionode_id, world_comm)
+  CALL mp_bcast(perp            , meta_ionode_id, world_comm)
   !
   ! integers
   !
@@ -200,6 +213,9 @@
   CALL mp_bcast(bnd_cum     , meta_ionode_id, world_comm)
   CALL mp_bcast(mob_maxiter , meta_ionode_id, world_comm)
   CALL mp_bcast(wannier_plot_supercell, meta_ionode_id, world_comm)
+  CALL mp_bcast(types       , meta_ionode_id, world_comm)
+  CALL mp_bcast(type_inf    , meta_ionode_id, world_comm)
+  CALL mp_bcast(corr        , meta_ionode_id, world_comm)
   !
   ! REAL*8
   !
@@ -219,6 +235,7 @@
   CALL mp_bcast(tempsmin      , meta_ionode_id, world_comm)
   CALL mp_bcast(tempsmax      , meta_ionode_id, world_comm)
   CALL mp_bcast(temps         , meta_ionode_id, world_comm)
+  CALL mp_bcast(temp_inf      , meta_ionode_id, world_comm)
   CALL mp_bcast(conv_thr_raxis, meta_ionode_id, world_comm)
   CALL mp_bcast(conv_thr_iaxis, meta_ionode_id, world_comm)
   CALL mp_bcast(conv_thr_racon, meta_ionode_id, world_comm)
@@ -245,6 +262,9 @@
   CALL mp_bcast(bfieldx       , meta_ionode_id, world_comm)
   CALL mp_bcast(bfieldy       , meta_ionode_id, world_comm)
   CALL mp_bcast(bfieldz       , meta_ionode_id, world_comm)
+  CALL mp_bcast(L             , meta_ionode_id, world_comm)
+  CALL mp_bcast(cdfpt_min     , meta_ionode_id, world_comm)
+  CALL mp_bcast(cdfpt_max     , meta_ionode_id, world_comm)
   !
   ! characters
   !
@@ -257,6 +277,9 @@
   CALL mp_bcast(filqf            , meta_ionode_id, world_comm)
   CALL mp_bcast(fileig           , meta_ionode_id, world_comm)
   CALL mp_bcast(dvscf_dir        , meta_ionode_id, world_comm)
+  CALL mp_bcast(cdfpt_dir        , meta_ionode_id, world_comm)
+  CALL mp_bcast(xdfpt_dir        , meta_ionode_id, world_comm)
+  CALL mp_bcast(phlabel          , meta_ionode_id, world_comm)
   CALL mp_bcast(fila2f           , meta_ionode_id, world_comm)
   CALL mp_bcast(restart_filq     , meta_ionode_id, world_comm)
   CALL mp_bcast(asr_typ          , meta_ionode_id, world_comm)
diff --git a/EPW/src/bloch2wan.f90 b/EPW/src/bloch2wan.f90
index a7a59c881..633e21375 100644
--- a/EPW/src/bloch2wan.f90
+++ b/EPW/src/bloch2wan.f90
@@ -460,7 +460,7 @@
     !------------------------------------------------------------------------
     !
     !------------------------------------------------------------------------
-    SUBROUTINE dynbloch2wan(nmodes, nq, xk, dynq, nrr, irvec, wslen )
+    SUBROUTINE dynbloch2wan(nmodes, nq, xk, dynq, rdw, nrr, irvec, wslen, lpolar, qrpl, epsi, zstar, Qmat, suffix)
     !------------------------------------------------------------------------
     !!
     !!  From the Dynamical Matrix in Bloch representation (coarse mesh),
@@ -478,8 +478,7 @@
     USE kinds,         ONLY : DP
     USE cell_base,     ONLY : at, bg, alat
     USE ions_base,     ONLY : nat, tau
-    USE elph2,         ONLY : rdw, epsi, zstar, qrpl
-    USE epwcom,        ONLY : lpolar, nqc1, nqc2, nqc3
+    USE epwcom,        ONLY : nqc1, nqc2, nqc3
     USE io_var,        ONLY : iudecaydyn
     USE constants_epw, ONLY : bohr2ang, twopi, ci, czero
     USE io_global,     ONLY : ionode_id
@@ -504,6 +503,20 @@
     !! WS vectors length (alat units)
     COMPLEX(KIND = DP), INTENT(inout) :: dynq(nmodes, nmodes, nq)
     !! dynamical matrix in bloch representation (Cartesian coordinates)
+    COMPLEX(KIND = DP), INTENT(inout) :: rdw(nmodes, nmodes, nrr)
+    !! dynamical matrix in wannier basis (real)
+    LOGICAL, INTENT(in) :: lpolar
+    !! if .TRUE. enable the correct Wannier interpolation in the case of polar material
+    LOGICAL, INTENT(in) :: qrpl
+    !! If true use quadrupole during interpolation
+    REAL(KIND = DP), INTENT(in) :: epsi(3, 3)
+    !! dielectric constant tensor
+    REAL(KIND = DP), INTENT(inout) :: zstar(3, 3, nat)
+    !! effective charges tensor
+    REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+    !! Quadrupole tensor
+    CHARACTER(*), INTENT(in) :: suffix
+    !! Extra label for filenames
     !
     ! Local variables
     INTEGER :: ik
@@ -521,7 +534,7 @@
     IF (lpolar .OR. qrpl) THEN
       DO ik = 1, nq
         !xk has to be in cart. coord.
-        CALL rgd_blk(nqc1, nqc2, nqc3, nat, dynq(:, :, ik), xk(:, ik), tau, epsi, zstar, -1.d0)
+        CALL rgd_blk(nqc1, nqc2, nqc3, nat, dynq(:, :, ik), xk(:, ik), tau, lpolar, epsi, zstar, Qmat, -1.d0)
         !
       ENDDO
     ENDIF
@@ -563,7 +576,7 @@
     ! the unit in r-space is angstrom, and I am plotting the matrix for the first mode only
     !
     IF (mpime == ionode_id) THEN
-      OPEN(UNIT = iudecaydyn, FILE = 'decay.dynmat')
+      OPEN(UNIT = iudecaydyn, FILE = 'decay.dynmat' // suffix)
       WRITE(iudecaydyn, '(a)') '# Spatial decay of Dynamical matrix in Wannier basis'
       WRITE(iudecaydyn, '(a)') '# R_p [Ang]      max_{mu,nu} |D(mu,nu)| [Ry] '
       DO ir = 1, nrr
@@ -1121,7 +1134,7 @@
     !--------------------------------------------------------------------------
     !
     !--------------------------------------------------------------------------
-    SUBROUTINE ephbloch2wanp(nbnd, nmodes, xk, nq, irvec_k, irvec_g, nrr_k, nrr_g, epmatwe)
+    SUBROUTINE ephbloch2wanp(nbnd, nmodes, xk, nq, irvec_k, irvec_g, nrr_k, nrr_g, epmatwe, epmatwp, suffix)
     !--------------------------------------------------------------------------
     !!
     !!  From the EP matrix in electron-Wannier representation and
@@ -1131,7 +1144,6 @@
     !
     USE kinds,         ONLY : DP
     USE cell_base,     ONLY : at, bg, alat
-    USE elph2,         ONLY : epmatwp
     USE constants_epw, ONLY : bohr2ang, twopi, ci, czero
     USE io_var,        ONLY : iuwanep, iuwane
     USE io_global,     ONLY : ionode_id
@@ -1163,6 +1175,10 @@
     COMPLEX(KIND = DP), INTENT(in) :: epmatwe(nbnd, nbnd, nrr_k, nmodes, nq)
     !! EP matrix in electron-Wannier representation and phonon-Bloch representation
     !!   (Cartesian coordinates)
+    COMPLEX(KIND = DP), INTENT(out) :: epmatwp(nbnd, nbnd, nrr_k, nmodes, nrr_g)
+    !! EP matrix in electron- and phonon-Wannier representation
+    CHARACTER(*), INTENT(in) :: suffix
+    !! Extra label for filenames
     !
     ! Work variables
     !
@@ -1231,14 +1247,14 @@
       len1(ire) = DSQRT(rvec1(1)**2.d0 + rvec1(2)**2.d0 + rvec1(3)**2.d0)
     ENDDO
     !
-    OPEN(UNIT = iuwane, FILE = 'decay.epmate', STATUS = 'unknown')
+    OPEN(UNIT = iuwane, FILE = 'decay.epmate' // suffix, STATUS = 'unknown')
     WRITE(iuwane, '(a)') '#   R_e [Ang]    max_{m,n,nu} |g(m, n, nu, R_e, :)| [Ry] '
     DO ire = 1, nrr_k
       WRITE(iuwane, '(2f15.10, 1E20.10)') len1(ire) * alat * bohr2ang, MAXVAL(tmp(ire, :))
     ENDDO
     CLOSE(iuwane)
     !
-    OPEN(UNIT = iuwanep, FILE = 'decay.epmatp', STATUS = 'unknown')
+    OPEN(UNIT = iuwanep, FILE = 'decay.epmatp' // suffix, STATUS = 'unknown')
     WRITE(iuwanep, '(a)') '#   R_p [Ang]    max_{m,n,nu} |g(m, n, nu, :, R_p)| [Ry] '
     DO ir = 1, nrr_g
       WRITE(iuwanep, '(2f15.10, 1E20.10)') len2(ir) * alat * bohr2ang, MAXVAL(tmp(:, ir))
@@ -1254,7 +1270,7 @@
     ! -----------------------------------------------------------
     !
     !--------------------------------------------------------------------------
-    SUBROUTINE ephbloch2wanp_mem(nbnd, nmodes, xk, nq, irvec_k, irvec_g, nrr_k, nrr_g)
+    SUBROUTINE ephbloch2wanp_mem(nbnd, nmodes, xk, nq, irvec_k, irvec_g, nrr_k, nrr_g, iunepmatwe, iunepmatwp, suffix)
     !--------------------------------------------------------------------------
     !
     !!  From the EP matrix in electron-Wannier representation and
@@ -1267,7 +1283,7 @@
     USE kinds,            ONLY : DP
     USE cell_base,        ONLY : at, bg, alat
     USE constants_epw,    ONLY : bohr2ang, twopi, ci, czero, zero
-    USE io_var,           ONLY : iunepmatwe, iunepmatwp, iuwanep, iuwane
+    USE io_var,           ONLY : iuwanep, iuwane
     USE io_global,        ONLY : ionode_id, stdout
     USE mp_global,        ONLY : world_comm
     USE mp,               ONLY : mp_barrier, mp_bcast, mp_sum
@@ -1301,6 +1317,12 @@
     !! Coordinates of real space vector
     REAL(KIND = DP), INTENT(in) :: xk(3, nq)
     !! K-point coordinates (cartesian in units of 2piba)
+    INTEGER, INTENT(in) :: iunepmatwe
+    !! The unit with the e-ph matrix in Wannier-Bloch representation
+    INTEGER, INTENT(in) :: iunepmatwp
+    !! The unit with the e-ph matrix in Wannier-Wannier representation
+    CHARACTER(*), INTENT(in) :: suffix
+    !! Extra label for filenames
     !
     ! Local variables
     !
@@ -1392,23 +1414,23 @@
                                 INT(nmodes, KIND = MPI_OFFSET_KIND)
     !
     ! Open the epmatwe file
-    filint = TRIM(tmp_dir) // TRIM(prefix)//'.epmatwe1'
+    filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwe' // suffix // '1'
     CALL MPI_FILE_OPEN(world_comm, filint, MPI_MODE_RDONLY + MPI_MODE_DELETE_ON_CLOSE, MPI_INFO_NULL, iunepmatwe, ierr)
     !CALL MPI_FILE_OPEN(world_comm, filint, MPI_MODE_RDONLY, MPI_INFO_NULL, iunepmatwe, ierr)
     IF (ierr /= 0) CALL errore('ephbloch2wanp_mem', 'error in MPI_FILE_OPEN epmatwe', 1)
     !
     ! Open the epmatwp file
-    filint = TRIM(tmp_dir) // TRIM(prefix)//'.epmatwp'
+    filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwp' // suffix
     CALL MPI_FILE_OPEN(world_comm, filint, MPI_MODE_WRONLY + MPI_MODE_CREATE, MPI_INFO_NULL, iunepmatwp, ierr)
     IF (ierr /= 0) CALL errore('ephbloch2wanp_mem', 'error in MPI_FILE_OPEN epmatwp', 1)
 #else
     ! Size of the read array
     lsize = INT(2 * nbnd * nbnd * nrr_k * nmodes, KIND = 4)
-    filint   = TRIM(tmp_dir) // TRIM(prefix)//'.epmatwe'
-    CALL diropn(iunepmatwe, 'epmatwe', lsize, exst)
+    filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwe' // suffix
+    CALL diropn(iunepmatwe, 'epmatwe' // suffix, lsize, exst)
     IF (.NOT. exst) CALL errore('ephbloch2wanp_mem', 'file ' // TRIM(filint) // ' not found', 1)
     !
-    CALL diropn(iunepmatwp, 'epmatwp', lsize, exst)
+    CALL diropn(iunepmatwp, 'epmatwp' // suffix, lsize, exst)
 #endif
     !
     DO ir = ir_start, ir_stop + add
@@ -1486,14 +1508,14 @@
         len1(ire) = DSQRT(rvec1(1)**2.d0 + rvec1(2)**2.d0 + rvec1(3)**2.d0)
       ENDDO
       !
-      OPEN(UNIT = iuwane, FILE = 'decay.epmate', STATUS = 'unknown')
+      OPEN(UNIT = iuwane, FILE = 'decay.epmate' // suffix, STATUS = 'unknown')
       WRITE(iuwane, '(a)') '#   R_e [Ang]    max_{m,n,nu} |g(m, n, nu, R_e, :)| [Ry] '
       DO ire = 1, nrr_k
         WRITE(iuwane, '(2f15.10, 1E20.10)') len1(ire) * alat * bohr2ang, MAXVAL(tmp(ire, :))
       ENDDO
       CLOSE(iuwane)
       !
-      OPEN(UNIT = iuwanep, FILE = 'decay.epmatp', STATUS = 'unknown')
+      OPEN(UNIT = iuwanep, FILE = 'decay.epmatp' // suffix, STATUS = 'unknown')
       WRITE(iuwanep, '(a)') '#   R_p [Ang]    max_{m,n,nu} |g(m, n, nu, :, R_p)| [Ry] '
       DO ir = 1, nrr_g
         WRITE(iuwanep, '(2f15.10, 1E20.10)') len2(ir) * alat * bohr2ang, MAXVAL(tmp(:, ir))
diff --git a/EPW/src/close_epw.f90 b/EPW/src/close_epw.f90
index 5aa7549c2..41097c6c0 100644
--- a/EPW/src/close_epw.f90
+++ b/EPW/src/close_epw.f90
@@ -26,9 +26,9 @@
     !!
     USE kinds,         ONLY : DP
     USE io_var,        ONLY : iunepmat, iunsparseq,  &
-                              iunsparseqcb, iunepmatcb, iunepmatwp2
+                              iunsparseqcb, iunepmatcb, iunepmatwp2, iunepmatwpc2, iunepmatwpx2
     USE epwcom,        ONLY : iterative_bte, int_mob, carrier, etf_mem, assume_metal
-    USE epwcom,        ONLY : int_mob, carrier, ncarrier
+    USE epwcom,        ONLY : int_mob, carrier, ncarrier, lcdfpt, lxdfpt
 #if defined(__MPI)
     USE parallel_include, ONLY : MPI_MODE_WRONLY, MPI_MODE_CREATE, MPI_INFO_NULL
 #endif
@@ -43,6 +43,14 @@
     IF (etf_mem == 1) then
       CALL MPI_FILE_CLOSE(iunepmatwp2, ierr)
       IF (ierr /= 0) CALL errore('iter_close', 'error in MPI_FILE_CLOSE', 1)
+      IF (lcdfpt) THEN
+        CALL MPI_FILE_CLOSE(iunepmatwpc2, ierr)
+        IF (ierr /= 0) CALL errore('iter_close', 'error in MPI_FILE_CLOSE', 1)
+      ENDIF
+      IF (lxdfpt) THEN
+        CALL MPI_FILE_CLOSE(iunepmatwpx2, ierr)
+        IF (ierr /= 0) CALL errore('iter_close', 'error in MPI_FILE_CLOSE', 1)
+      ENDIF
     ENDIF
 #endif
     !
@@ -77,8 +85,8 @@
     USE phcom,             ONLY : drc, dyn
     USE noncollin_module,  ONLY : m_loc
     USE control_lr,        ONLY : nbnd_occ
-    USE elph2,             ONLY : epsi, etf, wkf, wqf, &
-                                  zstar, xkf, xqf
+    USE elph2,             ONLY : epsi, epsic, epsix, etf, wkf, wqf, &
+                                  zstar, zstarc, zstarx, xkf, xqf
     USE klist_epw,         ONLY : xk_all, xk_loc, xk_cryst, et_all, et_loc, &
                                   isk_loc, isk_all
     USE epwcom,            ONLY : epbread, epwread
@@ -101,7 +109,11 @@
       IF(ASSOCIATED(igkq))    DEALLOCATE(igkq)
       IF(ALLOCATED(dyn))      DEALLOCATE(dyn)
       IF(ALLOCATED(epsi))     DEALLOCATE(epsi)
+      IF(ALLOCATED(epsic))    DEALLOCATE(epsic)
+      IF(ALLOCATED(epsix))    DEALLOCATE(epsix)
       IF(ALLOCATED(zstar))    DEALLOCATE(zstar)
+      IF(ALLOCATED(zstarc))   DEALLOCATE(zstarc)
+      IF(ALLOCATED(zstarx))   DEALLOCATE(zstarx)
       IF(ALLOCATED(nbnd_occ)) DEALLOCATE(nbnd_occ)
       IF(ALLOCATED(m_loc))    DEALLOCATE(m_loc)
       IF(ALLOCATED(drc))      DEALLOCATE(drc)
diff --git a/EPW/src/dvqpsi.f90 b/EPW/src/dvqpsi.f90
index 32f4afb22..604458afa 100644
--- a/EPW/src/dvqpsi.f90
+++ b/EPW/src/dvqpsi.f90
@@ -60,6 +60,8 @@
     USE xc_lib,                ONLY : xclib_dft_is
     USE elph2,                 ONLY : lower_band, upper_band, ibndstart
     USE constants_epw,         ONLY : czero, eps12
+    USE Coul_cut_2D,           ONLY : do_cutoff_2D
+    USE Coul_cut_2D_ph,        ONLY : cutoff_localq
     !
     IMPLICIT NONE
     !
@@ -161,6 +163,7 @@
           gu = gu0 + g(1, ig) * u1 + g(2, ig) * u2 + g(3, ig) * u3
           aux1(dffts%nl(ig)) = aux1(dffts%nl(ig)) + vlocq(ig, nt) * gu * fact * gtau
         ENDDO
+        IF (do_cutoff_2D) CALL cutoff_localq(aux1, fact, u1, u2, u3, gu0, nt, na)
       ENDIF
     ENDDO
     !
@@ -600,6 +603,7 @@
     !!
     !! Roxana Margine - Dec 2018: Updated based on QE 6.3
     !! SP: Sept. 2019 - Cleaning
+    !! SP: Jan. 2022 - Addition 2D Coulomb
     !!
     !! HL: Mar 2020 - Parallelization over G using intra image communicator 
     !!
@@ -622,6 +626,8 @@
     USE constants_epw,    ONLY : zero, czero
     USE mp_images,        ONLY : intra_image_comm
     USE elph2,            ONLY : veff, ig_s, ig_e
+    USE Coul_cut_2D,      ONLY : do_cutoff_2D
+    USE Coul_cut_2D_ph,   ONLY : lr_Vlocq
     !
     IMPLICIT NONE
     !
@@ -773,12 +779,22 @@
                   !    nb is the atom of the augmentation function
                   !
                   nta = ityp(na)
-                  DO ig = 1, ngvec
-                    sk(ig) = vlocq(ig + ig_s - 1, nta) &
-                             * eigts1(mill(1, ig + ig_s - 1), na) &
-                             * eigts2(mill(2, ig + ig_s - 1), na) &
-                             * eigts3(mill(3, ig + ig_s - 1), na)
-                  ENDDO
+                  !
+                  IF (do_cutoff_2D) THEN
+                    DO ig = 1, ngvec
+                      sk(ig) = (vlocq(ig + ig_s - 1, nta) + lr_Vlocq(ig + ig_s - 1, nta)) &
+                               * eigts1(mill(1, ig + ig_s - 1), na) &
+                               * eigts2(mill(2, ig + ig_s - 1), na) &
+                               * eigts3(mill(3, ig + ig_s - 1), na)
+                    ENDDO
+                  ELSE
+                    DO ig = 1, ngvec
+                      sk(ig) = vlocq(ig + ig_s - 1, nta) &
+                               * eigts1(mill(1, ig + ig_s - 1), na) &
+                               * eigts2(mill(2, ig + ig_s - 1), na) &
+                               * eigts3(mill(3, ig + ig_s - 1), na)
+                    ENDDO
+                  ENDIF
                   !
                   DO ipol = 1, 3
                     DO ig = 1, ngvec
diff --git a/EPW/src/dynmat_asr.f90 b/EPW/src/dynmat_asr.f90
index 1ab26d146..aa4aa2ae0 100644
--- a/EPW/src/dynmat_asr.f90
+++ b/EPW/src/dynmat_asr.f90
@@ -1,6 +1,6 @@
   !-----------------------------------------------------------------------
-  SUBROUTINE dynmat_asr(iq_irr, nqc_irr, nq, iq_first, sxq, imq, isq, &
-                              invs, s, irt, rtau, sumr)
+  SUBROUTINE dynmat_asr(dvscf_dir, dynq, iq_irr, nqc_irr, nq, iq_first, sxq, imq, isq, &
+                        invs, s, irt, rtau, sumr, lpolar, qrpl, epsi, zstar, Qmat)
   !-----------------------------------------------------------------------
   !!
   !! read dynamical matrix for the q points, either in plain text or xml.
@@ -11,9 +11,8 @@
   use io_files,         ONLY : prefix
   USE cell_base,        ONLY : ibrav, celldm, omega, at, bg
   USE ions_base,        ONLY : amass, tau, nat, ntyp => nsp, ityp
-  USE elph2,            ONLY : dynq, zstar, epsi
   USE symm_base,        ONLY : nsym
-  USE epwcom,           ONLY : dvscf_dir, lpolar, lifc, nqc1, nqc2, nqc3
+  USE epwcom,           ONLY : lifc, nqc1, nqc2, nqc3, asr_typ
   USE modes,            ONLY : nmodes
   USE control_flags,    ONLY : iverbosity
   USE noncollin_module, ONLY : nspin_mag
@@ -32,6 +31,10 @@
   IMPLICIT NONE
   !
   ! Input
+  CHARACTER(LEN = 100), INTENT(IN) :: dvscf_dir
+  !! directory for .dvscf and .dyn files (wannier interpolation)
+  COMPLEX(KIND = DP) :: dynq(nmodes, nmodes, nqc1 * nqc2 * nqc3)
+  !! dynamical matrix for every q (nmode, nmodes, nqtot)
   INTEGER, INTENT(in) :: iq_irr
   !! The index of the irreducible q point
   INTEGER, INTENT(in) :: nqc_irr
@@ -56,6 +59,16 @@
   !! the relative position of the rotated atom to the original one
   REAL(KIND = DP), INTENT(inout) :: sumr(2, 3, nat, 3)
   !! Sum to impose the ASR
+  LOGICAL, INTENT(in) :: lpolar
+  !! if .TRUE. enable the correct Wannier interpolation in the case of polar material
+  LOGICAL, INTENT(in) :: qrpl
+  !! If true use quadrupole during interpolation
+  REAL(KIND = DP), INTENT(out) :: epsi(3, 3)
+  !! dielectric constant tensor
+  REAL(KIND = DP), INTENT(out) :: zstar(3, 3, nat)
+  !! effective charges tensor
+  REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+  !! Quadrupole tensor
   !
   ! Local variables
   LOGICAL :: found
@@ -238,17 +251,19 @@
       zstar = zstar_
       epsi = epsi_
       !ASR on effective charges
-      DO i = 1, 3
-        DO j = 1, 3
-          sumz = 0.0d0
-          DO na = 1,nat
-            sumz = sumz + zstar(i, j, na)
-          ENDDO
-          DO na = 1,nat
-            zstar(i, j, na) = zstar(i, j, na) - sumz / nat
+      IF (asr_typ /= 'none') THEN
+        DO i = 1, 3
+          DO j = 1, 3
+            sumz = 0.0d0
+            DO na = 1,nat
+              sumz = sumz + zstar(i, j, na)
+            ENDDO
+            DO na = 1,nat
+              zstar(i, j, na) = zstar(i, j, na) - sumz / nat
+            ENDDO
           ENDDO
         ENDDO
-      ENDDO
+      ENDIF
     ENDIF
     !
     ! If time-reversal is not included in the star of q, then double the nq to
@@ -279,25 +294,27 @@
       ! Impose the acoustic sum rule (q=0 needs to be the first q point in the coarse grid)
       ! [Gonze and Lee, PRB 55, 10361 (1998), Eq. (45) and (81)]
       !
-      IF (ABS(q(1, iq)) < eps6 .AND. ABS(q(2, iq)) < eps6 .AND. ABS(q(3, iq)) < eps6) THEN
-        WRITE(stdout, '(5x,a)') 'Imposing acoustic sum rule on the dynamical matrix'
-        IF (lpolar .AND. .NOT. lrigid) CALL errore('dynmat', &
-          &'You set lpolar = .TRUE. but did not put epsil = true in the PH calculation at Gamma. ',1)
-      ENDIF
-      DO na = 1, nat
-        DO ipol = 1, 3
-          DO jpol = ipol, 3
-            !
-            IF (ABS(q(1, iq)) < eps6 .AND. ABS(q(2, iq)) < eps6 .AND. ABS(q(3, iq)) < eps6 ) THEN
-              sumr(1, ipol, na, jpol) = SUM(dynr(1, ipol, na, jpol, :))
-              sumr(2, ipol, na, jpol) = SUM(dynr(2, ipol, na, jpol, :))
-            ENDIF
-            !
-            dynr(:, ipol, na, jpol, na) = dynr(:, ipol, na, jpol, na) - sumr(:, ipol, na, jpol)
-            !
+      IF (asr_typ /= 'none') THEN
+        IF (ABS(q(1, iq)) < eps6 .AND. ABS(q(2, iq)) < eps6 .AND. ABS(q(3, iq)) < eps6) THEN
+          WRITE(stdout, '(5x,a)') 'Imposing acoustic sum rule on the dynamical matrix'
+          IF (lpolar .AND. .NOT. lrigid) CALL errore('dynmat', &
+            &'You set lpolar = .TRUE. but did not put epsil = true in the PH calculation at Gamma. ',1)
+        ENDIF
+        DO na = 1, nat
+          DO ipol = 1, 3
+            DO jpol = ipol, 3
+              !
+              IF (ABS(q(1, iq)) < eps6 .AND. ABS(q(2, iq)) < eps6 .AND. ABS(q(3, iq)) < eps6 ) THEN
+                sumr(1, ipol, na, jpol) = SUM(dynr(1, ipol, na, jpol, :))
+                sumr(2, ipol, na, jpol) = SUM(dynr(2, ipol, na, jpol, :))
+              ENDIF
+              !
+              dynr(:, ipol, na, jpol, na) = dynr(:, ipol, na, jpol, na) - sumr(:, ipol, na, jpol)
+              !
+            ENDDO
           ENDDO
         ENDDO
-      ENDDO
+      ENDIF
       !
       ! Fill the two-indices dynamical matrix in cartesian coordinates
       ! the proper index in the complete list is iq_first+iq-1
@@ -393,23 +410,25 @@
         ! impose the acoustic sum rule (q=0 needs to be the first q point in the coarse grid)
         ! [Gonze and Lee, PRB 55, 10361 (1998), Eq. (45) and (81)]
         !
-        IF (ABS(q(1, iq)) < eps6 .AND. ABS(q(2, iq)) < eps6 .AND. ABS(q(3, iq)) < eps6) THEN
-          WRITE(stdout, '(5x,a)') 'Imposing acoustic sum rule on the dynamical matrix'
-        ENDIF
-        DO na = 1, nat
-          DO ipol = 1,3
-            DO jpol = ipol, 3
-              !
-              IF (ABS(q(1, iq)) < eps6 .AND. ABS(q(2, iq)) < eps6 .AND. ABS(q(3, iq)) < eps6) THEN
-                sumr(1, ipol, na, jpol) = SUM(dynr(1, ipol, na, jpol, :))
-                sumr(2, ipol, na, jpol) = SUM(dynr(2, ipol, na, jpol, :))
-              ENDIF
-              !
-              dynr(:, ipol, na, jpol, na) = dynr(:, ipol, na, jpol, na) - sumr(:, ipol, na, jpol)
-              !
+        IF (asr_typ /= 'none') THEN
+          IF (ABS(q(1, iq)) < eps6 .AND. ABS(q(2, iq)) < eps6 .AND. ABS(q(3, iq)) < eps6) THEN
+            WRITE(stdout, '(5x,a)') 'Imposing acoustic sum rule on the dynamical matrix'
+          ENDIF
+          DO na = 1, nat
+            DO ipol = 1,3
+              DO jpol = ipol, 3
+                !
+                IF (ABS(q(1, iq)) < eps6 .AND. ABS(q(2, iq)) < eps6 .AND. ABS(q(3, iq)) < eps6) THEN
+                  sumr(1, ipol, na, jpol) = SUM(dynr(1, ipol, na, jpol, :))
+                  sumr(2, ipol, na, jpol) = SUM(dynr(2, ipol, na, jpol, :))
+                ENDIF
+                !
+                dynr(:, ipol, na, jpol, na) = dynr(:, ipol, na, jpol, na) - sumr(:, ipol, na, jpol)
+                !
+              ENDDO
             ENDDO
           ENDDO
-        ENDDO
+        ENDIF
         !
         !  fill the two-indices dynamical matrix in cartesian coordinates
         !  the proper index in the complete list is iq_first+iq-1
@@ -450,17 +469,19 @@
           WRITE(stdout,'(5x,a)') 'Read dielectric tensor and effective charges'
           !
           !ASR on effective charges
-          DO i = 1, 3
-            DO j = 1, 3
-              sumz = 0.0d0
-              DO na = 1, nat
-                sumz = sumz + zstar(i, j, na)
-              ENDDO
-              DO na = 1, nat
-                zstar(i, j, na) = zstar(i, j, na) - sumz / nat
+          IF (asr_typ /= 'none') THEN
+            DO i = 1, 3
+              DO j = 1, 3
+                sumz = 0.0d0
+                DO na = 1, nat
+                  sumz = sumz + zstar(i, j, na)
+                ENDDO
+                DO na = 1, nat
+                  zstar(i, j, na) = zstar(i, j, na) - sumz / nat
+                ENDDO
               ENDDO
             ENDDO
-          ENDDO
+          ENDIF
           !
         ELSE
           IF (lpolar) CALL errore('dynmat_asr', &
@@ -526,7 +547,7 @@
     ! initialize WS r-vectors
     CALL wsinit(rws, nrwsx, nrws, atws)
     ! dynifc2blochc requires ifc
-    CALL dynifc2blochc(nmodes, rws, nrws, q(:, 1), dynq_tmp)
+    CALL dynifc2blochc(nmodes, rws, nrws, q(:, 1), dynq_tmp, lpolar, qrpl, epsi, zstar, Qmat)
     dynq(:, :, iq_first) = dynq_tmp
     WRITE(stdout, '(5x,a)') "Dyn mat calculated from ifcs"
     !
diff --git a/EPW/src/elph2.f90 b/EPW/src/elph2.f90
index 25b9a20a6..2108f212b 100644
--- a/EPW/src/elph2.f90
+++ b/EPW/src/elph2.f90
@@ -19,7 +19,9 @@
   LOGICAL ::                 &!
     elph,                    &!  Perform electron-phonon interpolation
     adapt_smearing,          &!  Adaptative smearing
-    qrpl                      !  If true use quadrupole during interpolation
+    qrpl,                    &!  If true use quadrupole during interpolation
+    qrplc,                   &!  If true use quadrupole during interpolation (cDFPT)
+    qrplx                     !  If true use quadrupole during interpolation (extra DFPT)
   LOGICAL, ALLOCATABLE ::    &!
     lwin(:, :),              &!  identify bands within outer energy windows (when disentanglement is used)
     lwinq(:, :),             &!  Excluded bands
@@ -82,11 +84,14 @@
     s_bztoibz(:)              !  Symmetry operation map for BZ to IBZ. This could be a INTEGER(KIND = 2) but does not work on all compilers
   REAL(KIND = DP) ::         &!
     efnew,                   &!  Fermi level on the fine grid. Added globaly for efficiency reason
+    efw0,                    &!  Fermi level for original smearing on the fine grid. Added globaly for efficiency reason
+    efw_inf,                 &!  Fermi level for very high smearing on the fine grid. Added globaly for efficiency reason
     deltaq,                  &!  Displacement of fine-mesh k-points for velocity corrections
     threshold,               &!  Threshold below which the transition probabilities are not written to file in transport.
     area,                    &!  Area of the 2D unit cell.
     g0vec_all_r(3, 125)       ! G-vectors needed to fold the k+q grid into the k grid, cartesian coord.
   REAL(KIND = DP), ALLOCATABLE ::&
+    efw(:),                  &!  Fermi levels for chosen smearings on the fine grid. Added globaly for efficiency reason
     a_all(:, :, :),          &!  electronic spectral function du to electron-phonon interaction
     a_all_ph(:, :, :),       &!  phononic spectral function du to electron-phonon interaction
     dos(:),                  &!  Density of states at the chemical potential.
@@ -104,6 +109,14 @@
     etf_k(:, :),             &!  Saved interpolated KS eigenenergies for later used in q-parallelization (nbnd, nkqf)
     etf_ks(:, :),            &!  interpolated eigenvalues (nbnd, nkqf) KS eigenvalues in the case of eig_read
     wf(:, :),                &!  interpolated eigenfrequencies
+    wfc(:, :),               &!  interpolated eigenfrequencies (cDFPT)
+    wfx(:, :),               &!  interpolated eigenfrequencies (extra DFPT)
+    wfr(:, :),               &!  interpolated eigenfrequencies (renormalized)
+    wfcr(:, :),              &!  interpolated eigenfrequencies (cDFPT, renormalized)
+    wfr1(:, :, :),           &!  interpolated eigenfrequencies (cDFPT+Pi)
+    wfr2(:, :, :),           &!  interpolated eigenfrequencies (DFPT-Pi+Pi)
+    wfw1(:, :, :),           &!  spectral function (cDFPT+Pi(omega))
+    wfw2(:, :, :),           &!  spectral function (DFPT-Pi+Pi(omega))
     gamma_all(:, :, :, :),      &!  Gamma
     gamma_nest(:, :),        &!  Nesting function in the case of q-parallelization
     gamma_v_all(:, :, :, :),    &!  Gamma
@@ -119,7 +132,11 @@
     jdos(:),                    &!  j-DOS
     spectra(:, :, :, :, :, :),  &!  dipole absorption spectra, polarizations, nomega, nsmear, dme/vme, absorption/emission
     zstar(:, :, :),             &!  Born effective charges
+    zstarc(:, :, :),            &!  Born effective charges (cDFPT)
+    zstarx(:, :, :),            &!  Born effective charges (extra DFPT)
     epsi(:, :),                 &!  dielectric tensor
+    epsic(:, :),                &!  dielectric tensor (cDFPT)
+    epsix(:, :),                &!  dielectric tensor (extra DFPT)
     inv_tau_all(:, :, :),       &!  scattering rate
     inv_tau_allcb(:, :, :),     &!  Conduction band scattering rate
     inv_tau_all_mode(:, :, :, :),    &!  mode resolved scattering rate
@@ -127,6 +144,10 @@
     zi_allvb(:, :, :),       &!  Z-factor in scattering rate
     zi_allcb(:, :, :),       &!  Second Z-factor in scattering rate (for both VB and CB calculations)
     ifc(:,:,:,:,:,:,:),      &!  Interatomic force constant in real space
+    ifcc(:,:,:,:,:,:,:),     &!  Interatomic force constant in real space (cDFPT)
+    ifcx(:,:,:,:,:,:,:),     &!  Interatomic force constant in real space (extra DFPT)
+    ifcr(:,:,:,:,:,:,:),     &!  Interatomic force constant in real space (renormalized)
+    ifccr(:,:,:,:,:,:,:),    &!  Interatomic force constant in real space (cDFPT, renormalized)
     omegap(:),               &!  Photon energy for phonon-assisted absorption
     epsilon2_abs(:, :, :, :),   &!  Imaginary part of dielectric function for phonon-assisted absorption, vs omega, vs broadening
     wscache(:, :, :, :, :),  &!  Use as cache when doing IFC when lifc = .TRUE.
@@ -152,7 +173,9 @@
     inv_tau_b(:, :, :),      &!  In case of B-field, scattering rate for non-zero inv_tau k-points on full BZ
     df_in_b(:, :, :, :, :),  &!  In case of B-field, derivative of f wrt k for non-zero inv_tau k-points on full BZ
     xkf_bz(:, :),            &!  In case of B-field, homogeneous k-point list on the full BZ for etf_mem /= 3
-    Qmat(:, :, :, :)          !  Quadrupole tensor
+    Qmat(:, :, :, :),        &!  Quadrupole tensor
+    Qmatc(:, :, :, :),       &!  Quadrupole tensor (cDFPT)
+    Qmatx(:, :, :, :)         !  Quadrupole tensor (extra DFPT)
   COMPLEX(KIND = DP), ALLOCATABLE :: &
     el_ph_mat(:, :, :, :),    &!  e-p matrix  (nbnd, nbnd, nks, 3*nat)
     cu(:, :, :),              &!  rot matrix for wannier interpolation of k point, coarse mesh (nbnd*nbnd*nkstot)
@@ -162,14 +185,31 @@
     cdmew(:, :, :, :),        &!  Dipole matrix in wannier basis
     cvmew(:, :, :, :),        &!  Velocity matrix in wannier basis
     rdw(:, :, :),             &!  dynamical matrix in wannier basis (real)
+    rdwc(:, :, :),            &!  dynamical matrix in wannier basis (real) (cDFPT)
+    rdwx(:, :, :),            &!  dynamical matrix in wannier basis (real) (extra DFPT)
+    rdwr(:, :, :),            &!  dynamical matrix in wannier basis (real) (renormalized)
+    rdwcr(:, :, :),           &!  dynamical matrix in wannier basis (real) (cDFPT, renormalized)
     epmatwp(:, :, :, :, :),   &!  e-p matrix  in wannier basis - electrons and phonons
+    epmatwpc(:, :, :, :, :),  &!  e-p matrix  in wannier basis - electrons and phonons (cDFPT)
+    epmatwpx(:, :, :, :, :),  &!  e-p matrix  in wannier basis - electrons and phonons (extra DFPT)
     umat(:, :, :),            &!  the rotation matrix for the unique setting of the wfs gauge -- on the local pool
     umatq(:, :, :),           &!  the rotation matrix for the unique setting of the wfs gauge for the k + q-- on the local pool
     umat_all(:, :, :),        &!  the rotation matrix for the unique setting of the wfs gauge -- for all k points
     umatq_all(:, :, :),       &!  the rotation matrix for the unique setting of the wfs gauge -- for all k+q points
     dynq(:, :, :),            &!  dynamical matrix for every q (nmode, nmodes, nqtot)
+    dynqc(:, :, :),           &!  dynamical matrix for every q (nmode, nmodes, nqtot) (cDFPT)
+    dynqx(:, :, :),           &!  dynamical matrix for every q (nmode, nmodes, nqtot) (extra DFPT)
+    dynqr(:, :, :),           &!  dynamical matrix for every q (nmode, nmodes, nqtot) (renormalized)
+    dynqcr(:, :, :),          &!  dynamical matrix for every q (nmode, nmodes, nqtot) (cDFPT, renormalized)
     epmatq(:, :, :, :, :),    &!  e-p matrix for every q (nbnd, nbnd, nks, nmodes, nqtot)
+    epmatqc(:, :, :, :, :),   &!  e-p matrix for every q (nbnd, nbnd, nks, nmodes, nqtot) (cDFPT)
+    epmatqx(:, :, :, :, :),   &!  e-p matrix for every q (nbnd, nbnd, nks, nmodes, nqtot) (extra DFPT)
+    epmatq0(:, :, :, :, :),   &!  e-p matrix for every q (nbnd, nbnd, nks, nmodes, nqtot) (including long-range part)
+    epmatqc0(:, :, :, :, :),  &!  e-p matrix for every q (nbnd, nbnd, nks, nmodes, nqtot) (cDFPT, including long-range part)
+    epmatqx0(:, :, :, :, :),  &!  e-p matrix for every q (nbnd, nbnd, nks, nmodes, nqtot) (extra DFPT, including long-range part)
     epf17(:, :, :, :),        &!  full ep matrix in bloch rep stored in mem (nkqtotf, nbnd, nbnd, nmodes)-nbnd inside wndw
+    epf17c(:, :, :, :),       &!  full ep matrix in bloch rep stored in mem (nkqtotf, nbnd, nbnd, nmodes)-nbnd inside wndw (cDFPT)
+    epf17x(:, :, :, :),       &!  full ep matrix in bloch rep stored in mem (nkqtotf, nbnd, nbnd, nmodes)-nbnd inside wndw (extra DFPT)
     dmec(:, :, :, :),         &!  dipole matrix elements on the coarse mesh (ipol, nbnd, nbnd, nks)
     dmef(:, :, :, :),         &!  dipole matrix elements on the fine   mesh (ipol, nbnd, nbnd, nks)
     vmef(:, :, :, :),         &!  velocity matrix elements on the fine mesh (ipol, nbnd, nbnd, nks)
diff --git a/EPW/src/elphel2_shuffle.f90 b/EPW/src/elphel2_shuffle.f90
index da78cd645..e2a71a965 100644
--- a/EPW/src/elphel2_shuffle.f90
+++ b/EPW/src/elphel2_shuffle.f90
@@ -8,7 +8,7 @@
   !
   !
   !---------------------------------------------------------------------
-  SUBROUTINE elphel2_shuffle( npe, imode0, dvscfins, gmapsym, eigv, isym, xq0, timerev )
+  SUBROUTINE elphel2_shuffle( npe, imode0, dvscfins, u, gmapsym, eigv, isym, xq0, timerev )
   !---------------------------------------------------------------------
   !!
   !! Calculation of the electron-phonon matrix elements el_ph_mat
@@ -75,7 +75,7 @@
   USE gvect,            ONLY : g
   USE uspp,             ONLY : vkb
   USE symm_base,        ONLY : s, ft
-  USE modes,            ONLY : u
+  USE modes,            ONLY : nmodes
   USE qpoint,           ONLY : xq, npwq
   USE eqv,              ONLY : dvpsi
   USE phcom,            ONLY : evq
@@ -111,6 +111,8 @@
   !! The first q-point in the star (cartesian coords.)
   COMPLEX(KIND = DP), INTENT(in) :: dvscfins(dffts%nnr, nspin_mag, npe)
   !! Delta scf potential
+  COMPLEX(KIND = DP), INTENT(in) :: u(nmodes, nmodes)
+  !! Displacement patterns
   COMPLEX(KIND = DP), INTENT(in) :: eigv (ngxxf)
   !! $e^{iGv}$ for 1...nsym (v the fractional translation)
   LOGICAL, INTENT(in) :: timerev
diff --git a/EPW/src/elphon_shuffle.f90 b/EPW/src/elphon_shuffle.f90
index 207614711..e99a5c126 100644
--- a/EPW/src/elphon_shuffle.f90
+++ b/EPW/src/elphon_shuffle.f90
@@ -7,7 +7,7 @@
   ! present distribution, or http://www.gnu.org/copyleft.gpl.txt .
   !
   !-----------------------------------------------------------------------
-  SUBROUTINE elphon_shuffle(iq_irr, nqc_irr, iq, gmapsym, eigv, isym, xq0, timerev)
+  SUBROUTINE elphon_shuffle(dvscf_dir, epmatq, u, iq_irr, nqc_irr, iq, gmapsym, eigv, isym, xq0, timerev)
   !-----------------------------------------------------------------------
   !!
   !! Electron-phonon calculation from data saved in fildvscf
@@ -28,8 +28,9 @@
   USE ions_base,        ONLY : nat
   USE pwcom,            ONLY : nbnd, nks
   USE gvecs,            ONLY : doublegrid
-  USE modes,            ONLY : nmodes, nirr, npert, u
-  USE elph2,            ONLY : epmatq, el_ph_mat, ibndstart, nbndep, ngxxf
+  USE modes,            ONLY : nmodes, nirr, npert
+  USE epwcom,           ONLY : nqc1, nqc2, nqc3
+  USE elph2,            ONLY : el_ph_mat, ibndstart, nbndep, ngxxf
   USE lrus,             ONLY : int3, int3_nc, int3_paw
   USE uspp,             ONLY : okvan
   USE paw_variables,    ONLY : okpaw
@@ -44,6 +45,13 @@
   !
   IMPLICIT NONE
   !
+  CHARACTER(LEN = 100), INTENT(IN) :: dvscf_dir
+  !! directory for .dvscf and .dyn files (wannier interpolation)
+  COMPLEX(KIND = DP), INTENT(INOUT) :: &
+    epmatq(nbndep, nbndep, nks, nmodes, nqc1 * nqc2 * nqc3)
+  !! e-p matrix for every q (nbnd, nbnd, nks, nmodes, nqtot)
+  COMPLEX(KIND = DP), INTENT(IN) :: u(nmodes, nmodes)
+  !! Displacement patterns
   INTEGER, INTENT(in) :: iq_irr
   !! Current ireducible q-point
   INTEGER, INTENT(in) :: nqc_irr
@@ -121,8 +129,8 @@
     !
     IF (my_pool_id == 0) THEN
       DO ipert = 1, npe
-        CALL readdvscf(dvscfin(:, :, ipert), imode0 + ipert, iq_irr, nqc_irr)
-        IF (okpaw) CALL readint3paw(int3_paw(:, :, :, :, ipert), imode0 + ipert, iq_irr, nqc_irr)
+        CALL readdvscf(dvscf_dir, dvscfin(:, :, ipert), imode0 + ipert, iq_irr, nqc_irr)
+        IF (okpaw) CALL readint3paw(dvscf_dir, int3_paw(:, :, :, :, ipert), imode0 + ipert, iq_irr, nqc_irr)
       ENDDO
     ENDIF
     !
@@ -146,7 +154,7 @@
     ENDIF
     !
     CALL newdq2(dvscfin, npe, xq0, timerev)
-    CALL elphel2_shuffle(npe, imode0, dvscfins, gmapsym, eigv, isym, xq0, timerev)
+    CALL elphel2_shuffle(npe, imode0, dvscfins, u, gmapsym, eigv, isym, xq0, timerev)
     !
     imode0 = imode0 + npe
     IF (doublegrid) THEN
diff --git a/EPW/src/elphon_shuffle_wrap.f90 b/EPW/src/elphon_shuffle_wrap.f90
index 83db475a1..6b90a2eb5 100644
--- a/EPW/src/elphon_shuffle_wrap.f90
+++ b/EPW/src/elphon_shuffle_wrap.f90
@@ -38,8 +38,9 @@
   USE eqv,           ONLY : vlocq, dmuxc
   USE ions_base,     ONLY : nat, nsp, tau, ityp, amass
   USE control_flags, ONLY : iverbosity
-  USE io_var,        ONLY : iuepb, iuqpeig, crystal, iunpattern, iuquad
+  USE io_var,        ONLY : iuepb, iuqpeig, crystal, iunpattern, iuquad, iudipole
   USE pwcom,         ONLY : nks, nbnd, nkstot, nelec
+  USE klist,         ONLY : degauss, ngauss
   USE cell_base,     ONLY : at, bg, alat, omega, tpiba
   USE symm_base,     ONLY : irt, s, nsym, ft, sname, invs, s_axis_to_cart,      &
                             sr, nrot, set_sym_bl, find_sym, inverse_s, t_rev,   &
@@ -51,11 +52,15 @@
   USE epwcom,        ONLY : epbread, epbwrite, epwread, lifc, etf_mem, vme,     &
                             nbndsub, iswitch, kmaps, eig_read, dvscf_dir,       &
                             nkc1, nkc2, nkc3, nqc1, nqc2, nqc3, lpolar,         &
-                            fixsym, epw_noinv, system_2d
+                            fixsym, epw_noinv, system_2d, cdfpt_dir, lcdfpt,    &
+                            lpolarc, lpolarx, xdfpt_dir, lxdfpt
   USE elph2,         ONLY : epmatq, dynq, et_ks, xkq, ifc, umat, umat_all, veff,&
                             zstar, epsi, cu, cuq, lwin, lwinq, bmat, nbndep,    &
                             ngxx, exband, wscache, area, ngxxf, ng0vec, shift,  &
-                            gmap, g0vec_all_r, Qmat, qrpl
+                            gmap, g0vec_all_r, Qmat, qrpl, dynqc, dynqcr,       &
+                            dynqr, dynqx, epmatq0, epmatqc, epmatqc0, epmatqx,  &
+                            epmatqx0, epsic, epsix, ifcc, ifccr, ifcr, ifcx,    &
+                            Qmatc, Qmatx, qrplc, qrplx, zstarc, zstarx
   USE klist_epw,     ONLY : et_loc, et_all
   USE constants_epw, ONLY : ryd2ev, zero, two, czero, eps6, eps8
   USE fft_base,      ONLY : dfftp
@@ -204,8 +209,22 @@
   !! The corresponding weigths
   COMPLEX(KIND = DP) :: cz1(nmodes, nmodes)
   !! The eigenvectors for the first q in the star
+  COMPLEX(KIND = DP) :: czc1(nmodes, nmodes)
+  !! The eigenvectors for the first q in the star (cDFPT)
+  COMPLEX(KIND = DP) :: czx1(nmodes, nmodes)
+  !! The eigenvectors for the first q in the star (extra DFPT)
   COMPLEX(KIND = DP) :: cz2(nmodes, nmodes)
   !! The rotated eigenvectors, for the current q in the star
+  COMPLEX(KIND = DP) :: czc2(nmodes, nmodes)
+  !! The rotated eigenvectors, for the current q in the star (cDFPT)
+  COMPLEX(KIND = DP) :: czx2(nmodes, nmodes)
+  !! The rotated eigenvectors, for the current q in the star (extra DFPT)
+  COMPLEX(KIND = DP) :: upat(nmodes, nmodes)
+  !! Displacement patterns
+  COMPLEX(KIND = DP) :: upatc(nmodes, nmodes)
+  !! Displacement patterns (cDFPT)
+  COMPLEX(KIND = DP) :: upatx(nmodes, nmodes)
+  !! Displacement patterns (extra DFPT)
   COMPLEX(KIND = DP), ALLOCATABLE :: eigv(:, :)
   !! $e^{ iGv}$ for 1...nsym (v the fractional translation)
   !
@@ -343,6 +362,8 @@
       READ(crystal, *) nat
       READ(crystal, *) nmodes
       READ(crystal, *) nelec
+      READ(crystal, *) degauss
+      READ(crystal, *) ngauss
       READ(crystal, *) at
       READ(crystal, *) bg
       READ(crystal, *) omega
@@ -362,6 +383,8 @@
     IF (mpime /= ionode_id) ALLOCATE(ityp(nat))
     CALL mp_bcast(nmodes   , ionode_id, world_comm)
     CALL mp_bcast(nelec    , ionode_id, world_comm)
+    CALL mp_bcast(degauss  , ionode_id, world_comm)
+    CALL mp_bcast(ngauss   , ionode_id, world_comm)
     CALL mp_bcast(at       , ionode_id, world_comm)
     CALL mp_bcast(bg       , ionode_id, world_comm)
     CALL mp_bcast(omega    , ionode_id, world_comm)
@@ -423,6 +446,102 @@
     WRITE(stdout, '(a)') '     '
   ENDIF ! exst
   !
+  IF (lcdfpt) THEN
+    ! If quadrupole file exist, read it (cDFPT)
+    IF (mpime == ionode_id) THEN
+      INQUIRE(FILE = 'quadrupolec.fmt', EXIST = exst)
+    ENDIF
+    CALL mp_bcast(exst, ionode_id, world_comm)
+    !
+    qrplc = .FALSE.
+    ALLOCATE(Qmatc(nat, 3, 3, 3), STAT = ierr)
+    IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating Qmatc', 1)
+    Qmatc(:, :, :, :) = zero
+    IF (exst) THEN
+      qrplc = .TRUE.
+      IF (mpime == ionode_id) THEN
+        OPEN(UNIT = iuquad, FILE = 'quadrupolec.fmt', STATUS = 'old', IOSTAT = ios)
+        READ(iuquad, *) dummy
+        DO i = 1, 3 * nat
+          READ(iuquad, *) na, idir, Qxx, Qyy, Qzz, Qyz, Qxz, Qxy
+          Qmatc(na, idir, 1, 1) = Qxx
+          Qmatc(na, idir, 2, 2) = Qyy
+          Qmatc(na, idir, 3, 3) = Qzz
+          Qmatc(na, idir, 2, 3) = Qyz
+          Qmatc(na, idir, 3, 2) = Qyz
+          Qmatc(na, idir, 1, 3) = Qxz
+          Qmatc(na, idir, 3, 1) = Qxz
+          Qmatc(na, idir, 1, 2) = Qxy
+          Qmatc(na, idir, 2, 1) = Qxy
+        ENDDO
+        CLOSE(iuquad)
+      ENDIF ! mpime == ionode_id
+      CALL mp_bcast(Qmatc, ionode_id, world_comm)
+      WRITE(stdout, '(a)') '     '
+      WRITE(stdout, '(a)') '     ------------------------------------------ '
+      WRITE(stdout, '(a)') '     cDFPT quadrupole tensor is correctly read: '
+      WRITE(stdout, '(a)') '     ------------------------------------------ '
+      WRITE(stdout, '(a)') '     atom   dir        Qxx       Qyy      Qzz        Qyz       Qxz       Qxy'
+      DO na = 1, nat
+        WRITE(stdout, '(i8, a,6f10.5)' ) na, '        x    ', Qmatc(na, 1, 1, 1), Qmatc(na, 1, 2, 2), Qmatc(na, 1, 3, 3), &
+                                                              Qmatc(na, 1, 2, 3), Qmatc(na, 1, 1, 3), Qmatc(na, 1, 1, 2)
+        WRITE(stdout, '(i8, a,6f10.5)' ) na, '        y    ', Qmatc(na, 2, 1, 1), Qmatc(na, 2, 2, 2), Qmatc(na, 2, 3, 3), &
+                                                              Qmatc(na, 2, 2, 3), Qmatc(na, 2, 1, 3), Qmatc(na, 2, 1, 2)
+        WRITE(stdout, '(i8, a,6f10.5)' ) na, '        z    ', Qmatc(na, 3, 1, 1), Qmatc(na, 3, 2, 2), Qmatc(na, 3, 3, 3), &
+                                                              Qmatc(na, 3, 2, 3), Qmatc(na, 3, 1, 3), Qmatc(na, 3, 1, 2)
+      ENDDO
+      WRITE(stdout, '(a)') '     '
+    ENDIF ! exst
+  ENDIF
+  !
+  IF (lxdfpt) THEN
+    ! If quadrupole file exist, read it (extra DFPT)
+    IF (mpime == ionode_id) THEN
+      INQUIRE(FILE = 'quadrupolex.fmt', EXIST = exst)
+    ENDIF
+    CALL mp_bcast(exst, ionode_id, world_comm)
+    !
+    qrplx = .FALSE.
+    ALLOCATE(Qmatx(nat, 3, 3, 3), STAT = ierr)
+    IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating Qmatx', 1)
+    Qmatx(:, :, :, :) = zero
+    IF (exst) THEN
+      qrplx = .TRUE.
+      IF (mpime == ionode_id) THEN
+        OPEN(UNIT = iuquad, FILE = 'quadrupolex.fmt', STATUS = 'old', IOSTAT = ios)
+        READ(iuquad, *) dummy
+        DO i = 1, 3 * nat
+          READ(iuquad, *) na, idir, Qxx, Qyy, Qzz, Qyz, Qxz, Qxy
+          Qmatx(na, idir, 1, 1) = Qxx
+          Qmatx(na, idir, 2, 2) = Qyy
+          Qmatx(na, idir, 3, 3) = Qzz
+          Qmatx(na, idir, 2, 3) = Qyz
+          Qmatx(na, idir, 3, 2) = Qyz
+          Qmatx(na, idir, 1, 3) = Qxz
+          Qmatx(na, idir, 3, 1) = Qxz
+          Qmatx(na, idir, 1, 2) = Qxy
+          Qmatx(na, idir, 2, 1) = Qxy
+        ENDDO
+        CLOSE(iuquad)
+      ENDIF ! mpime == ionode_id
+      CALL mp_bcast(Qmatx, ionode_id, world_comm)
+      WRITE(stdout, '(a)') '     '
+      WRITE(stdout, '(a)') '     ----------------------------------------------- '
+      WRITE(stdout, '(a)') '     Extra DFPT quadrupole tensor is correctly read: '
+      WRITE(stdout, '(a)') '     ----------------------------------------------- '
+      WRITE(stdout, '(a)') '     atom   dir        Qxx       Qyy      Qzz        Qyz       Qxz       Qxy'
+      DO na = 1, nat
+        WRITE(stdout, '(i8, a,6f10.5)' ) na, '        x    ', Qmatx(na, 1, 1, 1), Qmatx(na, 1, 2, 2), Qmatx(na, 1, 3, 3), &
+                                                              Qmatx(na, 1, 2, 3), Qmatx(na, 1, 1, 3), Qmatx(na, 1, 1, 2)
+        WRITE(stdout, '(i8, a,6f10.5)' ) na, '        y    ', Qmatx(na, 2, 1, 1), Qmatx(na, 2, 2, 2), Qmatx(na, 2, 3, 3), &
+                                                              Qmatx(na, 2, 2, 3), Qmatx(na, 2, 1, 3), Qmatx(na, 2, 1, 2)
+        WRITE(stdout, '(i8, a,6f10.5)' ) na, '        z    ', Qmatx(na, 3, 1, 1), Qmatx(na, 3, 2, 2), Qmatx(na, 3, 3, 3), &
+                                                              Qmatx(na, 3, 2, 3), Qmatx(na, 3, 1, 3), Qmatx(na, 3, 1, 2)
+      ENDDO
+      WRITE(stdout, '(a)') '     '
+    ENDIF ! exst
+  ENDIF
+  !
   IF (system_2d) area = omega * bg(3, 3) / alat
   IF (system_2d) WRITE(stdout, * ) '  Area is [Bohr^2] ', area
   !
@@ -430,6 +549,22 @@
     ALLOCATE(ifc(nqc1, nqc2, nqc3, 3, 3, nat, nat), STAT = ierr)
     IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating ifc', 1)
     ifc(:, :, :, :, :, :, :) = zero
+    IF (lcdfpt) THEN
+      ALLOCATE(ifcc(nqc1, nqc2, nqc3, 3, 3, nat, nat), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating ifcc', 1)
+      ifcc(:, :, :, :, :, :, :) = zero
+      ALLOCATE(ifcr(nqc1, nqc2, nqc3, 3, 3, nat, nat), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating ifcr', 1)
+      ifcr(:, :, :, :, :, :, :) = zero
+      ALLOCATE(ifccr(nqc1, nqc2, nqc3, 3, 3, nat, nat), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating ifccr', 1)
+      ifccr(:, :, :, :, :, :, :) = zero
+    ENDIF
+    IF (lxdfpt) THEN
+      ALLOCATE(ifcx(nqc1, nqc2, nqc3, 3, 3, nat, nat), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating ifcx', 1)
+      ifcx(:, :, :, :, :, :, :) = zero
+    ENDIF
   ENDIF
   !
   ! SP: Symmetries needs to be consistent with QE so that the order of the q in the star is the
@@ -473,18 +608,67 @@
     IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating lwinq', 1)
     ALLOCATE(exband(nbnd), STAT = ierr)
     IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating exband', 1)
+    ALLOCATE(epmatq0(nbndep, nbndep, nks, nmodes, nqc1 * nqc2 * nqc3), STAT = ierr)
+    IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating epmatq0', 1)
+    IF (lcdfpt) THEN
+      ALLOCATE(dynqc(nmodes, nmodes, nqc1 * nqc2 * nqc3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating dynqc', 1)
+      ALLOCATE(dynqr(nmodes, nmodes, nqc1 * nqc2 * nqc3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating dynqr', 1)
+      ALLOCATE(dynqcr(nmodes, nmodes, nqc1 * nqc2 * nqc3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating dynqcr', 1)
+      ALLOCATE(epmatqc(nbndep, nbndep, nks, nmodes, nqc1 * nqc2 * nqc3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating epmatqc', 1)
+      ALLOCATE(epmatqc0(nbndep, nbndep, nks, nmodes, nqc1 * nqc2 * nqc3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating epmatqc0', 1)
+      ALLOCATE(epsic(3, 3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating epsic', 1)
+      ALLOCATE(zstarc(3, 3, nat), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating zstarc', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      ALLOCATE(dynqx(nmodes, nmodes, nqc1 * nqc2 * nqc3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating dynqx', 1)
+      ALLOCATE(epmatqx(nbndep, nbndep, nks, nmodes, nqc1 * nqc2 * nqc3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating epmatqx', 1)
+      ALLOCATE(epmatqx0(nbndep, nbndep, nks, nmodes, nqc1 * nqc2 * nqc3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating epmatqx0', 1)
+      ALLOCATE(epsix(3, 3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating epsix', 1)
+      ALLOCATE(zstarx(3, 3, nat), STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error allocating zstarx', 1)
+    ENDIF
     dynq(:, :, :)         = czero
     epmatq(:, :, :, :, :) = czero
+    epmatq0(:, :, :, :, :)= czero
     epsi(:, :)            = zero
     zstar(:, :, :)        = zero
     bmat(:, :, :, :)      = czero
     cu(:, :, :)           = czero
     cuq(:, :, :)          = czero
     sxq(:, :)             = zero
+    IF (lcdfpt) THEN
+      dynqc(:, :, :)          = czero
+      dynqr(:, :, :)          = czero
+      dynqcr(:, :, :)         = czero
+      epmatqc(:, :, :, :, :)  = czero
+      epmatqc0(:, :, :, :, :) = czero
+      epsic(:, :)             = zero
+      zstarc(:, :, :)         = zero
+    ENDIF
+    IF (lxdfpt) THEN
+      dynqx(:, :, :)          = czero
+      epmatqx(:, :, :, :, :)  = czero
+      epmatqx0(:, :, :, :, :) = czero
+      epsix(:, :)             = zero
+      zstarx(:, :, :)         = zero
+    ENDIF
     !
     ! read interatomic force constat matrix from q2r
     IF (lifc) THEN
-      CALL read_ifc_epw
+      CALL read_ifc_epw(dvscf_dir, ifc, epsi, zstar)
+      IF (lcdfpt) CALL read_ifc_epw(cdfpt_dir, ifcc, epsic, zstarc)
+      IF (lxdfpt) CALL read_ifc_epw(xdfpt_dir, ifcx, epsix, zstarx)
     ENDIF
     !
     ! The following loop is required to propertly set up the symmetry matrix s.
@@ -550,6 +734,29 @@
                    'cannot open file for reading or writing', ierr)
          CALL read_disp_pattern_only(iunpattern, filename, iq_irr, ierr)
          IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', ' Problem with modes file', 1)
+         upat = u
+         !
+         IF (lcdfpt) THEN
+            dirname = TRIM(cdfpt_dir) // TRIM(prefix) // '.phsave'
+            filename = TRIM(dirname) // '/patterns.' // TRIM(int_to_char(iq_irr)) // '.xml'
+            INQUIRE(FILE = TRIM(filename), EXIST = exst)
+            IF (.NOT. exst) CALL errore('elphon_shuffle_wrap', &
+                      'cannot open file for reading or writing', ierr)
+            CALL read_disp_pattern_only(iunpattern, filename, iq_irr, ierr)
+            IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', ' Problem with modes file', 1)
+            upatc = u
+         ENDIF
+         !
+         IF (lxdfpt) THEN
+            dirname = TRIM(xdfpt_dir) // TRIM(prefix) // '.phsave'
+            filename = TRIM(dirname) // '/patterns.' // TRIM(int_to_char(iq_irr)) // '.xml'
+            INQUIRE(FILE = TRIM(filename), EXIST = exst)
+            IF (.NOT. exst) CALL errore('elphon_shuffle_wrap', &
+                      'cannot open file for reading or writing', ierr)
+            CALL read_disp_pattern_only(iunpattern, filename, iq_irr, ierr)
+            IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', ' Problem with modes file', 1)
+            upatx = u
+         ENDIF
       ENDIF
       !
       WRITE(stdout, '(//5x, a)') REPEAT('=', 67)
@@ -603,7 +810,67 @@
       !
       CALL sgam_lr(at, bg, nsym, s, irt, tau, rtau, nat)
       !
-      CALL dynmat_asr(iq_irr, nqc_irr, nq, iq_first, sxq, imq, isq, invs, s, irt, rtau, sumr)
+      CALL dynmat_asr(dvscf_dir, dynq, iq_irr, nqc_irr, nq, iq_first, &
+        sxq, imq, isq, invs, s, irt, rtau, sumr, lpolar, qrpl, epsi, zstar, Qmat)
+      IF (lcdfpt) CALL dynmat_asr(cdfpt_dir, dynqc, iq_irr, nqc_irr, nq, iq_first, &
+        sxq, imq, isq, invs, s, irt, rtau, sumr, lpolarc, qrplc, epsic, zstarc, Qmatc)
+      IF (lxdfpt) CALL dynmat_asr(xdfpt_dir, dynqx, iq_irr, nqc_irr, nq, iq_first, &
+        sxq, imq, isq, invs, s, irt, rtau, sumr, lpolarx, qrplx, epsix, zstarx, Qmatx)
+      !
+      ! If dipole file exist, read it
+      IF (mpime == ionode_id) THEN
+        INQUIRE(FILE = 'dipole.fmt', EXIST = exst)
+      ENDIF
+      CALL mp_bcast(exst, ionode_id, world_comm)
+      !
+      IF (exst) THEN
+        IF (mpime == ionode_id) THEN
+          OPEN(UNIT = iudipole, FILE = 'dipole.fmt', STATUS = 'old', IOSTAT = ios)
+          DO na = 1, nat
+            READ(iudipole, *) ((zstar(i, j, na), j = 1, 3), i = 1, 3)
+          ENDDO
+          CLOSE(iudipole)
+        ENDIF
+        CALL mp_bcast(zstar, ionode_id, world_comm)
+      ENDIF
+      !
+      IF (lcdfpt) THEN
+        ! If dipole file exist, read it (cDFPT)
+        IF (mpime == ionode_id) THEN
+          INQUIRE(FILE = 'dipolec.fmt', EXIST = exst)
+        ENDIF
+        CALL mp_bcast(exst, ionode_id, world_comm)
+        !
+        IF (exst) THEN
+          IF (mpime == ionode_id) THEN
+            OPEN(UNIT = iudipole, FILE = 'dipolec.fmt', STATUS = 'old', IOSTAT = ios)
+            DO na = 1, nat
+              READ(iudipole, *) ((zstarc(i, j, na), j = 1, 3), i = 1, 3)
+            ENDDO
+            CLOSE(iudipole)
+          ENDIF
+          CALL mp_bcast(zstarc, ionode_id, world_comm)
+        ENDIF
+      ENDIF
+      !
+      IF (lxdfpt) THEN
+        ! If dipole file exist, read it (extra DFPT)
+        IF (mpime == ionode_id) THEN
+          INQUIRE(FILE = 'dipolex.fmt', EXIST = exst)
+        ENDIF
+        CALL mp_bcast(exst, ionode_id, world_comm)
+        !
+        IF (exst) THEN
+          IF (mpime == ionode_id) THEN
+            OPEN(UNIT = iudipole, FILE = 'dipolex.fmt', STATUS = 'old', IOSTAT = ios)
+            DO na = 1, nat
+              READ(iudipole, *) ((zstarx(i, j, na), j = 1, 3), i = 1, 3)
+            ENDDO
+            CLOSE(iudipole)
+          ENDIF
+          CALL mp_bcast(zstarx, ionode_id, world_comm)
+        ENDIF
+      ENDIF
       !
       ! now dynq is the cartesian dyn mat (not divided by the masses)
       !
@@ -760,7 +1027,8 @@
         CALL loadumat(nbndep, nbndsub, nks, nkstot, xq, cu, cuq, lwin, lwinq, exband, w_centers)
         !
         ! Calculate overlap U_k+q U_k^\dagger
-        IF (lpolar .OR. qrpl) CALL compute_umn_c(nbndep, nbndsub, nks, cu, cuq, bmat(:, :, :, nqc))
+        IF (lpolar .OR. lpolarc .OR. lpolarx .OR. qrpl .OR. qrplc .OR. qrplx) &
+          CALL compute_umn_c(nbndep, nbndsub, nks, cu, cuq, bmat(:, :, :, nqc))
         !
         !   calculate the sandwiches
         !
@@ -770,14 +1038,26 @@
         ! are equal to 5+ digits).
         ! For any volunteers, please write to giustino@civet.berkeley.edu
         !
-        CALL elphon_shuffle(iq_irr, nqc_irr, nqc, gmapsym(:, isym1), eigv(:, isym1), isym, xq0, .FALSE.)
+        CALL elphon_shuffle(dvscf_dir, epmatq, upat, iq_irr, nqc_irr, nqc, &
+          gmapsym(:, isym1), eigv(:, isym1), isym, xq0, .FALSE., nqc1, nqc2, nqc3)
+        IF (lcdfpt) CALL elphon_shuffle(cdfpt_dir, epmatqc, upatc, iq_irr, nqc_irr, nqc, &
+          gmapsym(:, isym1), eigv(:, isym1), isym, xq0, .FALSE., nqc1, nqc2, nqc3)
+        IF (lxdfpt) CALL elphon_shuffle(xdfpt_dir, epmatqx, upatx, iq_irr, nqc_irr, nqc, &
+          gmapsym(:, isym1), eigv(:, isym1), isym, xq0, .FALSE., nqc1, nqc2, nqc3)
         !
         !  bring epmatq in the mode representation of iq_first,
         !  and then in the cartesian representation of iq
         !
-        CALL rotate_eigenm(iq_first, nqc, isym, s, invs, irt, rtau, xq, cz1, cz2)
+        CALL rotate_eigenm(dynq, iq_first, nqc, isym, s, invs, irt, rtau, xq, cz1, cz2)
+        IF (lcdfpt) CALL rotate_eigenm(dynqc, iq_first, nqc, isym, s, invs, irt, rtau, xq, czc1, czc2)
+        IF (lxdfpt) CALL rotate_eigenm(dynqx, iq_first, nqc, isym, s, invs, irt, rtau, xq, czx1, czx2)
         !
-        CALL rotate_epmat(cz1, cz2, xq, nqc, lwin, lwinq, exband)
+        CALL rotate_epmat(epmatq, epmatq0, cz1, cz2, xq, nqc, lwin, lwinq, exband, &
+          lpolar, qrpl, epsi, zstar, Qmat)
+        IF (lcdfpt) CALL rotate_epmat(epmatqc, epmatqc0, czc1, czc2, xq, nqc, lwin, lwinq, exband, &
+          lpolarc, qrplc, epsic, zstarc, Qmatc)
+        IF (lxdfpt) CALL rotate_epmat(epmatqx, epmatqx0, czx1, czx2, xq, nqc, lwin, lwinq, exband, &
+          lpolarx, qrplx, epsix, zstarx, Qmatx)
         !DBSP
         !write(*,*)'epmatq(:,:,2,:,nqc)',SUM(epmatq(:,:,2,:,nqc))
         !write(*,*)'epmatq(:,:,2,:,nqc)**2',SUM((REAL(REAL(epmatq(:,:,2,:,nqc))))**2)+&
@@ -810,17 +1090,30 @@
           CALL loadumat(nbndep, nbndsub, nks, nkstot, xq, cu, cuq, lwin, lwinq, exband, w_centers)
           !
           ! Calculate overlap U_k+q U_k^\dagger
-          IF (lpolar .OR. qrpl) CALL compute_umn_c(nbndep, nbndsub, nks, cu, cuq, bmat(:, :, :, nqc))
+          IF (lpolar .OR. lpolarc .OR. lpolarx .OR. qrpl .OR. qrplc .OR. lpolarx) &
+            CALL compute_umn_c(nbndep, nbndsub, nks, cu, cuq, bmat(:, :, :, nqc))
           !
           xq0 = -xq0
           !
-          CALL elphon_shuffle(iq_irr, nqc_irr, nqc, gmapsym(:, isym1), eigv(:, isym1), isym, xq0, .TRUE.)
+          CALL elphon_shuffle(dvscf_dir, epmatq, upat, iq_irr, nqc_irr, nqc, &
+            gmapsym(:, isym1), eigv(:, isym1), isym, xq0, .TRUE.)
+          IF (lcdfpt) CALL elphon_shuffle(cdfpt_dir, epmatqc, upatc, iq_irr, nqc_irr, nqc, &
+            gmapsym(:, isym1), eigv(:, isym1), isym, xq0, .TRUE.)
+          IF (lxdfpt) CALL elphon_shuffle(xdfpt_dir, epmatqx, upatx, iq_irr, nqc_irr, nqc, &
+            gmapsym(:, isym1), eigv(:, isym1), isym, xq0, .TRUE.)
           !  bring epmatq in the mode representation of iq_first,
           !  and then in the cartesian representation of iq
           !
-          CALL rotate_eigenm(iq_first, nqc, isym, s, invs, irt, rtau, xq, cz1, cz2)
+          CALL rotate_eigenm(dynq, iq_first, nqc, isym, s, invs, irt, rtau, xq, cz1, cz2)
+          IF (lcdfpt) CALL rotate_eigenm(dynqc, iq_first, nqc, isym, s, invs, irt, rtau, xq, czc1, czc2)
+          IF (lxdfpt) CALL rotate_eigenm(dynqx, iq_first, nqc, isym, s, invs, irt, rtau, xq, czx1, czx2)
           !
-          CALL rotate_epmat(cz1, cz2, xq, nqc, lwin, lwinq, exband)
+          CALL rotate_epmat(epmatq, epmatq0, cz1, cz2, xq, nqc, lwin, lwinq, exband, &
+            lpolar, qrpl, epsi, zstar, Qmat)
+          IF (lcdfpt) CALL rotate_epmat(epmatqc, epmatqc0, czc1, czc2, xq, nqc, lwin, lwinq, exband, &
+            lpolarc, qrplc, epsic, zstarc, Qmatc)
+          IF (lxdfpt) CALL rotate_epmat(epmatqx, epmatqx0, czx1, czx2, xq, nqc, lwin, lwinq, exband, &
+            lpolarx, qrplx, epsix, zstarx, Qmatx)
           !
           xq0 = -xq0
         ENDIF ! end imq == 0
@@ -909,7 +1202,9 @@
         IF (.NOT.  exst) CALL errore('elphon_shuffle_wrap', 'epb files not found ', 1)
         OPEN(iuepb, FILE = tempfile, FORM = 'unformatted')
         WRITE(stdout, '(/5x, "Reading epmatq from .epb files"/)')
-        READ(iuepb) nqc, xqc, et_loc, dynq, epmatq, zstar, epsi
+        READ(iuepb) nqc, xqc, et_loc, dynq, epmatq, epmatq0, zstar, epsi
+        IF (lcdfpt) READ(iuepb) dynqc, epmatqc, epmatqc0, zstarc, epsic
+        IF (lxdfpt) READ(iuepb) dynqx, epmatqx, epmatqx0, zstarx, epsix
         CLOSE(iuepb)
         WRITE(stdout, '(/5x, "The .epb files have been correctly read"/)')
       ENDIF
@@ -917,7 +1212,9 @@
       IF (epbwrite) THEN
         OPEN(iuepb, FILE = tempfile, FORM = 'unformatted')
         WRITE(stdout, '(/5x, "Writing epmatq on .epb files"/)')
-        WRITE(iuepb) nqc, xqc, et_loc, dynq, epmatq, zstar, epsi
+        WRITE(iuepb) nqc, xqc, et_loc, dynq, epmatq, epmatq0, zstar, epsi
+        IF (lcdfpt) WRITE(iuepb) dynqc, epmatqc, epmatqc0, zstarc, epsic
+        IF (lxdfpt) WRITE(iuepb) dynqx, epmatqx, epmatqx0, zstarx, epsix
         CLOSE(iuepb)
         WRITE(stdout, '(/5x, "The .epb files have been correctly written"/)')
       ENDIF
@@ -1000,6 +1297,18 @@
   IF (lifc) THEN
     DEALLOCATE(ifc, STAT = ierr)
     IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error deallocating ifc', 1)
+    IF (lcdfpt) THEN
+      DEALLOCATE(ifcc, STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error deallocating ifcc', 1)
+      DEALLOCATE(ifcr, STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error deallocating ifcr', 1)
+      DEALLOCATE(ifccr, STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error deallocating ifccr', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      DEALLOCATE(ifcx, STAT = ierr)
+      IF (ierr /= 0) CALL errore('elphon_shuffle_wrap', 'Error deallocating ifcx', 1)
+    ENDIF
   ENDIF
   !
   IF (epwread) THEN
diff --git a/EPW/src/ephwann_shuffle.f90 b/EPW/src/ephwann_shuffle.f90
index b8f005982..275eadb84 100644
--- a/EPW/src/ephwann_shuffle.f90
+++ b/EPW/src/ephwann_shuffle.f90
@@ -19,7 +19,8 @@
   !
   USE kinds,            ONLY : DP, i4b, i8b
   USE pwcom,            ONLY : nbnd, nks, nkstot, ef, nelec
-  USE klist_epw,        ONLY : et_loc, xk_loc, isk_dummy
+  USE klist,            ONLY : degauss, ngauss
+  USE klist_epw,        ONLY : et_loc, et_all, xk_loc, isk_dummy
   USE cell_base,        ONLY : at, bg
   USE ions_base,        ONLY : nat, amass, ityp, tau
   USE modes,            ONLY : nmodes
@@ -36,7 +37,9 @@
                                epmatkqread, selecqread, restart_step, nsmear,      &
                                nqc1, nqc2, nqc3, nkc1, nkc2, nkc3, assume_metal,   &
                                cumulant, eliashberg, nomega,                       &
-                               omegamin, omegamax, omegastep, neta
+                               omegamin, omegamax, omegastep, neta, eig_plot,      &
+                               lcdfpt, lpolarc, lpolarx, lxdfpt, phlabel, prtgkkc, &
+                               prtgkkx, temp_inf, type_inf, types
   USE control_flags,    ONLY : iverbosity
   USE noncollin_module, ONLY : noncolin
   USE constants_epw,    ONLY : ryd2ev, ryd2mev, one, two, zero, czero, eps40,      &
@@ -44,7 +47,9 @@
   USE io_files,         ONLY : prefix, diropn, tmp_dir
   USE io_global,        ONLY : stdout, ionode
   USE io_var,           ONLY : lambda_phself, linewidth_phself, iunepmatwe,        &
-                               iunepmatwp2, iunrestart, iuntau, iuntaucb, iunepmatwp
+                               iunepmatwp2, iunrestart, iuntau, iuntaucb,          &
+                               iunepmatwp, iunepmatwec, iunepmatwex, iunepmatwpc,  &
+                               iunepmatwpc2, iunepmatwpx, iunepmatwpx2
   USE elph2,            ONLY : cu, cuq, lwin, lwinq, map_rebal, map_rebal_inv,     &
                                chw, chw_ks, cvmew, cdmew, rdw, adapt_smearing,     &
                                epmatwp, epmatq, wf, etf, etf_ks, xqf, xkf,         &
@@ -59,7 +64,13 @@
                                nktotf, gtemp, xkq, dos, nbndskip, nbndep,          &
                                inv_tau_all_mode, inv_tau_allcb_mode, qrpl, Qmat,   &
                                ef0_fca, epsilon2_abs, epsilon2_abs_lorenz,         &
-                               epsilon2_abs_all, epsilon2_abs_lorenz_all
+                               epsilon2_abs_all, epsilon2_abs_lorenz_all, dynqc,   &
+                               dynqcr, dynqr, dynqx, efw, efw0, efw_inf, epf17c,   &
+                               epf17x, epmatqc, epmatqx, epmatwpc, epmatwpx,       &
+                               epsic, epsix, ifc, ifcc, ifccr, ifcr, ifcx, Qmatc,  &
+                               Qmatx, qrplc, qrplx, rdwc, rdwcr, rdwr, rdwx,  wfc, &
+                               wfcr, wfr, wfr1, wfr2, wfw1, wfw2, wfx, zstarc,     &
+                               zstarx
   USE wan2bloch,        ONLY : dmewan2bloch, hamwan2bloch, dynwan2bloch,           &
                                ephwan2blochp, ephwan2bloch, vmewan2bloch,          &
                                dynifc2blochf, vmewan2blochp
@@ -71,7 +82,7 @@
                                check_restart_ephwrite
   USE transport,        ONLY : transport_coeffs, scattering_rate_q
   USE grid,             ONLY : qwindow, loadkmesh_fst, xqf_otf
-  USE printing,         ONLY : print_gkk, plot_band, plot_fermisurface
+  USE printing,         ONLY : print_gkk, plot_band_elec, plot_band_phon, plot_fermisurface
   USE io_epw,           ONLY : rwepmatw, epw_read, epw_write
   USE io_transport,     ONLY : tau_read, iter_open, print_ibte, iter_merge
   USE io_selfen,        ONLY : selfen_el_read, spectral_read
@@ -86,7 +97,7 @@
   USE utilities,        ONLY : compute_dos, broadening, fermicarrier, fermiwindow
   USE grid,             ONLY : loadqmesh_serial, loadkmesh_para, load_rebal
   USE selfen,           ONLY : selfen_phon_q, selfen_elec_q, selfen_pl_q,          &
-                               nesting_fn_q
+                               nesting_fn_q, unscreen_dynq, renorm_phon_q
   USE spectral_func,    ONLY : spectral_func_el_q, spectral_func_ph_q, a2f_main,   &
                                spectral_func_pl_q
   USE rigid_epw,        ONLY : rpa_epsilon, tf_epsilon, compute_umn_f, rgd_blk_epw_fine !, &
@@ -277,6 +288,14 @@
   !! Eigen-energies on the fine grid collected from all pools in parallel case
   REAL(KIND = DP), ALLOCATABLE :: w2(:)
   !! Interpolated phonon frequency
+  REAL(KIND = DP), ALLOCATABLE :: w2c(:)
+  !! Interpolated phonon frequency (cDFPT)
+  REAL(KIND = DP), ALLOCATABLE :: w2x(:)
+  !! Interpolated phonon frequency (extra DFPT)
+  REAL(KIND = DP), ALLOCATABLE :: w2r(:)
+  !! Interpolated phonon frequency (renormalized)
+  REAL(KIND = DP), ALLOCATABLE :: w2cr(:)
+  !! Interpolated phonon frequency (cDFPT, renormalized)
   REAL(KIND = DP), ALLOCATABLE :: irvec_r(:, :)
   !! Wigner-Size supercell vectors, store in real instead of integer
   REAL(KIND = DP), ALLOCATABLE :: rdotk(:)
@@ -293,20 +312,50 @@
   !! velocity from all the k-point
   REAL(KIND = DP), ALLOCATABLE :: wkf_all(:)
   !! k-point weights for all the k-points
+  REAL(KIND = DP), ALLOCATABLE :: uf_real(:, :)
+  !! Rotation matrix for phonons (two real instead of one complex number each)
   COMPLEX(KIND = DP), ALLOCATABLE :: epmatwe(:, :, :, :, :)
   !! e-p matrix  in wannier basis - electrons
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatwec(:, :, :, :, :)
+  !! e-p matrix  in wannier basis - electrons (cDFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatwex(:, :, :, :, :)
+  !! e-p matrix  in wannier basis - electrons (extra DFPT)
   COMPLEX(KIND = DP), ALLOCATABLE :: epmatwe_mem(:, :, :, :)
   !! e-p matrix  in wannier basis - electrons (written on disk)
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatwec_mem(:, :, :, :)
+  !! e-p matrix  in wannier basis - electrons (written on disk) (cDFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatwex_mem(:, :, :, :)
+  !! e-p matrix  in wannier basis - electrons (written on disk) (extra DFPT)
   COMPLEX(KIND = DP), ALLOCATABLE :: epmatwef(:, :, :, :)
   !! e-p matrix  in el wannier - fine Bloch phonon grid
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatwefc(:, :, :, :)
+  !! e-p matrix  in el wannier - fine Bloch phonon grid (cDPFT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatwefx(:, :, :, :)
+  !! e-p matrix  in el wannier - fine Bloch phonon grid (extra DPFT)
   COMPLEX(KIND = DP), ALLOCATABLE :: epmatf(:, :, :)
   !! e-p matrix  in smooth Bloch basis, fine mesh
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatfc(:, :, :)
+  !! e-p matrix  in smooth Bloch basis, fine mesh (cDPFT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatfx(:, :, :)
+  !! e-p matrix  in smooth Bloch basis, fine mesh (extra DPFT)
   COMPLEX(KIND = DP), ALLOCATABLE :: cufkk(:, :)
   !! Rotation matrix, fine mesh, points k
   COMPLEX(KIND = DP), ALLOCATABLE :: cufkq(:, :)
   !! the same, for points k+q
   COMPLEX(KIND = DP), ALLOCATABLE :: uf(:, :)
   !! Rotation matrix for phonons
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufc(:, :)
+  !! Rotation matrix for phonons (cDFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufx(:, :)
+  !! Rotation matrix for phonons (extra DFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufr(:, :)
+  !! Rotation matrix for phonons (renormalized)
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufcr(:, :)
+  !! Rotation matrix for phonons (cDFPT, renormalized)
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufr1(:, :, :, :)
+  !! Rotation matrix for phonons (cDFPT+Pi)
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufr2(:, :, :, :)
+  !! Rotation matrix for phonons (DFPT-Pi+Pi)
   COMPLEX(KIND = DP), ALLOCATABLE :: bmatf(:, :)
   !! overlap U_k+q U_k^\dagger in smooth Bloch basis, fine mesh
   COMPLEX(KIND = DP), ALLOCATABLE :: cfac(:, :, :)
@@ -341,12 +390,28 @@
   ALLOCATE(w2(3 * nat), STAT = ierr)
   IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating w2', 1)
   w2(:) = zero
+  IF (lcdfpt) THEN
+    ALLOCATE(w2c(3 * nat), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating w2c', 1)
+    w2c(:) = zero
+    ALLOCATE(w2r(3 * nat), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating w2r', 1)
+    w2r(:) = zero
+    ALLOCATE(w2cr(3 * nat), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating w2cr', 1)
+    w2cr(:) = zero
+  ENDIF
+  IF (lxdfpt) THEN
+    ALLOCATE(w2x(3 * nat), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating w2x', 1)
+    w2x(:) = zero
+  ENDIF
   !
-  IF (lpolar) THEN
+  IF (lpolar .OR. lpolarc .OR. lpolarx) THEN
     WRITE(stdout, '(/,5x,a)' ) 'Computes the analytic long-range interaction for polar materials [lpolar]'
     WRITE(stdout, '(5x,a)' )   ' '
   ENDIF
-  IF (.NOT. lpolar .AND. qrpl) THEN
+  IF (.NOT. lpolar .AND. qrpl .OR. .NOT. lpolarc .AND. qrplc .OR. .NOT. lpolarx .AND. qrplx) THEN
     WRITE(stdout, '(/,5x,a)' ) 'Computes the analytic quadrupole long-range interaction for non-polar materials [Q1,Q2]'
     WRITE(stdout, '(5x,a)' )   ' '
   ENDIF
@@ -422,6 +487,18 @@
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating chw_ks', 1)
     ALLOCATE(rdw(nmodes, nmodes, nrr_q), STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating rdw', 1)
+    IF (lcdfpt) THEN
+      ALLOCATE(rdwc(nmodes, nmodes, nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating rdwc', 1)
+      ALLOCATE(rdwr(nmodes, nmodes, nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating rdwr', 1)
+      ALLOCATE(rdwcr(nmodes, nmodes, nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating rdwcr', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      ALLOCATE(rdwx(nmodes, nmodes, nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating rdwx', 1)
+    ENDIF
     IF (vme == 'wannier') THEN
       ALLOCATE(cvmew(3, nbndsub, nbndsub, nrr_k), STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating cvmew', 1)
@@ -440,10 +517,40 @@
       IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatwp', 1)
       epmatwe(:, :, :, :, :) = czero
       epmatwp(:, :, : ,: ,:) = czero
+      IF (lcdfpt) THEN
+        ALLOCATE(epmatwec(nbndsub, nbndsub, nrr_k, nmodes, nqc), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatwec', 1)
+        ALLOCATE(epmatwpc(nbndsub, nbndsub, nrr_k, nmodes, nrr_g), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatwpc', 1)
+        epmatwec(:, :, :, :, :) = czero
+        epmatwpc(:, :, : ,: ,:) = czero
+      ENDIF
+      IF (lxdfpt) THEN
+        ALLOCATE(epmatwex(nbndsub, nbndsub, nrr_k, nmodes, nqc), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatwex', 1)
+        ALLOCATE(epmatwpx(nbndsub, nbndsub, nrr_k, nmodes, nrr_g), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatwpx', 1)
+        epmatwex(:, :, :, :, :) = czero
+        epmatwpx(:, :, : ,: ,:) = czero
+      ENDIF
     ELSE
       ALLOCATE(epmatwe_mem(nbndsub, nbndsub, nrr_k, nmodes), STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatwe_mem', 1)
       epmatwe_mem(:, :, :, :) = czero
+      IF (lcdfpt) THEN
+        ALLOCATE(epmatwec_mem(nbndsub, nbndsub, nrr_k, nmodes), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatwec_mem', 1)
+        epmatwec_mem(:, :, :, :) = czero
+      ENDIF
+      IF (lxdfpt) THEN
+        ALLOCATE(epmatwex_mem(nbndsub, nbndsub, nrr_k, nmodes), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatwex_mem', 1)
+        epmatwex_mem(:, :, :, :) = czero
+      ENDIF
+    ENDIF
+    !
+    IF (lcdfpt) THEN
+      CALL unscreen_dynq(xqc)
     ENDIF
     !
     ! Hamiltonian
@@ -468,7 +575,16 @@
     !
     ! Dynamical Matrix
     !
-    IF (.NOT. lifc) CALL dynbloch2wan(nmodes, nqc, xqc, dynq, nrr_q, irvec_q, wslen_q)
+    IF (.NOT. lifc) THEN
+      CALL dynbloch2wan(nmodes, nqc, xqc, dynq, rdw, nrr_q, irvec_q, wslen_q, lpolar, qrpl, epsi, zstar, Qmat, '')
+      IF (lcdfpt) THEN
+        CALL dynbloch2wan(nmodes, nqc, xqc, dynqc, rdwc, nrr_q, irvec_q, wslen_q, lpolarc, qrplc, epsic, zstarc, Qmatc, 'c')
+        CALL dynbloch2wan(nmodes, nqc, xqc, dynqr, rdwr, nrr_q, irvec_q, wslen_q, lpolar, qrpl, epsi, zstar, Qmat, 'r')
+        CALL dynbloch2wan(nmodes, nqc, xqc, dynqcr, rdwcr, nrr_q, irvec_q, wslen_q, lpolar, qrpl, epsi, zstar, Qmat, 'cr')
+      ENDIF
+      IF (lxdfpt) CALL dynbloch2wan(nmodes, nqc, xqc, dynqx, rdwx, nrr_q, irvec_q, wslen_q, &
+        lpolarx, qrplx, epsix, zstarx, Qmatx, 'x')
+    ENDIF
     !
     !
     ! Electron-Phonon vertex (Bloch el and Bloch ph -> Wannier el and Bloch ph)
@@ -477,6 +593,8 @@
     IF ((etf_mem == 1 .OR. etf_mem == 3) .AND. ionode) THEN
       lrepmatw = 2 * nbndsub * nbndsub * nrr_k * nmodes
       CALL diropn(iunepmatwe, 'epmatwe', lrepmatw, exst)
+      IF (lcdfpt) CALL diropn(iunepmatwec, 'epmatwec', lrepmatw, exst)
+      IF (lxdfpt) CALL diropn(iunepmatwex, 'epmatwex', lrepmatw, exst)
     ENDIF
     !
     WRITE(stdout, '(a)' ) ' '
@@ -498,10 +616,17 @@
         IF (etf_mem == 0) THEN
           CALL ephbloch2wane(nbndep, nbndsub, nks, nkstot, xk_loc, cu, cuq, &
             epmatq(:, :, :, imode, iq), nrr_k, irvec_k, wslen_k, epmatwe(:, :, :, imode, iq))
+          IF (lcdfpt) CALL ephbloch2wane(nbndep, nbndsub, nks, nkstot, xk_loc, cu, cuq, &
+            epmatqc(:, :, :, imode, iq), nrr_k, irvec_k, wslen_k, epmatwec(:, :, :, imode, iq))
+          IF (lxdfpt) CALL ephbloch2wane(nbndep, nbndsub, nks, nkstot, xk_loc, cu, cuq, &
+            epmatqx(:, :, :, imode, iq), nrr_k, irvec_k, wslen_k, epmatwex(:, :, :, imode, iq))
         ELSE
           CALL ephbloch2wane(nbndep, nbndsub, nks, nkstot, xk_loc, cu, cuq, &
             epmatq(:, :, :, imode, iq), nrr_k, irvec_k, wslen_k, epmatwe_mem(:, :, :, imode))
-          !
+          IF (lcdfpt) CALL ephbloch2wane(nbndep, nbndsub, nks, nkstot, xk_loc, cu, cuq, &
+            epmatqc(:, :, :, imode, iq), nrr_k, irvec_k, wslen_k, epmatwec_mem(:, :, :, imode))
+          IF (lxdfpt) CALL ephbloch2wane(nbndep, nbndsub, nks, nkstot, xk_loc, cu, cuq, &
+            epmatqx(:, :, :, imode, iq), nrr_k, irvec_k, wslen_k, epmatwex_mem(:, :, :, imode))
         ENDIF
         !
       ENDDO
@@ -509,22 +634,37 @@
       IF ((etf_mem == 1 .OR. etf_mem == 3) .AND. ionode) THEN
         ! direct write of epmatwe for this iq
         CALL rwepmatw(epmatwe_mem, nbndsub, nrr_k, nmodes, iq, iunepmatwe, +1)
-        !
+        IF (lcdfpt) CALL rwepmatw(epmatwec_mem, nbndsub, nrr_k, nmodes, iq, iunepmatwec, +1)
+        IF (lxdfpt) CALL rwepmatw(epmatwex_mem, nbndsub, nrr_k, nmodes, iq, iunepmatwex, +1)
       ENDIF
       !
     ENDDO
     WRITE(stdout, '(a)' ) ' '
     !
-    IF ((etf_mem == 1 .OR. etf_mem == 3) .AND. ionode) CLOSE(iunepmatwe, STATUS = 'keep')
+    IF ((etf_mem == 1 .OR. etf_mem == 3) .AND. ionode) THEN
+      CLOSE(iunepmatwe, STATUS = 'keep')
+      IF (lcdfpt) CLOSE(iunepmatwec, STATUS = 'keep')
+      IF (lxdfpt) CLOSE(iunepmatwex, STATUS = 'keep')
+    ENDIF
     !
     ! Electron-Phonon vertex (Wannier el and Bloch ph -> Wannier el and Wannier ph)
     !
     IF (etf_mem == 0) THEN
-      IF (ionode) CALL ephbloch2wanp(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g, epmatwe)
+      IF (ionode) CALL ephbloch2wanp(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g, epmatwe, epmatwp, '')
       CALL mp_bcast(epmatwp, ionode_id, world_comm)
+      IF (lcdfpt) THEN
+        IF (ionode) CALL ephbloch2wanp(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g, epmatwec, epmatwpc, 'c')
+        CALL mp_bcast(epmatwpc, ionode_id, world_comm)
+      ENDIF
+      IF (lxdfpt) THEN
+        IF (ionode) CALL ephbloch2wanp(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g, epmatwex, epmatwpx, 'x')
+        CALL mp_bcast(epmatwpx, ionode_id, world_comm)
+      ENDIF
     ENDIF
     IF (etf_mem > 0) THEN
-      CALL ephbloch2wanp_mem(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g)
+      CALL ephbloch2wanp_mem(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g, iunepmatwe, iunepmatwp, '')
+      IF (lcdfpt) CALL ephbloch2wanp_mem(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g, iunepmatwec, iunepmatwpc, 'c')
+      IF (lxdfpt) CALL ephbloch2wanp_mem(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g, iunepmatwex, iunepmatwpx, 'x')
     ENDIF
     !
     IF (epwwrite) THEN
@@ -535,13 +675,45 @@
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatq', 1)
     DEALLOCATE(dynq, STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating dynq', 1)
+    IF (lcdfpt) THEN
+      DEALLOCATE(epmatqc, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatqc', 1)
+      DEALLOCATE(dynqc, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating dynqc', 1)
+      DEALLOCATE(dynqr, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating dynqr', 1)
+      DEALLOCATE(dynqcr, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating dynqcr', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      DEALLOCATE(epmatqx, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatqx', 1)
+      DEALLOCATE(dynqx, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating dynqx', 1)
+    ENDIF
     IF (vme == 'dipole') DEALLOCATE(dmec)
     IF (etf_mem == 0) THEN
       DEALLOCATE(epmatwe, STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwe', 1)
+      IF (lcdfpt) THEN
+        DEALLOCATE(epmatwec, STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwec', 1)
+      ENDIF
+      IF (lxdfpt) THEN
+        DEALLOCATE(epmatwex, STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwex', 1)
+      ENDIF
     ELSE
       DEALLOCATE(epmatwe_mem, STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwe_mem', 1)
+      IF (lcdfpt) THEN
+        DEALLOCATE(epmatwec_mem, STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwec_mem', 1)
+      ENDIF
+      IF (lxdfpt) THEN
+        DEALLOCATE(epmatwex_mem, STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwex_mem', 1)
+      ENDIF
     ENDIF
     DEALLOCATE(cu, STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating cu', 1)
@@ -582,6 +754,36 @@
     ALLOCATE(wf(nmodes, nqtotf), STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wf', 1)
     wf(:, :) = zero
+    IF (lcdfpt) THEN
+      ALLOCATE(wfc(nmodes, nqtotf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfc', 1)
+      wfc(:, :) = zero
+      ALLOCATE(wfr(nmodes, nqtotf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfr', 1)
+      wfr(:, :) = zero
+      ALLOCATE(wfcr(nmodes, nqtotf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfcr', 1)
+      wfcr(:, :) = zero
+      ALLOCATE(wfr1(nmodes, nqtotf, nstemp), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfr1', 1)
+      wfr1(:, :, :) = zero
+      ALLOCATE(wfr2(nmodes, nqtotf, nstemp), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfr2', 1)
+      wfr2(:, :, :) = zero
+      IF (specfun_ph) THEN
+        ALLOCATE(wfw1(nw_specfun, nqtotf, nstemp), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfw1', 1)
+        wfw1(:, :, :) = zero
+        ALLOCATE(wfw2(nw_specfun, nqtotf, nstemp), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfw2', 1)
+        wfw2(:, :, :) = zero
+      ENDIF
+    ENDIF
+    IF (lxdfpt) THEN
+      ALLOCATE(wfx(nmodes, nqtotf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfx', 1)
+      wfx(:, :) = zero
+    ENDIF
   ENDIF
   ! Defines the total number of k-points
   nktotf = nkqtotf / 2
@@ -606,6 +808,34 @@
   IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating eps_rpa', 1)
   ALLOCATE(isk_dummy(nkqf), STAT = ierr)
   IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating isk_dummy', 1)
+  IF (lcdfpt) THEN
+    ALLOCATE(epmatwefc(nbndsub, nbndsub, nrr_k, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatwefc', 1)
+    ALLOCATE(epmatfc(nbndsub, nbndsub, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatfc', 1)
+    ALLOCATE(ufc(nmodes, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating ufc', 1)
+    ALLOCATE(ufr(nmodes, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating ufr', 1)
+    ALLOCATE(ufcr(nmodes, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating ufcr', 1)
+    ALLOCATE(ufr1(nmodes, nmodes, nstemp, nqtotf), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating ufr1', 1)
+    ALLOCATE(ufr2(nmodes, nmodes, nstemp, nqtotf), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating ufr2', 1)
+    IF (eig_plot) THEN
+      ALLOCATE(uf_real(2 * nmodes * nmodes, nqtotf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating uf_real', 1)
+    ENDIF
+  ENDIF
+  IF (lxdfpt) THEN
+    ALLOCATE(epmatwefx(nbndsub, nbndsub, nrr_k, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatwefx', 1)
+    ALLOCATE(epmatfx(nbndsub, nbndsub, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epmatfx', 1)
+    ALLOCATE(ufx(nmodes, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating ufx', 1)
+  ENDIF
   epmatwef(:, :, :, :) = czero
   etf(:, :)            = zero
   etf_ks(:, :)         = zero
@@ -616,6 +846,20 @@
   bmatf(:, :)          = czero
   eps_rpa(:)           = czero
   isk_dummy(:)         = 0
+  IF (lcdfpt) THEN
+    epmatwefc(:, :, :, :) = czero
+    epmatfc(:, :, :)      = czero
+    ufc(:, :)             = czero
+    ufr(:, :)             = czero
+    ufcr(:, :)            = czero
+    ufr1(:, :, :, :)      = czero
+    ufr2(:, :, :, :)      = czero
+  ENDIF
+  IF (lxdfpt) THEN
+    epmatwefx(:, :, :, :) = czero
+    epmatfx(:, :, :)      = czero
+    ufx(:, :)             = czero
+  ENDIF
   !
   ! Allocate velocity and dipole matrix elements after getting grid size
   IF (vme == 'wannier') THEN
@@ -711,7 +955,7 @@
       ENDIF
     ENDIF
     !
-  ELSEIF (band_plot) THEN
+  ELSEIF (band_plot .AND. .NOT. lcdfpt) THEN
     !
     WRITE(stdout, '(/5x,a)') REPEAT('=',67)
     WRITE(stdout, '(/5x,"Fermi energy corresponds to the coarse k-mesh")')
@@ -756,6 +1000,32 @@
     !
     ef = efnew
   ENDIF
+  !
+  IF (lcdfpt) THEN
+    IF (degauss > zero) THEN
+      efw0 = efermig(etf, nbndsub, nkqf, nelec, wkf, degauss, ngauss, 0, isk_dummy)
+    ELSE
+      efw0 = ef
+    ENDIF
+    !
+    ALLOCATE(efw(nstemp))
+    !
+    IF (efermi_read) THEN
+      efw = fermi_energy
+      efw_inf = fermi_energy
+    ELSE
+      DO itemp = 1, nstemp
+        efw(itemp) = efermig(etf, nbndsub, nkqf, nelec, wkf, gtemp(itemp), types(itemp), 0, isk_dummy)
+      ENDDO
+      !
+      IF (temp_inf > zero) THEN
+        efw_inf = efermig(etf, nbndsub, nkqf, nelec, wkf, temp_inf, type_inf, 0, isk_dummy)
+      ELSE
+        efw_inf = ef
+      ENDIF
+    ENDIF
+  ENDIF
+  !
   ! ------------------------------------------------------------
   ! Apply a possible shift to eigenenergies (applied later)
   icbm = 1
@@ -813,16 +1083,38 @@
     filint = TRIM(tmp_dir) // TRIM(prefix)//'.epmatwp'
     CALL MPI_FILE_OPEN(world_comm, filint, MPI_MODE_RDONLY, MPI_INFO_NULL, iunepmatwp2, ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'error in MPI_FILE_OPEN', 1)
+    IF (lcdfpt) THEN
+      filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwpc'
+      CALL MPI_FILE_OPEN(world_comm, filint, MPI_MODE_RDONLY, MPI_INFO_NULL, iunepmatwpc2, ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'error in MPI_FILE_OPEN (2)', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwpx'
+      CALL MPI_FILE_OPEN(world_comm, filint, MPI_MODE_RDONLY, MPI_INFO_NULL, iunepmatwpx2, ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'error in MPI_FILE_OPEN (2)', 1)
+    ENDIF
   ENDIF
 #else
   lrepmatw = 2 * nbndsub * nbndsub * nrr_k * nmodes
-  filint = TRIM(tmp_dir) // TRIM(prefix)//'.epmatwp'
+  filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwp'
   INQUIRE(IOLENGTH = direct_io_factor) dummy(1)
   unf_recl = direct_io_factor * INT(lrepmatw, KIND = KIND(unf_recl))
   IF (unf_recl <= 0) CALL errore('epw_write', 'wrong record length', 3)
   OPEN(iunepmatwp, FILE = TRIM(ADJUSTL(filint)), IOSTAT = ierr, FORM='unformatted', &
        STATUS = 'unknown', ACCESS = 'direct', RECL = unf_recl)
   IF (ierr /= 0) CALL errore('epw_write', 'error opening ' // TRIM(filint), 1)
+  IF (lcdfpt) THEN
+    filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwpc'
+    OPEN(iunepmatwpc, FILE = TRIM(ADJUSTL(filint)), IOSTAT = ierr, FORM='unformatted', &
+         STATUS = 'unknown', ACCESS = 'direct', RECL = unf_recl)
+    IF (ierr /= 0) CALL errore('epw_write', 'error opening ' // TRIM(filint), 1)
+  ENDIF
+  IF (lxdfpt) THEN
+    filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwpx'
+    OPEN(iunepmatwpx, FILE = TRIM(ADJUSTL(filint)), IOSTAT = ierr, FORM='unformatted', &
+         STATUS = 'unknown', ACCESS = 'direct', RECL = unf_recl)
+    IF (ierr /= 0) CALL errore('epw_write', 'error opening ' // TRIM(filint), 1)
+  ENDIF
 #endif
   !
   ! get the size of the matrix elements stored in each pool
@@ -977,11 +1269,49 @@
     ! Fine mesh set of g-matrices.  It is large for memory storage
     ALLOCATE(epf17(nbndfst, nbndfst, nmodes, nkf), STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epf17', 1)
+    IF (lcdfpt) THEN
+      ALLOCATE(epf17c(nbndfst, nbndfst, nmodes, nkf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epf17c', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      ALLOCATE(epf17x(nbndfst, nbndfst, nmodes, nkf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating epf17x', 1)
+    ENDIF
     ! We allocate the phonon frequency on the q-points within the window
     IF (etf_mem == 3) THEN
       ALLOCATE(wf(nmodes, totq), STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wf', 1)
       wf(:, :) = zero
+      IF (lcdfpt) THEN
+        ALLOCATE(wfc(nmodes, totq), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfc', 1)
+        wfc(:, :) = zero
+        ALLOCATE(wfr(nmodes, totq), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfr', 1)
+        wfr(:, :) = zero
+        ALLOCATE(wfcr(nmodes, totq), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfcr', 1)
+        wfcr(:, :) = zero
+        ALLOCATE(wfr1(nmodes, totq, nstemp), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfr1', 1)
+        wfr1(:, :, :) = zero
+        ALLOCATE(wfr2(nmodes, totq, nstemp), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfr2', 1)
+        wfr2(:, :, :) = zero
+        IF (specfun_ph) THEN
+          ALLOCATE(wfw1(nw_specfun, totq, nstemp), STAT = ierr)
+          IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfw1', 1)
+          wfw1(:, :, :) = zero
+          ALLOCATE(wfw2(nw_specfun, totq, nstemp), STAT = ierr)
+          IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfw2', 1)
+          wfw2(:, :, :) = zero
+        ENDIF
+      ENDIF
+      IF (lxdfpt) THEN
+        ALLOCATE(wfx(nmodes, totq), STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating wfx', 1)
+        wfx(:, :) = zero
+      ENDIF
     ENDIF
     IF (phonselfen) THEN
       ALLOCATE(lambda_all(nmodes, totq, nsmear, nstemp), STAT = ierr)
@@ -1008,7 +1338,7 @@
       esigmai_all(:, :, :, :) = zero
       a_all(:, :, :) = zero
     ENDIF
-    IF (specfun_ph) THEN
+    IF (specfun_ph .AND. .NOT. lcdfpt) THEN
       ALLOCATE(a_all_ph(nw_specfun, totq, nstemp), STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating a_all_ph', 1)
       a_all_ph(:, :, :) = zero
@@ -1212,6 +1542,8 @@
       CALL start_clock ('ep-interp')
       !
       epf17(:, :, :, :) = czero
+      IF (lcdfpt) epf17c(:, :, :, :) = czero
+      IF (lxdfpt) epf17x(:, :, :, :) = czero
       cufkk(:, :) = czero
       cufkq(:, :) = czero
       !
@@ -1247,9 +1579,21 @@
       ! ------------------------------------------------------
       !
       IF (.NOT. lifc) THEN
-        CALL dynwan2bloch(nmodes, nrr_q, irvec_q, ndegen_q, xxq, uf, w2)
+        CALL dynwan2bloch(rdw, nmodes, nrr_q, irvec_q, ndegen_q, xxq, uf, w2, lpolar, qrpl, epsi, zstar, Qmat)
+        IF (lcdfpt) THEN
+          CALL dynwan2bloch(rdwc, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufc, w2c, lpolarc, qrplc, epsic, zstarc, Qmatc)
+          CALL dynwan2bloch(rdwr, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufr, w2r, lpolar, qrpl, epsi, zstar, Qmat)
+          CALL dynwan2bloch(rdwcr, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufcr, w2cr, lpolar, qrpl, epsi, zstar, Qmat)
+        ENDIF
+        IF (lxdfpt) CALL dynwan2bloch(rdwx, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufx, w2x, lpolarx, qrplx, epsix, zstarx, Qmatx)
       ELSE
-        CALL dynifc2blochf(nmodes, rws, nrws, xxq, uf, w2)
+        CALL dynifc2blochf(ifc, nmodes, rws, nrws, xxq, uf, w2, lpolar, qrpl, epsi, zstar, Qmat)
+        IF (lcdfpt) THEN
+          CALL dynifc2blochf(ifcc, nmodes, rws, nrws, xxq, ufc, w2c, lpolarc, qrplc, epsic, zstarc, Qmatc)
+          CALL dynifc2blochf(ifcr, nmodes, rws, nrws, xxq, ufr, w2r, lpolar, qrpl, epsi, zstar, Qmat)
+          CALL dynifc2blochf(ifccr, nmodes, rws, nrws, xxq, ufcr, w2cr, lpolar, qrpl, epsi, zstar, Qmat)
+        ENDIF
+        IF (lxdfpt) CALL dynifc2blochf(ifcx, nmodes, rws, nrws, xxq, ufx, w2x, lpolarx, qrplx, epsix, zstarx, Qmatx)
       ENDIF
       !
       ! ...then take into account the mass factors and square-root the frequencies...
@@ -1264,10 +1608,22 @@
         ELSE
           wf(nu, qind) = -DSQRT(ABS(w2(nu)))
         ENDIF
+        IF (lcdfpt) THEN
+          wfc(nu, qind) = SIGN(DSQRT(ABS(w2c(nu))), w2c(nu))
+          wfr(nu, qind) = SIGN(DSQRT(ABS(w2r(nu))), w2r(nu))
+          wfcr(nu, qind) = SIGN(DSQRT(ABS(w2cr(nu))), w2cr(nu))
+        ENDIF
+        IF (lxdfpt) wfx(nu, qind) = SIGN(DSQRT(ABS(w2x(nu))), w2x(nu))
         !
         DO mu = 1, nmodes
           na = (mu - 1) / 3 + 1
           uf(mu, nu) = uf(mu, nu) / DSQRT(amass(ityp(na)))
+          IF (lcdfpt) THEN
+            ufc(mu, nu) = ufc(mu, nu) / DSQRT(amass(ityp(na)))
+            ufr(mu, nu) = ufr(mu, nu) / DSQRT(amass(ityp(na)))
+            ufcr(mu, nu) = ufcr(mu, nu) / DSQRT(amass(ityp(na)))
+          ENDIF
+          IF (lxdfpt) ufx(mu, nu) = ufx(mu, nu) / DSQRT(amass(ityp(na)))
         ENDDO
       ENDDO
       !
@@ -1276,7 +1632,12 @@
       ! --------------------------------------------------------------
       !
       IF (.NOT. longrange) THEN
-        CALL ephwan2blochp(nmodes, xxq, irvec_g, ndegen_g, nrr_g, uf, epmatwef, nbndsub, nrr_k, dims, dims2)
+        CALL ephwan2blochp(epmatwp, iunepmatwp, iunepmatwp2, nmodes, &
+          xxq, irvec_g, ndegen_g, nrr_g, uf, epmatwef, nbndsub, nrr_k, dims, dims2)
+        IF (lcdfpt) CALL ephwan2blochp(epmatwpc, iunepmatwpc, iunepmatwpc2, nmodes, &
+          xxq, irvec_g, ndegen_g, nrr_g, ufc, epmatwefc, nbndsub, nrr_k, dims, dims2)
+        IF (lxdfpt) CALL ephwan2blochp(epmatwpx, iunepmatwpx, iunepmatwpx2, nmodes, &
+          xxq, irvec_g, ndegen_g, nrr_g, ufx, epmatwefx, nbndsub, nrr_k, dims, dims2)
       ENDIF
       !
       ! Number of k points with a band on the Fermi surface
@@ -1414,25 +1775,36 @@
             IF (longrange) THEN
               !
               epmatf(:, :, :) = czero
+              IF (lcdfpt) epmatfc(:, :, :) = czero
+              IF (lxdfpt) epmatfx(:, :, :) = czero
               !
             ELSE
               !
               epmatf(:, :, :) = czero
               CALL ephwan2bloch(nbndsub, nrr_k, epmatwef, cufkk, cufkq, epmatf, nmodes, cfac, dims)
+              IF (lcdfpt) THEN
+                 epmatfc(:, :, :) = czero
+                 CALL ephwan2bloch(nbndsub, nrr_k, epmatwefc, cufkk, cufkq, epmatfc, nmodes, cfac, dims)
+              ENDIF
+              IF (lxdfpt) THEN
+                 epmatfx(:, :, :) = czero
+                 CALL ephwan2bloch(nbndsub, nrr_k, epmatwefx, cufkk, cufkq, epmatfx, nmodes, cfac, dims)
+              ENDIF
               !
             ENDIF
             !
-            IF (lpolar .OR. qrpl) THEN
+            IF (lpolar .OR. lpolarc .OR. lpolarx .OR. qrpl .OR. qrplc .OR. qrplx) THEN
               !
               CALL compute_umn_f(nbndsub, cufkk, cufkq, bmatf)
               !
-              IF ((ABS(xxq(1)) > eps8) .OR. (ABS(xxq(2)) > eps8) .OR. (ABS(xxq(3)) > eps8)) THEN
-                !
-                CALL cryst_to_cart(1, xxq, bg, 1)
-                CALL rgd_blk_epw_fine(nqc1, nqc2, nqc3, xxq, uf, epmatf, nmodes, epsi, zstar, bmatf, one)
-                CALL cryst_to_cart(1, xxq, at, -1)
-                !
-              ENDIF
+              CALL cryst_to_cart(1, xxq, bg, 1)
+              IF (lpolar .OR. qrpl) CALL rgd_blk_epw_fine(nqc1, nqc2, nqc3, xxq, uf, epmatf, nmodes, &
+                lpolar, epsi, zstar, Qmat, bmatf, one)
+              IF (lpolarc .OR. qrplc) CALL rgd_blk_epw_fine(nqc1, nqc2, nqc3, xxq, ufc, epmatfc, nmodes, &
+                lpolarc, epsic, zstarc, Qmatc, bmatf, one)
+              IF (lpolarx .OR. qrplx) CALL rgd_blk_epw_fine(nqc1, nqc2, nqc3, xxq, ufx, epmatfx, nmodes, &
+                lpolarx, epsix, zstarx, Qmatx, bmatf, one)
+              CALL cryst_to_cart(1, xxq, at, -1)
               !
             ENDIF
             !
@@ -1445,6 +1817,8 @@
                 ELSE
                    epf17(ibnd - ibndmin + 1, jbnd - ibndmin + 1, :, ik) = epmatf(ibnd, jbnd, :)
                 ENDIF
+                IF (lcdfpt) epf17c(ibnd - ibndmin + 1, jbnd - ibndmin + 1, :, ik) = epmatfc(ibnd, jbnd, :)
+                IF (lxdfpt) epf17x(ibnd - ibndmin + 1, jbnd - ibndmin + 1, :, ik) = epmatfx(ibnd, jbnd, :)
               ENDDO
             ENDDO
             !
@@ -1485,13 +1859,17 @@
       ENDIF
       ! --------------------------------------------------------------------------------------------------
       !
-      IF (prtgkk    ) CALL print_gkk(iq)
+      IF (prtgkk    ) CALL print_gkk(iq, epf17, wf, totq)
+      IF (prtgkkc   ) CALL print_gkk(iq, epf17c, wfc, totq)
+      IF (prtgkkx   ) CALL print_gkk(iq, epf17x, wfx, totq)
       IF (phonselfen) CALL selfen_phon_q(iqq, iq, totq)
+      IF (lcdfpt    ) CALL renorm_phon_q(iq, w2, uf, w2c, ufc, w2x, ufx, w2r, ufr, w2cr, ufcr, &
+                                         ufr1(:, :, :, iq), ufr2(:, :, :, iq))
       IF (elecselfen) CALL selfen_elec_q(iqq, iq, totq, first_cycle)
       IF (plselfen .AND. vme == 'dipole') CALL selfen_pl_q(iqq, iq, totq, first_cycle)
       IF (nest_fn   ) CALL nesting_fn_q(iqq, iq)
       IF (specfun_el) CALL spectral_func_el_q(iqq, iq, totq, first_cycle)
-      IF (specfun_ph) CALL spectral_func_ph_q(iqq, iq, totq)
+      IF (specfun_ph .AND. .NOT. lcdfpt) CALL spectral_func_ph_q(iqq, iq, totq)
       IF (specfun_pl .AND. vme == 'dipole') CALL spectral_func_pl_q(iqq, iq, totq, first_cycle)
       IF (ephwrite) THEN
         IF (first_cycle .OR. iq == 1) THEN
@@ -1600,9 +1978,21 @@
       DO iq = iq_restart, nqf
         xxq = xqf(:, iq)
         IF (.NOT. lifc) THEN
-          CALL dynwan2bloch(nmodes, nrr_q, irvec_q, ndegen_q, xxq, uf, w2)
+          CALL dynwan2bloch(rdw, nmodes, nrr_q, irvec_q, ndegen_q, xxq, uf, w2, lpolar, qrpl, epsi, zstar, Qmat)
+          IF (lcdfpt) THEN
+            CALL dynwan2bloch(rdwc, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufc, w2c, lpolarc, qrplc, epsic, zstarc, Qmatc)
+            CALL dynwan2bloch(rdwr, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufr, w2r, lpolar, qrpl, epsi, zstar, Qmat)
+            CALL dynwan2bloch(rdwcr, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufcr, w2cr, lpolar, qrpl, epsi, zstar, Qmat)
+          ENDIF
+          IF (lxdfpt) CALL dynwan2bloch(rdwx, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufx, w2x, lpolarx, qrplx, epsix, zstarx, Qmatx)
         ELSE
-          CALL dynifc2blochf(nmodes, rws, nrws, xxq, uf, w2)
+          CALL dynifc2blochf(ifc, nmodes, rws, nrws, xxq, uf, w2, lpolar, qrpl, epsi, zstar, Qmat)
+          IF (lcdfpt) THEN
+            CALL dynifc2blochf(ifcc, nmodes, rws, nrws, xxq, ufc, w2c, lpolarc, qrplc, epsic, zstarc, Qmatc)
+            CALL dynifc2blochf(ifcr, nmodes, rws, nrws, xxq, ufr, w2r, lpolar, qrpl, epsi, zstar, Qmat)
+            CALL dynifc2blochf(ifccr, nmodes, rws, nrws, xxq, ufcr, w2cr, lpolar, qrpl, epsi, zstar, Qmat)
+          ENDIF
+          IF (lxdfpt) CALL dynifc2blochf(ifcx, nmodes, rws, nrws, xxq, ufx, w2x, lpolarx, qrplx, epsix, zstarx, Qmatx)
         ENDIF
         !
         DO nu = 1, nmodes
@@ -1613,6 +2003,12 @@
           ELSE
             wf(nu, iq) = -SQRT(ABS(w2(nu)))
           ENDIF
+          IF (lcdfpt) THEN
+            wfc(nu, iq) = SIGN(DSQRT(ABS(w2c(nu))), w2c(nu))
+            wfr(nu, iq) = SIGN(DSQRT(ABS(w2r(nu))), w2r(nu))
+            wfcr(nu, iq) = SIGN(DSQRT(ABS(w2cr(nu))), w2cr(nu))
+          ENDIF
+          IF (lxdfpt) wfx(nu, iq) = SIGN(DSQRT(ABS(w2x(nu))), w2x(nu))
         ENDDO
       ENDDO
       !
@@ -1690,7 +2086,54 @@
         ENDDO ! itempphen
       ENDIF
     ENDIF
-    IF (band_plot) CALL plot_band()
+    IF (band_plot) THEN
+      WRITE(filint, "(A, '.freq')") TRIM(phlabel)
+      CALL plot_band_phon(TRIM(filint), wf)
+      !
+      IF (lcdfpt) THEN
+        WRITE(filint, "(A, 'c.freq')") TRIM(phlabel)
+        CALL plot_band_phon(TRIM(filint), wfc)
+        !
+        WRITE(filint, "(A, 'cr.freq')") TRIM(phlabel)
+        CALL plot_band_phon(TRIM(filint), wfcr)
+        !
+        WRITE(filint, "(A, 'r.freq')") TRIM(phlabel)
+        CALL plot_band_phon(TRIM(filint), wfr)
+        !
+        DO itemp = 1, nstemp
+          WRITE(filint, "(A, 'cr', I0, '.freq')") TRIM(phlabel), itemp
+          CALL plot_band_phon(TRIM(filint), wfr1(:, :, itemp))
+          !
+          WRITE(filint, "(A, 'r', I0, '.freq')") TRIM(phlabel), itemp
+          CALL plot_band_phon(TRIM(filint), wfr2(:, :, itemp))
+          !
+          IF (eig_plot) THEN
+            WRITE(filint, "(A, 'cre', I0, '.freq')") TRIM(phlabel), itemp
+            uf_real(1::2, :) = RESHAPE(REAL(ufr1(:, :, itemp, :)), (/nmodes * nmodes, nqtotf/))
+            uf_real(2::2, :) = RESHAPE(AIMAG(ufr1(:, :, itemp, :)), (/nmodes * nmodes, nqtotf/))
+            CALL plot_band_phon(TRIM(filint), uf_real)
+            !
+            WRITE(filint, "(A, 're', I0, '.freq')") TRIM(phlabel), itemp
+            uf_real(1::2, :) = RESHAPE(REAL(ufr2(:, :, itemp, :)), (/nmodes * nmodes, nqtotf/))
+            uf_real(2::2, :) = RESHAPE(AIMAG(ufr2(:, :, itemp, :)), (/nmodes * nmodes, nqtotf/))
+            CALL plot_band_phon(TRIM(filint), uf_real)
+          ENDIF
+          !
+          IF (specfun_ph) THEN
+            WRITE(filint, "(A, 'crw', I0, '.freq')") TRIM(phlabel), itemp
+            CALL plot_band_phon(TRIM(filint), wfw1(:, :, itemp))
+            !
+            WRITE(filint, "(A, 'rw', I0, '.freq')") TRIM(phlabel), itemp
+            CALL plot_band_phon(TRIM(filint), wfw2(:, :, itemp))
+          ENDIF
+        ENDDO
+      ENDIF
+      IF (lxdfpt) THEN
+        WRITE(filint, "(A, 'x.freq')") TRIM(phlabel)
+        CALL plot_band_phon(TRIM(filint), wfx)
+      ENDIF
+      CALL plot_band_elec()
+    ENDIF
     !
     IF (fermi_plot) CALL plot_fermisurface()
     !
@@ -1736,6 +2179,14 @@
     ! Now deallocate
     DEALLOCATE(epf17, STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epf17', 1)
+    IF (lcdfpt) THEN
+      DEALLOCATE(epf17c, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epf17c', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      DEALLOCATE(epf17x, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epf17x', 1)
+    ENDIF
     DEALLOCATE(selecq, STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating selecq', 1)
     IF (scattering .AND. .NOT. iterative_bte) THEN
@@ -1780,7 +2231,7 @@
       DEALLOCATE(a_all, STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating a_all', 1)
     ENDIF
-    IF (specfun_ph) THEN
+    IF (specfun_ph .AND. .NOT. lcdfpt) THEN
       DEALLOCATE(a_all_ph, STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating a_all_ph', 1)
     ENDIF
@@ -1832,6 +2283,14 @@
   IF (etf_mem == 0) THEN
     DEALLOCATE(epmatwp, STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwp', 1)
+    IF (lcdfpt) THEN
+      DEALLOCATE(epmatwpc, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwpc', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      DEALLOCATE(epmatwpx, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwpx', 1)
+    ENDIF
   ENDIF
   !
   DEALLOCATE(chw, STAT = ierr)
@@ -1849,6 +2308,28 @@
   IF (.NOT. epmatkqread) THEN
     DEALLOCATE(wf, STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating wf', 1)
+    IF (lcdfpt) THEN
+      DEALLOCATE(wfc, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating wfc', 1)
+      DEALLOCATE(wfr, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating wfr', 1)
+      DEALLOCATE(wfcr, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating wfcr', 1)
+      DEALLOCATE(wfr1, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating wfr1', 1)
+      DEALLOCATE(wfr2, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating wfr2', 1)
+      IF (specfun_ph) THEN
+        DEALLOCATE(wfw1, STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating wfw1', 1)
+        DEALLOCATE(wfw2, STAT = ierr)
+        IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating wfw2', 1)
+      ENDIF
+    ENDIF
+    IF (lxdfpt) THEN
+      DEALLOCATE(wfx, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating wfx', 1)
+    ENDIF
   ENDIF
   DEALLOCATE(etf, STAT = ierr)
   IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating etf', 1)
@@ -1900,6 +2381,54 @@
   IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating wslen_g', 1)
   DEALLOCATE(etf_all, STAT = ierr)
   IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating etf_all', 1)
+  IF (lcdfpt) THEN
+    DEALLOCATE(rdwc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating rdwc', 1)
+    DEALLOCATE(rdwr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating rdwr', 1)
+    DEALLOCATE(rdwcr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating rdwcr', 1)
+    DEALLOCATE(epsic, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epsic', 1)
+    DEALLOCATE(zstarc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating zstarc', 1)
+    DEALLOCATE(epmatwefc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwefc', 1)
+    DEALLOCATE(epmatfc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatfc', 1)
+    DEALLOCATE(ufc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufc', 1)
+    DEALLOCATE(ufr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufr', 1)
+    DEALLOCATE(ufcr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufcr', 1)
+    DEALLOCATE(ufr1, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufr1', 1)
+    DEALLOCATE(ufr2, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufr2', 1)
+    DEALLOCATE(w2c, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating w2c', 1)
+    DEALLOCATE(w2r, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating w2r', 1)
+    DEALLOCATE(w2cr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating w2cr', 1)
+  ENDIF
+  IF (lxdfpt) THEN
+    DEALLOCATE(rdwx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating rdwx', 1)
+    DEALLOCATE(epsix, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epsix', 1)
+    DEALLOCATE(zstarx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating zstarx', 1)
+    DEALLOCATE(epmatwefx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatwefx', 1)
+    DEALLOCATE(epmatfx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epmatfx', 1)
+    DEALLOCATE(ufx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufx', 1)
+    DEALLOCATE(w2x, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating w2x', 1)
+  ENDIF
   ! Deallocate temperature when no cumulant or supercond
   IF ((.NOT. cumulant) .AND. (.NOT. eliashberg)) THEN
     DEALLOCATE(gtemp, STAT = ierr)
@@ -1913,6 +2442,14 @@
   ENDIF
   DEALLOCATE(Qmat, STAT = ierr)
   IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating Qmat', 1)
+  IF (lcdfpt) THEN
+    DEALLOCATE(Qmatc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating Qmatc', 1)
+  ENDIF
+  IF (lxdfpt) THEN
+    DEALLOCATE(Qmatx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating Qmatx', 1)
+  ENDIF
   !
   IF (lindabs .AND. (.NOT. scattering)) THEN
     IF (carrier) THEN
diff --git a/EPW/src/ephwann_shuffle_mem.f90 b/EPW/src/ephwann_shuffle_mem.f90
index 9f5250127..8120e5425 100644
--- a/EPW/src/ephwann_shuffle_mem.f90
+++ b/EPW/src/ephwann_shuffle_mem.f90
@@ -23,6 +23,7 @@
   !
   USE kinds,         ONLY : DP, i4b, i8b
   USE pwcom,         ONLY : nbnd, nks, nkstot, ef, nelec
+  USE klist,         ONLY : degauss, ngauss
   USE klist_epw,     ONLY : et_loc, xk_loc, isk_dummy
   USE cell_base,     ONLY : at, bg
   USE ions_base,     ONLY : nat, amass, ityp, tau
@@ -39,7 +40,9 @@
                             epmatkqread, selecqread, restart_step, nsmear,      &
                             nkc1, nkc2, nkc3, nqc1, nqc2, nqc3, assume_metal,   &
                             cumulant, eliashberg, fermi_plot,                   &
-                            nomega, omegamin, omegamax, omegastep, neta
+                            nomega, omegamin, omegamax, omegastep, neta,        &
+                            eig_plot, lcdfpt, lpolarc, lpolarx, lxdfpt,         &
+                            phlabel, prtgkkc, prtgkkx, temp_inf, type_inf, types
   USE control_flags, ONLY : iverbosity
   USE noncollin_module, ONLY : noncolin
   USE constants_epw, ONLY : ryd2ev, ryd2mev, one, two, zero, czero, cone,       &
@@ -47,7 +50,9 @@
   USE io_files,      ONLY : prefix, diropn, tmp_dir
   USE io_global,     ONLY : stdout, ionode
   USE io_var,        ONLY : lambda_phself, linewidth_phself, iunepmatwe,        &
-                            iunepmatwp2, iunrestart, iuntau, iuntaucb
+                            iunepmatwp2, iunrestart, iuntau, iuntaucb,          &
+                            iunepmatwec, iunepmatwex, iunepmatwp, iunepmatwpc,  &
+                            iunepmatwpc2, iunepmatwpx, iunepmatwpx2
   USE elph2,         ONLY : cu, cuq, lwin, lwinq, map_rebal, map_rebal_inv,     &
                             chw, chw_ks, cvmew, cdmew, rdw, adapt_smearing,     &
                             epmatq, wf, etf, etf_ks, xqf, xkf,                  &
@@ -59,9 +64,15 @@
                             inv_tau_allcb, zi_allcb, exband, nbndskip,          &
                             gamma_v_all, esigmar_all, esigmai_all,              &
                             a_all, a_all_ph, wscache, lambda_v_all, threshold,  &
-                            nktotf,  gtemp, xkq, lower_bnd, upper_bnd, dos,&
+                            nktotf,  gtemp, xkq, lower_bnd, upper_bnd, dos,     &
                             nbndep, ef0_fca, epsilon2_abs, epsilon2_abs_lorenz, &
-                            epsilon2_abs_all, epsilon2_abs_lorenz_all
+                            epsilon2_abs_all, epsilon2_abs_lorenz_all, dynqc,   &
+                            dynqcr, dynqr, dynqx, efw, efw0, efw_inf, epf17c,   &
+                            epf17x, epmatqc, epmatqx, epmatwp, epmatwpc,        &
+                            epmatwpx, epsic, epsix, ifc, ifcc, ifccr, ifcr,     &
+                            ifcx, Qmat, Qmatc, Qmatx, qrpl, qrplc, qrplx, rdwc, &
+                            rdwcr, rdwr, rdwx, wfc, wfcr, wfr, wfr1, wfr2,      &
+                            wfw1, wfw2, wfx, zstarc, zstarx
   USE wan2bloch,     ONLY : dmewan2bloch, hamwan2bloch, dynwan2bloch,           &
                             ephwan2blochp, ephwan2bloch, vmewan2bloch,          &
                             dynifc2blochf, ephwan2blochp_mem, ephwan2bloch_mem
@@ -73,7 +84,7 @@
                             check_restart_ephwrite
   USE transport,     ONLY : transport_coeffs, scattering_rate_q
   USE grid,          ONLY : qwindow
-  USE printing,      ONLY : print_gkk, plot_band, plot_fermisurface
+  USE printing,      ONLY : print_gkk, plot_band_elec, plot_band_phon, plot_fermisurface
   USE io_epw,        ONLY : rwepmatw, epw_read, epw_write
   USE io_transport,  ONLY : tau_read, iter_open, print_ibte, iter_merge
   USE io_selfen,     ONLY : selfen_el_read, spectral_read
@@ -88,7 +99,7 @@
   USE utilities,     ONLY : compute_dos, fermicarrier, fermiwindow
   USE grid,          ONLY : loadqmesh_serial, loadkmesh_para, load_rebal
   USE selfen,        ONLY : selfen_phon_q, selfen_elec_q, selfen_pl_q,          &
-                            nesting_fn_q
+                            nesting_fn_q, unscreen_dynq, renorm_phon_q
   USE spectral_func, ONLY : spectral_func_el_q, spectral_func_ph_q, a2f_main,   &
                             spectral_func_pl_q
   USE rigid_epw,     ONLY : rpa_epsilon, tf_epsilon, compute_umn_f, rgd_blk_epw_fine_mem !, &
@@ -257,6 +268,14 @@
   !! Eigen-energies on the fine grid collected from all pools in parallel case
   REAL(KIND = DP), ALLOCATABLE :: w2(:)
   !! Interpolated phonon frequency
+  REAL(KIND = DP), ALLOCATABLE :: w2c(:)
+  !! Interpolated phonon frequency (cDFPT)
+  REAL(KIND = DP), ALLOCATABLE :: w2x(:)
+  !! Interpolated phonon frequency (extra DFPT)
+  REAL(KIND = DP), ALLOCATABLE :: w2r(:)
+  !! Interpolated phonon frequency (renormalized)
+  REAL(KIND = DP), ALLOCATABLE :: w2cr(:)
+  !! Interpolated phonon frequency (cDFPT, renormalized)
   REAL(KIND = DP), ALLOCATABLE :: irvec_r(:, :)
   !! Wigner-Size supercell vectors, store in real instead of integer
   REAL(KIND = DP), ALLOCATABLE :: rdotk(:)
@@ -273,18 +292,44 @@
   !! velocity from all the k-point
   REAL(KIND = DP), ALLOCATABLE :: wkf_all(:)
   !! k-point weights for all the k-points
+  REAL(KIND = DP), ALLOCATABLE :: uf_real(:, :)
+  !! Rotation matrix for phonons (two real instead of one complex number each)
   COMPLEX(KIND = DP), ALLOCATABLE :: epmatwe_mem(:, :, :, :)
   !! e-p matrix  in wannier basis - electrons (written on disk)
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatwec_mem(:, :, :, :)
+  !! e-p matrix  in wannier basis - electrons (written on disk) (cDFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatwex_mem(:, :, :, :)
+  !! e-p matrix  in wannier basis - electrons (written on disk) (extra DFPT)
   COMPLEX(KIND = DP), ALLOCATABLE :: epmatwef(:, :, :)
   !! e-p matrix  in el wannier - fine Bloch phonon grid
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatwefc(:, :, :)
+  !! e-p matrix  in el wannier - fine Bloch phonon grid (cDFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatwefx(:, :, :)
+  !! e-p matrix  in el wannier - fine Bloch phonon grid (extra DFPT)
   COMPLEX(KIND = DP), ALLOCATABLE :: epmatf(:, :)
   !! e-p matrix  in smooth Bloch basis, fine mesh
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatfc(:, :)
+  !! e-p matrix  in smooth Bloch basis, fine mesh (cDFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatfx(:, :)
+  !! e-p matrix  in smooth Bloch basis, fine mesh (extra DFPT)
   COMPLEX(KIND = DP), ALLOCATABLE :: cufkk(:, :)
   !! Rotation matrix, fine mesh, points k
   COMPLEX(KIND = DP), ALLOCATABLE :: cufkq(:, :)
   !! the same, for points k+q
   COMPLEX(KIND = DP), ALLOCATABLE :: uf(:, :)
   !! Rotation matrix for phonons
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufc(:, :)
+  !! Rotation matrix for phonons (cDFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufx(:, :)
+  !! Rotation matrix for phonons (extra DFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufr(:, :)
+  !! Rotation matrix for phonons (renormalized)
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufcr(:, :)
+  !! Rotation matrix for phonons (cDFPT, renormalized)
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufr1(:, :, :, :)
+  !! Rotation matrix for phonons (cDFPT+Pi)
+  COMPLEX(KIND = DP), ALLOCATABLE :: ufr2(:, :, :, :)
+  !! Rotation matrix for phonons (DFPT-Pi+Pi)
   COMPLEX(KIND = DP), ALLOCATABLE :: bmatf(:, :)
   !! overlap U_k+q U_k^\dagger in smooth Bloch basis, fine mesh
   COMPLEX(KIND = DP), ALLOCATABLE :: cfac(:, :, :)
@@ -293,8 +338,16 @@
   !! Used to store $e^{2\pi r \cdot k+q}$ exponential
   COMPLEX(KIND = DP), ALLOCATABLE :: eptmp(:, :, :, :)
   !! Temporary el-ph matrices.
+  COMPLEX(KIND = DP), ALLOCATABLE :: eptmpc(:, :, :, :)
+  !! Temporary el-ph matrices (cDFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: eptmpx(:, :, :, :)
+  !! Temporary el-ph matrices (extra DFPT)
   COMPLEX(KIND = DP), ALLOCATABLE :: epmatlrT(:, :, :, :)
   !! Long-range temp. save
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatlrTc(:, :, :, :)
+  !! Long-range temp. save (cDFPT)
+  COMPLEX(KIND = DP), ALLOCATABLE :: epmatlrTx(:, :, :, :)
+  !! Long-range temp. save (extra DFPT)
   COMPLEX(KIND = DP), ALLOCATABLE :: vmefp(:, :, :)
   !! Phonon velocity
   !
@@ -323,8 +376,24 @@
   ALLOCATE(w2(3 * nat), STAT = ierr)
   IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating w2', 1)
   w2(:) = zero
+  IF (lcdfpt) THEN
+    ALLOCATE(w2c(3 * nat), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating w2c', 1)
+    w2c(:) = zero
+    ALLOCATE(w2r(3 * nat), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating w2r', 1)
+    w2r(:) = zero
+    ALLOCATE(w2cr(3 * nat), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating w2cr', 1)
+    w2cr(:) = zero
+  ENDIF
+  IF (lxdfpt) THEN
+    ALLOCATE(w2x(3 * nat), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating w2x', 1)
+    w2x(:) = zero
+  ENDIF
   !
-  IF (lpolar) THEN
+  IF (lpolar .OR. lpolarc .OR. lpolarx) THEN
     WRITE(stdout, '(/,5x,a)') 'Computes the analytic long-range interaction for polar materials [lpolar]'
     WRITE(stdout, '(5x,a)')   ' '
   ENDIF
@@ -400,6 +469,18 @@
     IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating chw_ks', 1)
     ALLOCATE(rdw(nmodes, nmodes, nrr_q), STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating rdw', 1)
+    IF (lcdfpt) THEN
+      ALLOCATE(rdwc(nmodes, nmodes, nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating rdwc', 1)
+      ALLOCATE(rdwr(nmodes, nmodes, nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating rdwr', 1)
+      ALLOCATE(rdwcr(nmodes, nmodes, nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating rdwcr', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      ALLOCATE(rdwx(nmodes, nmodes, nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating rdwx', 1)
+    ENDIF
     IF (vme == 'wannier') THEN
       ALLOCATE(cvmew(3, nbndsub, nbndsub, nrr_k), STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating cvmew', 1)
@@ -414,6 +495,20 @@
     ALLOCATE(epmatwe_mem(nbndsub, nbndsub, nrr_k, nmodes), STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epmatwe_mem', 1)
     epmatwe_mem(:, :, :, :) = czero
+    IF (lcdfpt) THEN
+      ALLOCATE(epmatwec_mem(nbndsub, nbndsub, nrr_k, nmodes), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epmatwec_mem', 1)
+      epmatwec_mem(:, :, :, :) = czero
+    ENDIF
+    IF (lxdfpt) THEN
+      ALLOCATE(epmatwex_mem(nbndsub, nbndsub, nrr_k, nmodes), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epmatwex_mem', 1)
+      epmatwex_mem(:, :, :, :) = czero
+    ENDIF
+    !
+    IF (lcdfpt) THEN
+      CALL unscreen_dynq(xqc)
+    ENDIF
     !
     ! Hamiltonian
     !
@@ -437,7 +532,16 @@
     !
     ! Dynamical Matrix
     !
-    IF (.NOT. lifc) CALL dynbloch2wan(nmodes, nqc, xqc, dynq, nrr_q, irvec_q, wslen_q)
+    IF (.NOT. lifc) THEN
+      CALL dynbloch2wan(nmodes, nqc, xqc, dynq, rdw, nrr_q, irvec_q, wslen_q, lpolar, qrpl, epsi, zstar, Qmat, '')
+      IF (lcdfpt) THEN
+        CALL dynbloch2wan(nmodes, nqc, xqc, dynqc, rdwc, nrr_q, irvec_q, wslen_q, lpolarc, qrplc, epsic, zstarc, Qmatc, 'c')
+        CALL dynbloch2wan(nmodes, nqc, xqc, dynqr, rdwr, nrr_q, irvec_q, wslen_q, lpolar, qrpl, epsi, zstar, Qmat, 'r')
+        CALL dynbloch2wan(nmodes, nqc, xqc, dynqcr, rdwcr, nrr_q, irvec_q, wslen_q, lpolar, qrpl, epsi, zstar, Qmat, 'cr')
+      ENDIF
+      IF (lxdfpt) CALL dynbloch2wan(nmodes, nqc, xqc, dynqx, rdwx, nrr_q, irvec_q, wslen_q, &
+        lpolarx, qrplx, epsix, zstarx, Qmatx, 'x')
+    ENDIF
     !
     !
     ! Electron-Phonon vertex (Bloch el and Bloch ph -> Wannier el and Bloch ph)
@@ -445,8 +549,9 @@
     ! Open the prefix.epmatwe file
     IF (ionode) THEN
       lrepmatw = 2 * nbndsub * nbndsub * nrr_k * nmodes
-      filint   = TRIM(prefix)//'.epmatwe'
       CALL diropn(iunepmatwe, 'epmatwe', lrepmatw, exst)
+      IF (lcdfpt) CALL diropn(iunepmatwec, 'epmatwec', lrepmatw, exst)
+      IF (lxdfpt) CALL diropn(iunepmatwex, 'epmatwex', lrepmatw, exst)
     ENDIF
     !
     DO iq = 1, nqc
@@ -465,21 +570,33 @@
         !
         CALL ephbloch2wane(nbndep, nbndsub, nks, nkstot, xk_loc, cu, cuq, &
           epmatq(:, :, :, imode, iq), nrr_k, irvec_k, wslen_k, epmatwe_mem(:, :, :, imode))
+        IF (lcdfpt) CALL ephbloch2wane(nbndep, nbndsub, nks, nkstot, xk_loc, cu, cuq, &
+          epmatqc(:, :, :, imode, iq), nrr_k, irvec_k, wslen_k, epmatwec_mem(:, :, :, imode))
+        IF (lxdfpt) CALL ephbloch2wane(nbndep, nbndsub, nks, nkstot, xk_loc, cu, cuq, &
+          epmatqx(:, :, :, imode, iq), nrr_k, irvec_k, wslen_k, epmatwex_mem(:, :, :, imode))
         !
       ENDDO
       ! Only the master node writes
       IF (ionode) THEN
         ! direct write of epmatwe for this iq
         CALL rwepmatw(epmatwe_mem, nbndsub, nrr_k, nmodes, iq, iunepmatwe, +1)
+        IF (lcdfpt) CALL rwepmatw(epmatwec_mem, nbndsub, nrr_k, nmodes, iq, iunepmatwec, +1)
+        IF (lxdfpt) CALL rwepmatw(epmatwex_mem, nbndsub, nrr_k, nmodes, iq, iunepmatwex, +1)
         !
       ENDIF
       !
     ENDDO
     !
-    IF (ionode) CLOSE(iunepmatwe, STATUS = 'keep')
+    IF (ionode) THEN
+      CLOSE(iunepmatwe, STATUS = 'keep')
+      IF (lcdfpt) CLOSE(iunepmatwec, STATUS = 'keep')
+      IF (lxdfpt) CLOSE(iunepmatwex, STATUS = 'keep')
+    ENDIF
     !
     ! Electron-Phonon vertex (Wannier el and Bloch ph -> Wannier el and Wannier ph)
-    CALL ephbloch2wanp_mem(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g)
+    CALL ephbloch2wanp_mem(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g, iunepmatwe, iunepmatwp, '')
+    IF (lcdfpt) CALL ephbloch2wanp_mem(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g, iunepmatwec, iunepmatwpc, 'c')
+    IF (lxdfpt) CALL ephbloch2wanp_mem(nbndsub, nmodes, xqc, nqc, irvec_k, irvec_g, nrr_k, nrr_g, iunepmatwex, iunepmatwpx, 'x')
     !
     IF (epwwrite) THEN
       CALL epw_write(nrr_k, nrr_q, nrr_g, w_centers)
@@ -502,6 +619,26 @@
     IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating lwinq', 1)
     DEALLOCATE(exband, STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating exband', 1)
+    IF (lcdfpt) THEN
+      DEALLOCATE(epmatqc, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epmatqc', 1)
+      DEALLOCATE(dynqc, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating dynqc', 1)
+      DEALLOCATE(dynqr, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating dynqr', 1)
+      DEALLOCATE(dynqcr, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating dynqcr', 1)
+      DEALLOCATE(epmatwec_mem, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epmatwec_mem', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      DEALLOCATE(epmatqx, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epmatqx', 1)
+      DEALLOCATE(dynqx, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating dynqx', 1)
+      DEALLOCATE(epmatwex_mem, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epmatwex_mem', 1)
+    ENDIF
   ENDIF ! (epwread .AND. .NOT. epbread)
   !
   ! Check Memory usage
@@ -545,6 +682,52 @@
   IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating eps_rpa', 1)
   ALLOCATE(isk_dummy(nkqf), STAT = ierr)
   IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating isk_dummy', 1)
+  IF (lcdfpt) THEN
+    ALLOCATE(epmatwefc(nbndsub, nbndsub, nrr_k), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epmatwefc', 1)
+    ALLOCATE(wfc(nmodes, nqf), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating wfc', 1)
+    ALLOCATE(wfr(nmodes, nqf), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating wfr', 1)
+    ALLOCATE(wfcr(nmodes, nqf), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating wfcr', 1)
+    ALLOCATE(wfr1(nmodes, nqf, nstemp), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating wfr1', 1)
+    ALLOCATE(wfr2(nmodes, nqf, nstemp), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating wfr2', 1)
+    IF (specfun_ph) THEN
+       ALLOCATE(wfw1(nw_specfun, nqf, nstemp), STAT = ierr)
+       IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating wfw1', 1)
+       ALLOCATE(wfw2(nw_specfun, nqf, nstemp), STAT = ierr)
+       IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating wfw2', 1)
+    ENDIF
+    ALLOCATE(epmatfc(nbndsub, nbndsub), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epmatfc', 1)
+    ALLOCATE(ufc(nmodes, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating ufc', 1)
+    ALLOCATE(ufr(nmodes, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating ufr', 1)
+    ALLOCATE(ufcr(nmodes, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating ufcr', 1)
+    ALLOCATE(ufr1(nmodes, nmodes, nstemp, nqf), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating ufr1', 1)
+    ALLOCATE(ufr2(nmodes, nmodes, nstemp, nqf), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating ufr2', 1)
+    IF (eig_plot) THEN
+      ALLOCATE(uf_real(2 * nmodes * nmodes * nstemp, nqf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error allocating uf_real', 1)
+    ENDIF
+  ENDIF
+  IF (lxdfpt) THEN
+    ALLOCATE(epmatwefx(nbndsub, nbndsub, nrr_k), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epmatwefx', 1)
+    ALLOCATE(wfx(nmodes, nqf), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating wfx', 1)
+    ALLOCATE(epmatfx(nbndsub, nbndsub), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epmatfx', 1)
+    ALLOCATE(ufx(nmodes, nmodes), STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating ufx', 1)
+  ENDIF
   epmatwef(:, :, :) = czero
   wf(:, :)          = zero
   etf(:, :)         = zero
@@ -556,6 +739,30 @@
   bmatf(:, :)       = czero
   eps_rpa(:)        = czero
   isk_dummy(:)      = 0
+  IF (lcdfpt) THEN
+    epmatwefc(:, :, :) = czero
+    wfc(:, :)          = zero
+    wfr(:, :)          = zero
+    wfcr(:, :)         = zero
+    wfr1(:, :, :)      = zero
+    wfr2(:, :, :)      = zero
+    IF (specfun_ph) THEN
+      wfw1(:, :, :)    = zero
+      wfw2(:, :, :)    = zero
+    ENDIF
+    epmatfc(:, :)      = czero
+    ufc(:, :)          = czero
+    ufr(:, :)          = czero
+    ufcr(:, :)         = czero
+    ufr1(:, :, :, :)   = czero
+    ufr2(:, :, :, :)   = czero
+  ENDIF
+  IF (lxdfpt) THEN
+    epmatwefx(:, :, :) = czero
+    wfx(:, :)          = zero
+    epmatfx(:, :)      = czero
+    ufx(:, :)          = czero
+  ENDIF
   !
   ! Allocate velocity and dipole matrix elements after getting grid size
   !
@@ -652,7 +859,7 @@
       ENDIF
     ENDIF
     !
-  ELSEIF (band_plot) THEN
+  ELSEIF (band_plot .AND. .NOT. lcdfpt) THEN
     !
     WRITE(stdout, '(/5x,a)') REPEAT('=',67)
     WRITE(stdout, '(/5x,"Fermi energy corresponds to the coarse k-mesh")')
@@ -697,6 +904,32 @@
     !
     ef = efnew
   ENDIF
+  !
+  IF (lcdfpt) THEN
+    IF (degauss > zero) THEN
+      efw0 = efermig(etf, nbndsub, nkqf, nelec, wkf, degauss, ngauss, 0, isk_dummy)
+    ELSE
+      efw0 = ef
+    ENDIF
+    !
+    ALLOCATE(efw(nstemp))
+    !
+    IF (efermi_read) THEN
+      efw = fermi_energy
+      efw_inf = fermi_energy
+    ELSE
+      DO itemp = 1, nstemp
+        efw(itemp) = efermig(etf, nbndsub, nkqf, nelec, wkf, gtemp(itemp), types(itemp), 0, isk_dummy)
+      ENDDO
+      !
+      IF (temp_inf > zero) THEN
+        efw_inf = efermig(etf, nbndsub, nkqf, nelec, wkf, temp_inf, type_inf, 0, isk_dummy)
+      ELSE
+        efw_inf = ef
+      ENDIF
+    ENDIF
+  ENDIF
+  !
   ! ------------------------------------------------------------
   ! Apply a possible shift to eigenenergies (applied later)
   icbm = 1
@@ -753,6 +986,16 @@
   filint = TRIM(tmp_dir) // TRIM(prefix)//'.epmatwp'
   CALL MPI_FILE_OPEN(world_comm, filint, MPI_MODE_RDONLY, MPI_INFO_NULL, iunepmatwp2, ierr)
   IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'error in MPI_FILE_OPEN', 1)
+  IF (lcdfpt) THEN
+    filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwpc'
+    CALL MPI_FILE_OPEN(world_comm, filint, MPI_MODE_RDONLY, MPI_INFO_NULL, iunepmatwpc2, ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'error in MPI_FILE_OPEN', 1)
+  ENDIF
+  IF (lxdfpt) THEN
+    filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwpx'
+    CALL MPI_FILE_OPEN(world_comm, filint, MPI_MODE_RDONLY, MPI_INFO_NULL, iunepmatwpx2, ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'error in MPI_FILE_OPEN', 1)
+  ENDIF
 #endif
   !
   ! get the size of the matrix elements stored in each pool
@@ -891,6 +1134,22 @@
     IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating eptmp', 1)
     ALLOCATE(epmatlrT(nbndsub, nbndsub, nmodes, nkf), STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epmatlrT', 1)
+    IF (lcdfpt) THEN
+      ALLOCATE(epf17c(nbndfst, nbndfst, nmodes, nkf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epf17c', 1)
+      ALLOCATE(eptmpc(nbndfst, nbndfst, nmodes, nkf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating eptmpc', 1)
+      ALLOCATE(epmatlrTc(nbndsub, nbndsub, nmodes, nkf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epmatlrTc', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      ALLOCATE(epf17x(nbndfst, nbndfst, nmodes, nkf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epf17x', 1)
+      ALLOCATE(eptmpx(nbndfst, nbndfst, nmodes, nkf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating eptmpx', 1)
+      ALLOCATE(epmatlrTx(nbndsub, nbndsub, nmodes, nkf), STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating epmatlrTx', 1)
+    ENDIF
     IF (phonselfen) THEN
       ALLOCATE(lambda_all(nmodes, totq, nsmear, nstemp), STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating lambda_all', 1)
@@ -916,7 +1175,7 @@
       esigmai_all(:, :, :, :) = zero
       a_all(:, :, :) = zero
     ENDIF
-    IF (specfun_ph) THEN
+    IF (specfun_ph .AND. .NOT. lcdfpt) THEN
       ALLOCATE(a_all_ph(nw_specfun, totq, nstemp), STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error allocating a_all_ph', 1)
       a_all_ph(:, :, :) = zero
@@ -1089,6 +1348,16 @@
       epf17(:, :, :, :) = czero
       eptmp(:, :, :, :)    = czero
       epmatlrT(:, :, :, :) = czero
+      IF (lcdfpt) THEN
+        epf17c(:, :, :, :) = czero
+        eptmpc(:, :, :, :) = czero
+        epmatlrTc(:, :, :, :) = czero
+      ENDIF
+      IF (lxdfpt) THEN
+        epf17x(:, :, :, :) = czero
+        eptmpx(:, :, :, :) = czero
+        epmatlrTx(:, :, :, :) = czero
+      ENDIF
       cufkk(:, :) = czero
       cufkq(:, :) = czero
       !
@@ -1113,9 +1382,21 @@
       ! ------------------------------------------------------
       !
       IF (.NOT. lifc) THEN
-        CALL dynwan2bloch(nmodes, nrr_q, irvec_q, ndegen_q, xxq, uf, w2)
+        CALL dynwan2bloch(rdw, nmodes, nrr_q, irvec_q, ndegen_q, xxq, uf, w2, lpolar, qrpl, epsi, zstar, Qmat)
+        IF (lcdfpt) THEN
+          CALL dynwan2bloch(rdwc, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufc, w2c, lpolarc, qrplc, epsic, zstarc, Qmatc)
+          CALL dynwan2bloch(rdwr, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufr, w2r, lpolar, qrpl, epsi, zstar, Qmat)
+          CALL dynwan2bloch(rdwcr, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufcr, w2cr, lpolar, qrpl, epsi, zstar, Qmat)
+        ENDIF
+        IF (lxdfpt) CALL dynwan2bloch(rdwx, nmodes, nrr_q, irvec_q, ndegen_q, xxq, ufx, w2x, lpolarx, qrplx, epsix, zstarx, Qmatx)
       ELSE
-        CALL dynifc2blochf(nmodes, rws, nrws, xxq, uf, w2)
+        CALL dynifc2blochf(ifc, nmodes, rws, nrws, xxq, uf, w2, lpolar, qrpl, epsi, zstar, Qmat)
+        IF (lcdfpt) THEN
+          CALL dynifc2blochf(ifcc, nmodes, rws, nrws, xxq, ufc, w2c, lpolarc, qrplc, epsic, zstarc, Qmatc)
+          CALL dynifc2blochf(ifcr, nmodes, rws, nrws, xxq, ufr, w2r, lpolar, qrpl, epsi, zstar, Qmat)
+          CALL dynifc2blochf(ifccr, nmodes, rws, nrws, xxq, ufcr, w2cr, lpolar, qrpl, epsi, zstar, Qmat)
+        ENDIF
+        IF (lxdfpt) CALL dynifc2blochf(ifcx, nmodes, rws, nrws, xxq, ufx, w2x, lpolarx, qrplx, epsix, zstarx, Qmatx)
       ENDIF
       !
       ! ...then take into account the mass factors and square-root the frequencies...
@@ -1130,10 +1411,22 @@
         ELSE
           wf(nu, iq) = -DSQRT(ABS(w2(nu)))
         ENDIF
+        IF (lcdfpt) THEN
+          wfc(nu, iq) = SIGN(DSQRT(ABS(w2c(nu))), w2c(nu))
+          wfr(nu, iq) = SIGN(DSQRT(ABS(w2r(nu))), w2r(nu))
+          wfcr(nu, iq) = SIGN(DSQRT(ABS(w2cr(nu))), w2cr(nu))
+        ENDIF
+        IF (lxdfpt) wfx(nu, iq) = SIGN(DSQRT(ABS(w2x(nu))), w2x(nu))
         !
         DO mu = 1, nmodes
           na = (mu - 1) / 3 + 1
           uf(mu, nu) = uf(mu, nu) / DSQRT(amass(ityp(na)))
+          IF (lcdfpt) THEN
+            ufc(mu, nu) = ufc(mu, nu) / DSQRT(amass(ityp(na)))
+            ufr(mu, nu) = ufr(mu, nu) / DSQRT(amass(ityp(na)))
+            ufcr(mu, nu) = ufcr(mu, nu) / DSQRT(amass(ityp(na)))
+          ENDIF
+          IF (lxdfpt) ufx(mu, nu) = ufx(mu, nu) / DSQRT(amass(ityp(na)))
         ENDDO
       ENDDO
       !
@@ -1143,9 +1436,16 @@
       !
       DO imode = 1, nmodes
         epmatwef(:, :, :) = czero
+        IF (lcdfpt) epmatwefc(:, :, :) = czero
+        IF (lxdfpt) epmatwefx(:, :, :) = czero
         !
         IF (.NOT. longrange) THEN
-          CALL ephwan2blochp_mem(imode, nmodes, xxq, irvec_g, ndegen_g, nrr_g, epmatwef, nbndsub, nrr_k, dims, dims2)
+          CALL ephwan2blochp_mem(imode, nmodes, xxq, irvec_g, ndegen_g, nrr_g, &
+            epmatwef, nbndsub, nrr_k, dims, dims2, '')
+          IF (lcdfpt) CALL ephwan2blochp_mem(imode, nmodes, xxq, irvec_g, ndegen_g, nrr_g, &
+            epmatwefc, nbndsub, nrr_k, dims, dims2, 'c')
+          IF (lxdfpt) CALL ephwan2blochp_mem(imode, nmodes, xxq, irvec_g, ndegen_g, nrr_g, &
+            epmatwefx, nbndsub, nrr_k, dims, dims2, 'x')
         ENDIF
         !
         !
@@ -1276,26 +1576,36 @@
               IF (longrange) THEN
                 !
                 epmatf(:, :) = czero
+                IF (lcdfpt) epmatfc(:, :) = czero
+                IF (lxdfpt) epmatfx(:, :) = czero
                 !
               ELSE
                 !
                 epmatf(:, :) = czero
                 CALL ephwan2bloch_mem(nbndsub, nrr_k, epmatwef, cufkk, cufkq, epmatf, cfac, dims)
+                IF (lcdfpt) THEN
+                  epmatfc(:, :) = czero
+                  CALL ephwan2bloch_mem(nbndsub, nrr_k, epmatwefc, cufkk, cufkq, epmatfc, cfac, dims)
+                ENDIF
+                IF (lxdfpt) THEN
+                  epmatfx(:, :) = czero
+                  CALL ephwan2bloch_mem(nbndsub, nrr_k, epmatwefx, cufkk, cufkq, epmatfx, cfac, dims)
+                ENDIF
                 !
               ENDIF
               !
-              IF (lpolar) THEN
+              IF (lpolar .OR. lpolarc .OR. lpolarx) THEN
                 !
                 CALL compute_umn_f(nbndsub, cufkk, cufkq, bmatf)
                 !
-                IF ((ABS(xxq(1)) > eps8) .OR. (ABS(xxq(2)) > eps8) .OR. (ABS(xxq(3)) > eps8)) THEN
-                  !
-                  CALL cryst_to_cart(1, xxq, bg, 1)
-                  CALL rgd_blk_epw_fine_mem(imode, nqc1, nqc2, nqc3, xxq, uf, epmatlrT(:, :, imode, ik), &
-                                        nmodes, epsi, zstar, bmatf, one)
-                  CALL cryst_to_cart(1, xxq, at, -1)
-                  !
-                ENDIF
+                CALL cryst_to_cart(1, xxq, bg, 1)
+                IF (lpolar) CALL rgd_blk_epw_fine_mem(imode, nqc1, nqc2, nqc3, xxq, uf, epmatlrT(:, :, imode, ik), &
+                  nmodes, lpolar, epsi, zstar, Qmat, bmatf, one)
+                IF (lpolarc) CALL rgd_blk_epw_fine_mem(imode, nqc1, nqc2, nqc3, xxq, ufc, epmatlrTc(:, :, imode, ik), &
+                  nmodes, lpolarc, epsic, zstarc, Qmatc, bmatf, one)
+                IF (lpolarx) CALL rgd_blk_epw_fine_mem(imode, nqc1, nqc2, nqc3, xxq, ufx, epmatlrTx(:, :, imode, ik), &
+                  nmodes, lpolarx, epsix, zstarx, Qmatx, bmatf, one)
+                CALL cryst_to_cart(1, xxq, at, -1)
                 !
               ENDIF
               !
@@ -1309,6 +1619,8 @@
                   ELSE
                     eptmp(ibnd - ibndmin + 1, jbnd - ibndmin + 1, imode, ik) = epmatf(ibnd, jbnd)
                   ENDIF
+                  IF (lcdfpt) eptmpc(ibnd - ibndmin + 1, jbnd - ibndmin + 1, imode, ik) = epmatfc(ibnd, jbnd)
+                  IF (lxdfpt) eptmpx(ibnd - ibndmin + 1, jbnd - ibndmin + 1, imode, ik) = epmatfx(ibnd, jbnd)
                   !
                 ENDDO
               ENDDO
@@ -1324,6 +1636,10 @@
       DO ik = 1, nkf
         CALL ZGEMM('n', 'n', nbndfst * nbndfst, nmodes, nmodes, cone, eptmp(:, :, :, ik), &
                    nbndfst * nbndfst, uf, nmodes, czero, epf17(:, :, :, ik), nbndfst * nbndfst)
+        IF (lcdfpt) CALL ZGEMM('n', 'n', nbndfst * nbndfst, nmodes, nmodes, cone, eptmpc(:, :, :, ik), &
+                   nbndfst * nbndfst, ufc, nmodes, czero, epf17c(:, :, :, ik), nbndfst * nbndfst)
+        IF (lxdfpt) CALL ZGEMM('n', 'n', nbndfst * nbndfst, nmodes, nmodes, cone, eptmpx(:, :, :, ik), &
+                   nbndfst * nbndfst, ufx, nmodes, czero, epf17x(:, :, :, ik), nbndfst * nbndfst)
         !
       ENDDO
       !
@@ -1332,18 +1648,26 @@
         DO ibnd = ibndmin, ibndmax
           epf17(ibnd - ibndmin+1, jbnd - ibndmin + 1, :, :) = epf17(ibnd-ibndmin+1, jbnd - ibndmin + 1, :, :) &
                                                             + epmatlrT(ibnd, jbnd, :, :)
+          IF (lcdfpt) epf17c(ibnd - ibndmin+1, jbnd - ibndmin + 1, :, :) = epf17c(ibnd-ibndmin+1, jbnd - ibndmin + 1, :, :) &
+                                                            + epmatlrTc(ibnd, jbnd, :, :)
+          IF (lxdfpt) epf17x(ibnd - ibndmin+1, jbnd - ibndmin + 1, :, :) = epf17x(ibnd-ibndmin+1, jbnd - ibndmin + 1, :, :) &
+                                                            + epmatlrTx(ibnd, jbnd, :, :)
         ENDDO
       ENDDO
       !
       !
       !
-      IF (prtgkk    ) CALL print_gkk(iq)
+      IF (prtgkk    ) CALL print_gkk(iq, epf17, wf, totq)
+      IF (prtgkkc   ) CALL print_gkk(iq, epf17c, wfc, totq)
+      IF (prtgkkx   ) CALL print_gkk(iq, epf17x, wfx, totq)
       IF (phonselfen) CALL selfen_phon_q(iqq, iq, totq)
+      IF (lcdfpt    ) CALL renorm_phon_q(iq, w2, uf, w2c, ufc, w2x, ufx, w2r, ufr, w2cr, ufcr, &
+                                         ufr1(:, :, :, iq), ufr2(:, :, :, iq))
       IF (elecselfen) CALL selfen_elec_q(iqq, iq, totq, first_cycle)
       IF (plselfen .AND. vme == 'dipole') CALL selfen_pl_q(iqq, iq, totq, first_cycle)
       IF (nest_fn   ) CALL nesting_fn_q(iqq, iq)
       IF (specfun_el) CALL spectral_func_el_q(iqq, iq, totq, first_cycle)
-      IF (specfun_ph) CALL spectral_func_ph_q(iqq, iq, totq)
+      IF (specfun_ph .AND. .NOT. lcdfpt) CALL spectral_func_ph_q(iqq, iq, totq)
       IF (specfun_pl .AND. vme == 'dipole') CALL spectral_func_pl_q(iqq, iq, totq, first_cycle)
       IF (ephwrite) THEN
         IF (first_cycle .OR. iq == 1) THEN
@@ -1482,7 +1806,54 @@
         ENDDO ! itempphen
       ENDIF
     ENDIF
-    IF (band_plot) CALL plot_band()
+    IF (band_plot) THEN
+      WRITE(filint, "(A, '.freq')") TRIM(phlabel)
+      CALL plot_band_phon(TRIM(filint), wf)
+      !
+      IF (lcdfpt) THEN
+        WRITE(filint, "(A, 'c.freq')") TRIM(phlabel)
+        CALL plot_band_phon(TRIM(filint), wfc)
+        !
+        WRITE(filint, "(A, 'cr.freq')") TRIM(phlabel)
+        CALL plot_band_phon(TRIM(filint), wfcr)
+        !
+        WRITE(filint, "(A, 'r.freq')") TRIM(phlabel)
+        CALL plot_band_phon(TRIM(filint), wfr)
+        !
+        DO itemp = 1, nstemp
+          WRITE(filint, "(A, 'cr', I0, '.freq')") TRIM(phlabel), itemp
+          CALL plot_band_phon(TRIM(filint), wfr1(:, :, itemp))
+          !
+          WRITE(filint, "(A, 'r', I0, '.freq')") TRIM(phlabel), itemp
+          CALL plot_band_phon(TRIM(filint), wfr2(:, :, itemp))
+          !
+          IF (eig_plot) THEN
+            WRITE(filint, "(A, 'cre', I0, '.freq')") TRIM(phlabel), itemp
+            uf_real(1::2, :) = RESHAPE(REAL(ufr1(:, :, itemp, :)), (/nmodes * nmodes, nqtotf/))
+            uf_real(2::2, :) = RESHAPE(AIMAG(ufr1(:, :, itemp, :)), (/nmodes * nmodes, nqtotf/))
+            CALL plot_band_phon(TRIM(filint), uf_real)
+            !
+            WRITE(filint, "(A, 're', I0, '.freq')") TRIM(phlabel), itemp
+            uf_real(1::2, :) = RESHAPE(REAL(ufr2(:, :, itemp, :)), (/nmodes * nmodes, nqtotf/))
+            uf_real(2::2, :) = RESHAPE(AIMAG(ufr2(:, :, itemp, :)), (/nmodes * nmodes, nqtotf/))
+            CALL plot_band_phon(TRIM(filint), uf_real)
+          ENDIF
+          !
+          IF (specfun_ph) THEN
+            WRITE(filint, "(A, 'crw', I0, '.freq')") TRIM(phlabel), itemp
+            CALL plot_band_phon(TRIM(filint), wfw1(:, :, itemp))
+            !
+            WRITE(filint, "(A, 'rw', I0, '.freq')") TRIM(phlabel), itemp
+            CALL plot_band_phon(TRIM(filint), wfw2(:, :, itemp))
+          ENDIF
+        ENDDO
+      ENDIF
+      IF (lxdfpt) THEN
+        WRITE(filint, "(A, 'x.freq')") TRIM(phlabel)
+        CALL plot_band_phon(TRIM(filint), wfx)
+      ENDIF
+      CALL plot_band_elec()
+    ENDIF
     !
     IF (fermi_plot) CALL plot_fermisurface()
     !
@@ -1525,6 +1896,14 @@
     ! Now deallocate
     DEALLOCATE(epf17, STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epf17', 1)
+    IF (lcdfpt) THEN
+      DEALLOCATE(epf17c, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epf17c', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      DEALLOCATE(epf17x, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating epf17x', 1)
+    ENDIF
     DEALLOCATE(selecq, STAT = ierr)
     IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating selecq', 1)
     IF (scattering .AND. .NOT. iterative_bte) THEN
@@ -1569,7 +1948,7 @@
       DEALLOCATE(a_all, STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating a_all', 1)
     ENDIF
-    IF (specfun_ph) THEN
+    IF (specfun_ph .AND. .NOT. lcdfpt) THEN
       DEALLOCATE(a_all_ph, STAT = ierr)
       IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating a_all_ph', 1)
     ENDIF
@@ -1683,6 +2062,68 @@
   IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating wslen_g', 1)
   DEALLOCATE(etf_all, STAT = ierr)
   IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating etf_all', 1)
+  IF (lcdfpt) THEN
+    DEALLOCATE(rdwc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating rdwc', 1)
+    DEALLOCATE(rdwr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating rdwr', 1)
+    DEALLOCATE(rdwcr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating rdwcr', 1)
+    DEALLOCATE(epsic, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epsic', 1)
+    DEALLOCATE(zstarc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating zstarc', 1)
+    DEALLOCATE(epmatwefc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epmatwefc', 1)
+    DEALLOCATE(wfc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating wfc', 1)
+    DEALLOCATE(wfr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating wfr', 1)
+    DEALLOCATE(wfcr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating wfcr', 1)
+    DEALLOCATE(wfr1, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating wfr1', 1)
+    DEALLOCATE(wfr2, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating wfr2', 1)
+    IF (specfun_ph) THEN
+      DEALLOCATE(wfw1, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating wfw1', 1)
+      DEALLOCATE(wfw2, STAT = ierr)
+      IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating wfw2', 1)
+    ENDIF
+    DEALLOCATE(epmatfc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epmatfc', 1)
+    DEALLOCATE(ufc, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufc', 1)
+    DEALLOCATE(ufr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufr', 1)
+    DEALLOCATE(ufcr, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufcr', 1)
+    DEALLOCATE(ufr1, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufr1', 1)
+    DEALLOCATE(ufr2, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufr2', 1)
+    DEALLOCATE(w2c, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating w2c', 1)
+  ENDIF
+  IF (lxdfpt) THEN
+    DEALLOCATE(rdwx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating rdwx', 1)
+    DEALLOCATE(epsix, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epsix', 1)
+    DEALLOCATE(zstarx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating zstarx', 1)
+    DEALLOCATE(epmatwefx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epmatwefx', 1)
+    DEALLOCATE(wfx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating wfx', 1)
+    DEALLOCATE(epmatfx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating epmatfx', 1)
+    DEALLOCATE(ufx, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle', 'Error deallocating ufx', 1)
+    DEALLOCATE(w2x, STAT = ierr)
+    IF (ierr /= 0) CALL errore('ephwann_shuffle_mem', 'Error deallocating w2x', 1)
+  ENDIF
   ! Deallocate temperature when no cumulant or supercond
   IF ((.NOT. cumulant) .AND. (.NOT. eliashberg)) THEN
     DEALLOCATE(gtemp, STAT = ierr)
diff --git a/EPW/src/epw_init.f90 b/EPW/src/epw_init.f90
index 87b2fd7a7..47b7ccc9e 100644
--- a/EPW/src/epw_init.f90
+++ b/EPW/src/epw_init.f90
@@ -49,6 +49,8 @@
   USE poolgathering,    ONLY : poolgather_int, poolgather_int1
   USE io_epw,           ONLY : readwfc
   USE dvqpsi,           ONLY : dvanqq2
+  USE Coul_cut_2D,      ONLY : do_cutoff_2D
+  USE Coul_cut_2D_ph,   ONLY : cutoff_lr_Vlocq, cutoff_fact_qg
   USE scf,              ONLY : v, vltot
   USE fft_base,         ONLY : dfftp
   USE fft_interfaces,   ONLY : fwfft
@@ -173,6 +175,19 @@
     !
   END DO
   !
+  ! From PHonon/PH/phq_init.f90
+  ! SP: For 2d calculations, we need to initialize the fact for the q+G
+  ! component of the cutoff of the Coulomb interaction
+  IF (do_cutoff_2D) call cutoff_fact_qg()
+  !
+  ! In 2D calculations the long range part of vlocq(g) (erf/r part)
+  ! was not re-added in g-space because everything is caclulated in
+  ! radial coordinates, which is not compatible with 2D cutoff.
+  ! It will be re-added each time vlocq(g) is used in the code.
+  ! Here, this cutoff long-range part of vlocq(g) is computed only once
+  ! by the routine below and stored
+  IF (do_cutoff_2D) call cutoff_lr_Vlocq()
+  !
   IF (first_run) THEN
     ALLOCATE(igk_k_all(npwx, nkstot), STAT = ierr)
     IF (ierr /= 0) CALL errore('epw_init', 'Error allocating igk_k_all', 1)
diff --git a/EPW/src/epw_readin.f90 b/EPW/src/epw_readin.f90
index 88e4c9f3f..82a5fa663 100644
--- a/EPW/src/epw_readin.f90
+++ b/EPW/src/epw_readin.f90
@@ -60,7 +60,11 @@
                             wannier_plot_supercell, wannier_plot_scale, reduce_unk,    &
                             wannier_plot_radius, fermi_plot, fixsym, epw_no_t_rev,     &
                             epw_tr, epw_nosym, epw_noinv, epw_crysym,                  &
-                            bfieldx, bfieldy, bfieldz, tc_linear, tc_linear_solver
+                            bfieldx, bfieldy, bfieldz, tc_linear, tc_linear_solver,    &
+                            bare, cdfpt_dir, cdfpt_max, cdfpt_min, corr, eig_plot, L,  &
+                            lcdfpt, lpolarc, lpolarx, lxdfpt, perp, phlabel, phlabel,  &
+                            prtgkkc, prtgkkx, temp_inf, type_inf, types,               &
+                            unscreen_fine, xdfpt_dir
   USE klist_epw,     ONLY : xk_all, xk_loc, xk_cryst, isk_all, isk_loc, et_all, et_loc
   USE elph2,         ONLY : elph, num_wannier_plot, wanplotlist, gtemp
   USE constants_epw, ONLY : ryd2mev, ryd2ev, ev2cmm1, kelvin2eV, zero, eps20, ang2m
@@ -80,6 +84,7 @@
   USE paw_variables, ONLY : okpaw
   USE io_epw,        ONLY : param_get_range_vector
   USE open_close_input_file, ONLY : open_input_file, close_input_file
+  USE ph_restart,    ONLY : read_cdfpt_subspace
   !
   ! ---------------------------------------------------------------------------------------
   ! Added for polaron calculations. Originally by Danny Sio, modified by Chao Lian.
@@ -138,7 +143,7 @@
   NAMELIST / inputepw / &
        amass, outdir, prefix, iverbosity, fildvscf, rand_q, rand_nq, rand_k,   &
        elph, nq1, nq2, nq3, nk1, nk2, nk3, nbndsub, rand_nk, specfun_pl, nswc, &
-       filukk, epbread, epbwrite, epwread, epwwrite, etf_mem, nswfc,    &
+       filukk, epbread, epbwrite, epwread, epwwrite, etf_mem, nswfc,           &
        eig_read, wepexst, epexst, vme, elecselfen, phonselfen, use_ws, nc,     &
        degaussw, fsthick, nsmear, delta_smear, nqf1, nqf2, nqf3, nkf1, nkf2,   &
        dvscf_dir, ngaussw, epmatkqread, selecqread, nkf3, mp_mesh_k, mp_mesh_q,&
@@ -161,7 +166,9 @@
        scdm_sigma, assume_metal, wannier_plot, wannier_plot_list, reduce_unk,  &
        wannier_plot_supercell, wannier_plot_scale, wannier_plot_radius,        &
        fixsym, epw_no_t_rev, epw_tr, epw_nosym, epw_noinv, epw_crysym,         &
-       tc_linear, tc_linear_solver,                                            &
+       tc_linear, tc_linear_solver, bare, cdfpt_dir, corr, eig_plot, L,        &
+       lpolarc, lpolarx, perp, phlabel, prtgkkc, prtgkkx, temp_inf, type_inf,  &
+       types, unscreen_fine, xdfpt_dir,                                        &
   !---------------------------------------------------------------------------------
   ! Added for polaron calculations. Originally by Danny Sio, modified by Chao Lian.
   ! Shell implementation for future use.
@@ -204,6 +211,9 @@
   ! elecselfen : if .TRUE. calculate imaginary part of electron selfenergy due to e-p interaction
   ! phonselfen : if .TRUE. calculate imaginary part of phonon selfenergy due to e-p interaction
   ! dvscf_dir  : the dir containing all the .dvscf and .dyn files
+  ! cdfpt_dir  : the dir containing all the .dvscf and .dyn files (cDFPT)
+  ! xdfpt_dir  : the dir containing all the .dvscf and .dyn files (extra DFPT data)
+  ! phlabel    : prefix for files with phonon dispersions
   ! epbread    : read epmatq array from .epb files
   ! epbwrite   : write epmatq array to .epb files
   ! epwread    : read all quantities in Wannier representation from file epwdata.fmt
@@ -238,6 +248,7 @@
   ! ephwrite    : if .TRUE. write el-phonon matrix elements on the fine mesh to file
   ! eps_acustic : min phonon frequency for e-p and a2f calculations (units of cm-1)
   ! band_plot   : if .TRUE. write files to plot band structure and phonon dispersion
+  ! eig_plot    : if .TRUE. write files to plot phonon eigenvectors
   ! fermi_plot  : if .TRUE. write files to plot Fermi surface
   ! degaussq    : smearing for sum over q in e-ph coupling (units of meV)
   ! delta_qsmear: change in energy for each additional smearing in the a2f (units of meV)
@@ -253,6 +264,13 @@
   ! nstemp      : number of temperature points for which the Eliashberg equations are solved
   ! tempsmin    : minimum temperature for which the Eliashberg equations are solved
   ! tempsmax    : maximum temperature " "
+  ! temps        : input temperature array (units of Kelvin)
+  ! temp_inf     : input high smearing (units of Kelvin)
+  ! types        : input smearing types corresponding to temps
+  ! type_inf     : input smearing types corresponding high smearing
+  ! unscreen_fine: if .TRUE. unscreen DFPT phonons on fine mesh
+  ! bare         : if .TRUE. unscreen on coarse mesh in cDFPT case
+  ! corr         : type of DFPT coupling correction: 0 (none), 1, 2, or negative band index
   ! conv_thr_raxis : convergence threshold for iterative solution of real-axis Eliashberg equations
   ! conv_thr_iaxis : convergence threshold for iterative solution of imag-axis Eliashberg equations
   ! conv_thr_racon : convergence threshold for iterative solution of analytic continuation of
@@ -287,6 +305,8 @@
   !
   ! Added by Carla Verdi & Samuel Pon\'e
   ! lpolar     : if .TRUE. enable the correct Wannier interpolation in the case of polar material.
+  ! lpolarc    : if .TRUE. enable the correct Wannier interpolation in the case of polar material (cDFPT)
+  ! lpolarx    : if .TRUE. enable the correct Wannier interpolation in the case of polar material (extra DFPT)
   ! lifc       : if .TRUE. reads interatomic force constants produced by q2r.x for phonon interpolation
   ! asr_typ    : select type of ASR if lifc=.TRUE. (as in matdyn); otherwise it is the usual simple sum rule
   ! lscreen    : if .TRUE. the e-ph matrix elements are screened by the RPA or TF dielectric function
@@ -323,6 +343,8 @@
   ! shortrange      : if .TRUE. computes the short-range part of the el-ph (can
   !                   only be used with lpolar = .TRUE. )
   ! prtgkk          : Print the vertex |g| [meV]. This generates huge outputs.
+  ! prtgkkc         : Print the vertex |g| [meV]. This generates huge outputs (cDFPT)
+  ! prtgkkx         : Print the vertex |g| [meV]. This generates huge outputs (extra DFPT)
   ! etf_mem         : if 0 no optimization, if 1 less memory is used for the fine grid interpolation
   !                   When etf_mem == 2, an additional loop is done on mode for the fine grid interpolation
   !                   part. This reduces the memory further by a factor "nmodes".
@@ -337,6 +359,8 @@
   ! selecqread      : If .TRUE., restart from the selecq.fmt file
   ! nc              : Number of carrier for the Ziman resistivity formula (can be fractional)
   ! bfieldx, y, z   : Value of the magnetic field in Tesla along x, y, z direction.
+  ! L               : Optimized distance between replica in 2D
+  ! perp            : if .TRUE. consider effect of out-of-plane polarizability (for L > 0)
   !
   ! Added by Manos Kioupakis
   ! omegamin        : Photon energy minimum
@@ -454,6 +478,9 @@
   ngaussw      = 1
   outdir       = '.'
   dvscf_dir    = '.'
+  cdfpt_dir    = ' '
+  xdfpt_dir    = ' '
+  phlabel      = 'phband'
   prefix       = 'pwscf'
   filqf        = ' '
   restart_filq = ' '
@@ -489,6 +516,7 @@
   vme          = 'wannier' ! Note: Was .FALSE. by default until EPW v5.1 and then .TRUE. until EPW v5.4
   ephwrite     = .FALSE.
   band_plot    = .FALSE.
+  eig_plot     = .FALSE.
   fermi_plot   = .FALSE.
   nqsmear      = 10
   nqstep       = 500
@@ -502,6 +530,8 @@
   liso         = .FALSE.
   laniso       = .FALSE.
   lpolar       = .FALSE.
+  lpolarc      = .TRUE.
+  lpolarx      = .FALSE.
   lifc         = .FALSE.
   asr_typ      = 'simple'
   lscreen      = .FALSE.
@@ -531,6 +561,12 @@
   gap_edge     = 0.d0
   nstemp       = 0
   temps(:)     = 0.d0
+  temp_inf     = 0.d0
+  types(:)     = -99
+  type_inf     = -99
+  unscreen_fine= .FALSE.
+  bare         = .FALSE.
+  corr         = 0
   nsiter       = 40
   npade        = 90
   muc          = 0.d0
@@ -554,6 +590,8 @@
   longrange    = .FALSE.
   shortrange   = .FALSE.
   prtgkk       = .FALSE.
+  prtgkkc      = .FALSE.
+  prtgkkx      = .FALSE.
   nel          = 0.0d0
   meff         = 1.d0
   epsiheg      = 1.d0
@@ -578,6 +616,8 @@
   bfieldx      = 0.d0  ! Tesla
   bfieldy      = 0.d0  ! Tesla
   bfieldz      = 0.d0  ! Tesla
+  L            = 0.d0  ! Bohr
+  perp         = .FALSE.
   !
   ! --------------------------------------------------------------------------------
   ! Added for polaron calculations. Originally by Danny Sio, modified by Chao Lian.
@@ -750,7 +790,7 @@
       'carrier must be .TRUE. if you specify ncarrier.', 1)
   IF (carrier .AND. (ABS(ncarrier) < 1E+5))  CALL errore('epw_readin', &
       'The absolute value of the doping carrier concentration must be larger than 1E5 cm^-3', 1)
-  IF ((longrange .OR. shortrange) .AND. (.NOT. lpolar)) CALL errore('epw_readin', &
+  IF ((longrange .OR. shortrange) .AND. .NOT. (lpolar .OR. lpolarc)) CALL errore('epw_readin', &
       'Error: longrange or shortrange can only be true if lpolar is true as well.', 1)
   IF (longrange .AND. shortrange) CALL errore('epw_readin',&
       'Error: longrange and shortrange cannot be both true.', 1)
@@ -808,7 +848,7 @@
     WRITE(stdout, '(5x,a)') "The use of 2D interpolation is experimental for now"
     WRITE(stdout, '(5x,a)') "Use with caution"
     WRITE(stdout, '(5x,a)') "WARNING - 2D - WARNING - 2D - WARNING - 2D - WARNING - 2D"
-    CALL errore('epw_readin', '2D interpolation is under developement.', 1)
+    CALL errore('epw_readin', '2D interpolation is under developement.', 0)
   ENDIF
   !
   IF (etf_mem == 3) THEN
@@ -864,6 +904,7 @@
   END IF
   ! go from K to Ry
   temps(:) = temps(:) * kelvin2eV / ryd2ev
+  temp_inf = temp_inf * kelvin2eV / ryd2ev
   !
   CALL mp_bcast(nstemp, meta_ionode_id, world_comm)
   CALL mp_bcast(temps, meta_ionode_id, world_comm)
@@ -925,6 +966,30 @@
   tmp_dir = trimcheck(outdir)
   dvscf_dir = trimcheck(dvscf_dir)
   !
+  ! cDFPT energy window from eV to Ryd
+  !
+  IF (meta_ionode) THEN
+    lcdfpt = cdfpt_dir /= ' '
+    lxdfpt = xdfpt_dir /= ' '
+    !
+    IF (lcdfpt) THEN
+      cdfpt_dir = trimcheck(cdfpt_dir)
+      !
+      CALL read_cdfpt_subspace(TRIM(cdfpt_dir) // TRIM(prefix) &
+        // '.phsave/cdfpt_subspace.xml', cdfpt_min, cdfpt_max)
+      !
+      IF (dis_froz_max == +9999.d0) dis_froz_max = cdfpt_max
+      IF (dis_froz_min == -9999.d0) dis_froz_min = cdfpt_min
+      !
+      cdfpt_min = cdfpt_min / ryd2ev
+      cdfpt_max = cdfpt_max / ryd2ev
+    ELSE
+      lpolarc = .FALSE.
+    ENDIF
+    !
+    IF (lxdfpt) xdfpt_dir = trimcheck(xdfpt_dir)
+  ENDIF
+  !
   CALL bcast_epw_input()
   !
   !   Here we finished the reading of the input file.
diff --git a/EPW/src/epwcom.f90 b/EPW/src/epwcom.f90
index 3ec6afc2c..ae725c9ae 100644
--- a/EPW/src/epwcom.f90
+++ b/EPW/src/epwcom.f90
@@ -21,6 +21,12 @@
   !
   CHARACTER(LEN = 100) :: dvscf_dir ='./'
   !! directory for .dvscf and .dyn files (wannier interpolation)
+  CHARACTER(LEN = 100) :: cdfpt_dir = ' '
+  !! directory for .dvscf and .dyn files (wannier interpolation) (cDFPT)
+  CHARACTER(LEN = 100) :: xdfpt_dir = ' '
+  !! directory for .dvscf and .dyn files (wannier interpolation) (extra DFPT data)
+  CHARACTER(LEN = 100) :: phlabel = 'phband'
+  !! prefix for files with phonon dispersions
   CHARACTER(LEN = 80) :: fileig
   !! output file for the electron-phonon coefficients
   CHARACTER(LEN = 256) :: proj(200)
@@ -92,10 +98,16 @@
   !! if .TRUE. prefix.epmatwp files are already on disk. don't recalculate. debugging param
   LOGICAL :: band_plot
   !! if .TRUE. write files to plot band structure and phonon dispersion
+  LOGICAL :: eig_plot
+  !! if .TRUE. write files to plot band structure and phonon dispersion
   LOGICAL :: fermi_plot
   !! if .TRUE. write files to plot Fermi surface
   LOGICAL :: lpolar
   !! if .TRUE. enable the correct Wannier interpolation in the case of polar material.
+  LOGICAL :: lpolarc
+  !! if .TRUE. enable the correct Wannier interpolation in the case of polar material (cDFPT)
+  LOGICAL :: lpolarx
+  !! if .TRUE. enable the correct Wannier interpolation in the case of polar material (extra DFPT)
   LOGICAL :: lscreen
   !! if .TRUE. the e-ph matrix elements are screened by the RPA or TF dielectric function
   LOGICAL :: lifc
@@ -112,6 +124,10 @@
   !! if .TRUE. the system is 2 dimensional (vaccum is in z-direction)
   LOGICAL :: prtgkk
   !! if .TRUE. print the |g| vertex in [meV].
+  LOGICAL :: prtgkkc
+  !! if .TRUE. print the |g| vertex in [meV] (cDFPT)
+  LOGICAL :: prtgkkx
+  !! if .TRUE. print the |g| vertex in [meV] (extra DFPT)
   LOGICAL :: lphase
   !! if .TRUE. fix the gauge when diagonalizing the interpolated dynamical matrix and electronic Hamiltonian.
   LOGICAL :: lindabs
@@ -124,6 +140,14 @@
   !! if .TRUE. restart from the selecq.fmt file
   LOGICAL :: assume_metal
   !! if .TRUE. we are dealing with a metal.
+  LOGICAL :: lcdfpt
+  !! if .TRUE. process both DFPT and cDFPT data and renormalize cDFPT phonons
+  LOGICAL :: lxdfpt
+  !! if .TRUE. process an extra set of DFPT data (e.g., at low temperature)
+  LOGICAL :: unscreen_fine
+  !! if .TRUE. unscreen DFPT phonons on fine mesh
+  LOGICAL :: bare
+  !! if .TRUE. unscreen on coarse mesh in cDFPT case
   !
   ! Superconductivity
   LOGICAL :: ephwrite
@@ -239,6 +263,14 @@
   !! max. temperature - deprecated as an input parameter
   REAL(KIND = DP) :: temps(50)
   !! input temperature array (units of Kelvin)
+  REAL(KIND = DP) :: temp_inf
+  !! input high smearing (units of Kelvin)
+  INTEGER :: types(50)
+  !! input smearing types corresponding to temps
+  INTEGER :: type_inf
+  !! input smearing types corresponding high smearing
+  INTEGER :: corr
+  !! type of DFPT coupling correction: 0 (none), 1, 2, or negative band index
   !
   ! Superconductivity
   INTEGER :: nswfc
@@ -268,6 +300,14 @@
   !! max frequency for frequency scan in \delta( e_k - e_k+q - w ) when strict sel. rule is applied
   REAL(KIND = DP) :: delta_smear
   !! change in energy for each additional smearing in the selfen_phon
+  REAL(KIND = DP) :: L
+  !! Distance between replica in 2D
+  REAL(KIND = DP) :: cdfpt_min
+  !! lower bound of cDFPT energy window
+  REAL(KIND = DP) :: cdfpt_max
+  !! upper bound of cDFPT energy window
+  LOGICAL :: perp
+  !! if .TRUE. consider effect of out-of-plane polarizability (for L > 0)
   !
   ! Wannierization
   CHARACTER(LEN = 255) :: wannier_plot_list
diff --git a/EPW/src/io_epw.f90 b/EPW/src/io_epw.f90
index 30e0cbeb1..45a4c7f72 100644
--- a/EPW/src/io_epw.f90
+++ b/EPW/src/io_epw.f90
@@ -117,15 +117,16 @@
     !! Routine to write files on real-space grid for fine grid interpolation
     !!
     USE kinds,     ONLY : DP
-    USE epwcom,    ONLY : nbndsub, vme, eig_read, etf_mem
+    USE epwcom,    ONLY : nbndsub, vme, eig_read, etf_mem, lcdfpt, lxdfpt
     USE pwcom,     ONLY : ef, nelec
-    USE elph2,     ONLY : chw, rdw, cdmew, cvmew, chw_ks, &
-                          zstar, epsi, epmatwp
+    USE klist,     ONLY : degauss, ngauss
+    USE elph2,     ONLY : chw, rdw, rdwc, rdwcr, rdwr, rdwx, cdmew, cvmew, chw_ks, &
+                          zstar, zstarc, zstarx, epsi, epsic, epsix, epmatwp, epmatwpc, epmatwpx
     USE ions_base, ONLY : amass, ityp, nat, tau
     USE cell_base, ONLY : at, bg, omega, alat
     USE modes,     ONLY : nmodes
     USE io_var,    ONLY : epwdata, iundmedata, iunvmedata, iunksdata, iunepmatwp, &
-                          crystal
+                          crystal, iunepmatwpc, iunepmatwpx
     USE noncollin_module, ONLY : noncolin
     USE io_files,  ONLY : prefix, diropn, tmp_dir
     USE mp,        ONLY : mp_barrier
@@ -182,6 +183,8 @@
       WRITE(crystal,*) nat
       WRITE(crystal,*) nmodes
       WRITE(crystal,*) nelec
+      WRITE(crystal,*) degauss
+      WRITE(crystal,*) ngauss
       WRITE(crystal,*) at
       WRITE(crystal,*) bg
       WRITE(crystal,*) omega
@@ -195,6 +198,8 @@
       WRITE(epwdata,*) ef
       WRITE(epwdata,*) nbndsub, nrr_k, nmodes, nrr_q, nrr_g
       WRITE(epwdata,*) zstar, epsi
+      IF (lcdfpt) WRITE(epwdata,*) zstarc, epsic
+      IF (lxdfpt) WRITE(epwdata,*) zstarx, epsix
       !
       DO ibnd = 1, nbndsub
         DO jbnd = 1, nbndsub
@@ -216,6 +221,12 @@
         DO jmode = 1, nmodes
           DO irq = 1, nrr_q
             WRITE(epwdata,*) rdw(imode, jmode, irq)
+            IF (lcdfpt) THEN
+              WRITE(epwdata,*) rdwc(imode, jmode, irq)
+              WRITE(epwdata,*) rdwr(imode, jmode, irq)
+              WRITE(epwdata,*) rdwcr(imode, jmode, irq)
+            ENDIF
+            IF (lxdfpt) WRITE(epwdata,*) rdwx(imode, jmode, irq)
           ENDDO
         ENDDO
       ENDDO
@@ -227,20 +238,36 @@
         !     Note that in Fortran the record length has to be a integer
         !     of kind 4.
         lrepmatw = 2 * nbndsub * nbndsub * nrr_k * nmodes
-        filint   = TRIM(tmp_dir) // TRIM(prefix)//'.epmatwp'
+        filint   = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwp'
         INQUIRE(IOLENGTH = direct_io_factor) dummy
         unf_recl = direct_io_factor * INT(lrepmatw, KIND = KIND(unf_recl))
         IF (unf_recl <= 0) CALL errore('epw_write', 'wrong record length', 3)
         OPEN(iunepmatwp, FILE = TRIM(ADJUSTL(filint)), IOSTAT = ierr, form='unformatted', &
              STATUS = 'unknown', ACCESS = 'direct', RECL = unf_recl)
         IF (ierr /= 0) CALL errore('epw_write', 'error opening ' // TRIM(filint), 1)
+        IF (lcdfpt) THEN
+          filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwpc'
+          OPEN(iunepmatwpc, FILE = TRIM(ADJUSTL(filint)), IOSTAT = ierr, form='unformatted', &
+               STATUS = 'unknown', ACCESS = 'direct', RECL = unf_recl)
+          IF (ierr /= 0) CALL errore('epw_write', 'error opening ' // TRIM(filint), 1)
+        ENDIF
+        IF (lxdfpt) THEN
+          filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwpx'
+          OPEN(iunepmatwpx, FILE = TRIM(ADJUSTL(filint)), IOSTAT = ierr, form='unformatted', &
+               STATUS = 'unknown', ACCESS = 'direct', RECL = unf_recl)
+          IF (ierr /= 0) CALL errore('epw_write', 'error opening ' // TRIM(filint), 1)
+        ENDIF
         !
         !CALL diropn(iunepmatwp, 'epmatwp', lrepmatw, exst)
         DO irg = 1, nrr_g
           CALL davcio(epmatwp(:, :, :, :, irg), lrepmatw, iunepmatwp, irg, +1)
+          IF (lcdfpt) CALL davcio(epmatwpc(:, :, :, :, irg), lrepmatw, iunepmatwpc, irg, +1)
+          IF (lxdfpt) CALL davcio(epmatwpx(:, :, :, :, irg), lrepmatw, iunepmatwpx, irg, +1)
         ENDDO
         !
         CLOSE(iunepmatwp)
+        IF (lcdfpt) CLOSE(iunepmatwpc)
+        IF (lxdfpt) CLOSE(iunepmatwpx)
       ENDIF
       !
       CLOSE(epwdata)
@@ -264,14 +291,18 @@
     !! Routine to read the real space quantities for fine grid interpolation
     !!
     USE kinds,     ONLY : DP
-    USE epwcom,    ONLY : nbndsub, vme, eig_read, etf_mem, lifc
+    USE epwcom,    ONLY : nbndsub, vme, eig_read, etf_mem, lifc, cdfpt_dir, dvscf_dir, &
+                          lcdfpt, lxdfpt, xdfpt_dir
     USE pwcom,     ONLY : ef
-    USE elph2,     ONLY : chw, rdw, epmatwp, cdmew, cvmew, chw_ks, zstar, epsi
+    USE elph2,     ONLY : chw, rdw, rdwc, rdwcr, rdwr, rdwx, epmatwp, epmatwpc, epmatwpx, &
+                          cdmew, cvmew, chw_ks, zstar, zstarc, zstarx, epsi, epsic, epsix, &
+                          ifc, ifcc, ifccr, ifcr, ifcx
     USE ions_base, ONLY : nat
     USE modes,     ONLY : nmodes
     USE io_global, ONLY : stdout
     USE io_files,  ONLY : prefix, diropn, tmp_dir
-    USE io_var,    ONLY : epwdata, iundmedata, iunvmedata, iunksdata, iunepmatwp
+    USE io_var,    ONLY : epwdata, iundmedata, iunvmedata, iunksdata, iunepmatwp, &
+                          iunepmatwpc, iunepmatwpx
     USE constants_epw, ONLY : czero, zero
 #if defined(__NAG)
     USE f90_unix_io,ONLY : flush
@@ -326,6 +357,18 @@
     IF (ierr /= 0) CALL errore('epw_read', 'Error allocating zstar', 1)
     ALLOCATE(epsi(3, 3), STAT = ierr)
     IF (ierr /= 0) CALL errore('epw_read', 'Error allocating epsi', 1)
+    IF (lcdfpt) THEN
+      ALLOCATE(zstarc(3, 3, nat), STAT = ierr)
+      IF (ierr /= 0) CALL errore('epw_read', 'Error allocating zstarc', 1)
+      ALLOCATE(epsic(3, 3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('epw_read', 'Error allocating epsic', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      ALLOCATE(zstarx(3, 3, nat), STAT = ierr)
+      IF (ierr /= 0) CALL errore('epw_read', 'Error allocating zstarx', 1)
+      ALLOCATE(epsix(3, 3), STAT = ierr)
+      IF (ierr /= 0) CALL errore('epw_read', 'Error allocating epsix', 1)
+    ENDIF
     !
     IF (mpime == ionode_id) THEN
       !
@@ -343,6 +386,8 @@
       READ(epwdata,*) ef
       READ(epwdata,*) nbndsub, nrr_k, nmodes, nrr_q, nrr_g
       READ(epwdata,*) zstar, epsi
+      IF (lcdfpt) READ(epwdata,*) zstarc, epsic
+      IF (lxdfpt) READ(epwdata,*) zstarx, epsix
       !
     ENDIF
     CALL mp_bcast(ef,      ionode_id, world_comm)
@@ -353,6 +398,14 @@
     CALL mp_bcast(nrr_g,   ionode_id, world_comm)
     CALL mp_bcast(zstar,   ionode_id, world_comm)
     CALL mp_bcast(epsi,    ionode_id, world_comm)
+    IF (lcdfpt) THEN
+      CALL mp_bcast(zstarc,  ionode_id, world_comm)
+      CALL mp_bcast(epsic,   ionode_id, world_comm)
+    ENDIF
+    IF (lxdfpt) THEN
+      CALL mp_bcast(zstarx,  ionode_id, world_comm)
+      CALL mp_bcast(epsix,   ionode_id, world_comm)
+    ENDIF
     !
     ALLOCATE(chw(nbndsub, nbndsub, nrr_k), STAT = ierr)
     IF (ierr /= 0) CALL errore('epw_read', 'Error allocating chw', 1)
@@ -360,6 +413,18 @@
     IF (ierr /= 0) CALL errore('epw_read', 'Error allocating chw_ks', 1)
     ALLOCATE(rdw(nmodes, nmodes,  nrr_q), STAT = ierr)
     IF (ierr /= 0) CALL errore('epw_read', 'Error allocating rdw', 1)
+    IF (lcdfpt) THEN
+      ALLOCATE(rdwc(nmodes, nmodes,  nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('epw_read', 'Error allocating rdwc', 1)
+      ALLOCATE(rdwr(nmodes, nmodes,  nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('epw_read', 'Error allocating rdwr', 1)
+      ALLOCATE(rdwcr(nmodes, nmodes,  nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('epw_read', 'Error allocating rdwcr', 1)
+    ENDIF
+    IF (lxdfpt) THEN
+      ALLOCATE(rdwx(nmodes, nmodes,  nrr_q), STAT = ierr)
+      IF (ierr /= 0) CALL errore('epw_read', 'Error allocating rdwx', 1)
+    ENDIF
     IF (vme == 'wannier') THEN
       ALLOCATE(cvmew(3, nbndsub, nbndsub, nrr_k), STAT = ierr)
       IF (ierr /= 0) CALL errore('epw_read', 'Error allocating cvmew', 1)
@@ -391,6 +456,12 @@
          DO jmode = 1, nmodes
            DO irq = 1, nrr_q
              READ(epwdata,*) rdw(imode, jmode, irq)
+             IF (lcdfpt) THEN
+               READ(epwdata,*) rdwc(imode, jmode, irq)
+               READ(epwdata,*) rdwr(imode, jmode, irq)
+               READ(epwdata,*) rdwcr(imode, jmode, irq)
+             ENDIF
+             IF (lxdfpt) READ(epwdata,*) rdwx(imode, jmode, irq)
            ENDDO
          ENDDO
        ENDDO
@@ -401,7 +472,15 @@
     CALL mp_bcast(chw, ionode_id, world_comm)
     !
     IF (eig_read) CALL mp_bcast(chw_ks, ionode_id, world_comm)
-    IF (.NOT. lifc) CALL mp_bcast(rdw, ionode_id, world_comm)
+    IF (.NOT. lifc) THEN
+      CALL mp_bcast(rdw, ionode_id, world_comm)
+      IF (lcdfpt) THEN
+         CALL mp_bcast(rdwc, ionode_id, world_comm)
+         CALL mp_bcast(rdwr, ionode_id, world_comm)
+         CALL mp_bcast(rdwcr, ionode_id, world_comm)
+      ENDIF
+      IF (lxdfpt) CALL mp_bcast(rdwx, ionode_id, world_comm)
+    ENDIF
     !
     IF (vme == 'wannier') THEN
       CALL mp_bcast(cvmew, ionode_id, world_comm)
@@ -410,7 +489,15 @@
     ENDIF
     !
     IF (lifc) THEN
-      CALL read_ifc_epw
+      CALL read_ifc_epw(dvscf_dir, ifc, epsi, zstar)
+      IF (lcdfpt) THEN
+        CALL read_ifc_epw(cdfpt_dir, ifcc, epsic, zstarc)
+        CALL read_ifc_epw(cdfpt_dir, ifcr, epsi, zstar)
+        CALL read_ifc_epw(cdfpt_dir, ifccr, epsi, zstar)
+      ENDIF
+      IF (lxdfpt) THEN
+        CALL read_ifc_epw(xdfpt_dir, ifcx, epsix, zstarx)
+      ENDIF
     ENDIF
     !
     IF (etf_mem == 0) THEN
@@ -424,7 +511,7 @@
         !     Note that in Fortran the record length has to be a integer
         !     of kind 4.
         lrepmatw = 2 * nbndsub * nbndsub * nrr_k * nmodes
-        filint   = TRIM(tmp_dir) // TRIM(prefix)//'.epmatwp'
+        filint   = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwp'
         !
         INQUIRE(IOLENGTH = direct_io_factor) dummy
         unf_recl = direct_io_factor * INT(lrepmatw, KIND = KIND(unf_recl))
@@ -432,12 +519,28 @@
         OPEN(iunepmatwp, FILE = TRIM(ADJUSTL(filint)), IOSTAT = ierr, FORM = 'unformatted', &
              STATUS = 'unknown', ACCESS = 'direct', RECL = unf_recl)
         IF (ierr /= 0) CALL errore('epw_read', 'error opening ' // TRIM(filint), 1)
+        IF (lcdfpt) THEN
+          filint   = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwpc'
+          OPEN(iunepmatwpc, FILE = TRIM(ADJUSTL(filint)), IOSTAT = ierr, FORM = 'unformatted', &
+               STATUS = 'unknown', ACCESS = 'direct', RECL = unf_recl)
+          IF (ierr /= 0) CALL errore('epw_read', 'error opening ' // TRIM(filint), 1)
+        ENDIF
+        IF (lxdfpt) THEN
+          filint   = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwpx'
+          OPEN(iunepmatwpx, FILE = TRIM(ADJUSTL(filint)), IOSTAT = ierr, FORM = 'unformatted', &
+               STATUS = 'unknown', ACCESS = 'direct', RECL = unf_recl)
+          IF (ierr /= 0) CALL errore('epw_read', 'error opening ' // TRIM(filint), 1)
+        ENDIF
         !
         DO irg = 1, nrr_g
           CALL davcio(epmatwp(:, :, :, :, irg), lrepmatw, iunepmatwp, irg, -1)
+          IF (lcdfpt) CALL davcio(epmatwpc(:, :, :, :, irg), lrepmatw, iunepmatwpc, irg, -1)
+          IF (lxdfpt) CALL davcio(epmatwpx(:, :, :, :, irg), lrepmatw, iunepmatwpx, irg, -1)
         ENDDO
         !
         CLOSE(iunepmatwp)
+        IF (lcdfpt) CLOSE(iunepmatwpc)
+        IF (lxdfpt) CLOSE(iunepmatwpx)
       ENDIF
       !
       CALL mp_bcast(epmatwp, ionode_id, world_comm)
@@ -461,7 +564,7 @@
     !------------------------------------------------------------------------------
     !
     !---------------------------------------------------------------------------------
-    SUBROUTINE read_ifc_epw()
+    SUBROUTINE read_ifc_epw(dvscf_dir, ifc, epsi, zstar)
     !---------------------------------------------------------------------------------
     !!
     !! Read IFC in real space from the file generated by q2r.
@@ -469,8 +572,7 @@
     !!
     !
     USE kinds,     ONLY : DP
-    USE elph2,     ONLY : ifc, zstar, epsi
-    USE epwcom,    ONLY : asr_typ, dvscf_dir, nqc1, nqc2, nqc3
+    USE epwcom,    ONLY : asr_typ, nqc1, nqc2, nqc3
     USE ions_base, ONLY : nat
     USE cell_base, ONLY : ibrav, omega, at, bg, celldm, alat
     USE io_global, ONLY : stdout
@@ -488,6 +590,15 @@
     !
     IMPLICIT NONE
     !
+    CHARACTER(LEN = 100), INTENT(IN) :: dvscf_dir
+    !! directory for .dvscf and .dyn files (wannier interpolation)
+    REAL(KIND = DP), INTENT(out) :: ifc(nqc1, nqc2, nqc3, 3, 3, nat, nat)
+    !! Interatomic force constant in real space
+    REAL(KIND = DP), INTENT(out) :: epsi(3, 3)
+    !! dielectric constant tensor
+    REAL(KIND = DP), INTENT(out) :: zstar(3, 3, nat)
+    !! effective charges tensor
+    !
     ! Local variables
     LOGICAL :: lpolar_
     !! Polar flag
@@ -748,6 +859,8 @@
     ! (i.e. the rotation axis is (Ox) if axis='1', (Oy) if axis='2' and (Oz) if
     ! axis='3')
     !
+    IF (asr == 'none') RETURN
+    !
     IF ((asr /= 'simple') .AND. (asr /= 'crystal') .AND. (asr /= 'one-dim') .AND. (asr /= 'zero-dim')) THEN
       CALL errore('set_asr','invalid Acoustic Sum Rule:' // asr, 1)
     ENDIF
@@ -1413,7 +1526,7 @@
     !------------------------------------------------------------------------------
     !
     !-------------------------------------------------------------
-    SUBROUTINE readdvscf(dvscf, recn, iq, nqc)
+    SUBROUTINE readdvscf(dvscf_dir, dvscf, recn, iq, nqc)
     !-------------------------------------------------------------
     !!
     !! Open dvscf files as direct access, read, and close again
@@ -1429,13 +1542,14 @@
     USE io_files,  ONLY : prefix
     USE units_ph,  ONLY : lrdrho
     USE fft_base,  ONLY : dfftp
-    USE epwcom,    ONLY : dvscf_dir
     USE io_var,    ONLY : iudvscf
     USE low_lvl,   ONLY : set_ndnmbr
     USE noncollin_module, ONLY : nspin_mag
     !
     IMPLICIT NONE
     !
+    CHARACTER(LEN = 100), INTENT(IN) :: dvscf_dir
+    !! directory for .dvscf and .dyn files (wannier interpolation)
     INTEGER, INTENT(in) :: recn
     !! perturbation number
     INTEGER, INTENT(in) :: iq
@@ -1495,7 +1609,7 @@
     !-------------------------------------------------------------
     !
     !-------------------------------------------------------------
-    SUBROUTINE readint3paw(int3paw, recn, iq, nqc)
+    SUBROUTINE readint3paw(dvscf_dir, int3paw, recn, iq, nqc)
     !-------------------------------------------------------------
     !!
     !! Open int3paw files as direct access, read, and close again
@@ -1506,7 +1620,6 @@
     USE kinds,            ONLY : DP
     USE io_files,         ONLY : prefix
     USE units_ph,         ONLY : lint3paw
-    USE epwcom,           ONLY : dvscf_dir
     USE io_var,           ONLY : iuint3paw
     USE low_lvl,          ONLY : set_ndnmbr
     USE uspp_param,       ONLY : nhm
@@ -1515,6 +1628,8 @@
     !
     IMPLICIT NONE
     !
+    CHARACTER(LEN = 100), INTENT(IN) :: dvscf_dir
+    !! directory for .dvscf and .dyn files (wannier interpolation)
     INTEGER, INTENT(in) :: recn
     !! perturbation number
     INTEGER, INTENT(in) :: iq
diff --git a/EPW/src/io_var.f90 b/EPW/src/io_var.f90
index bf45c62af..06c570faf 100644
--- a/EPW/src/io_var.f90
+++ b/EPW/src/io_var.f90
@@ -24,11 +24,13 @@
             iua2ffil, iudosfil, iufillambda, iuqdos, iufe, iufilker, iuquad,  &
             iufilgap, iospectral_sup, iua2ftrfil, iufilgapFS, iufillambdaFS,  &
             iospectral_cum, iuwanep, iuwane, iunukk, iudvscf, iuqpeig, iures, &
-            iuint3paw
+            iuint3paw, iudipole
   PUBLIC :: epwdata, iundmedata, iunvmedata, iunksdata, iudyn, iukgmap, iuepb, &
             iufilfreq, iufilegnv, iufileph, iufilkqmap, iunpattern, iufilmu_q, &
             iufilikmap, iueig, iunepmatwp, iunepmatwe, iunkf, iunqf, iufilFS,  &
-            iufileig, iukmap, crystal, iunifc, iunimem, iunepmatwp2
+            iufileig, iukmap, crystal, iunifc, iunimem, iunepmatwp2,           &
+            iunepmatwec, iunepmatwex, iunepmatwpc, iunepmatwpc2, iunepmatwpx,  &
+            iunepmatwpx2, iunwigner
   PUBLIC :: iuwinfil, iun_plot, iuprojfil, iudecayH, iudecayP, &
             iudecaydyn, iudecayv, iunnkp, iuamn, iummn, iubvec
   PUBLIC :: iufilsigma, iufilseebeck, iufilkappael, iufilkappa, iufilscatt_rate,   &
@@ -70,6 +72,7 @@
                                    ! [specfun_cum##.elself]
   INTEGER :: iunukk          = 77  ! Unit with rotation matrix U(k) from wannier code
   INTEGER :: iuquad          = 78  ! Unit to read the quadrupole tensor from file
+  INTEGER :: iudipole        = 79  ! Unit to read the Born effective charges from file
   INTEGER :: iudvscf         = 80  ! Unit for the dvscf_q file
   INTEGER :: iudyn           = 81  ! Unit for the dynamical matrix file
   INTEGER :: iufilkqmap      = 82  ! Map of k+q
@@ -128,6 +131,13 @@
   INTEGER :: iuqpeig         = 144  ! Reading quasi-particle eigenenergies from file
   INTEGER :: iunpattern      = 145  ! Unit for reading the pattern files.
   INTEGER :: iufilFS         = 146  ! Unit for Fermi surface files
+  INTEGER :: iunepmatwpc     = 147  ! The unit with the e-ph matrix in Wannier-Wannier representation (cDFPT)
+  INTEGER :: iunepmatwpx     = 148  ! The unit with the e-ph matrix in Wannier-Wannier representation (extra DFPT)
+  INTEGER :: iunepmatwec     = 149  ! The unit with the e-ph matrix in Wannier-Bloch representation (cDPFT)
+  INTEGER :: iunepmatwex     = 150  ! The unit with the e-ph matrix in Wannier-Bloch representation (extra DPFT)
+  INTEGER :: iunepmatwpc2    = 151  ! Opening the epmatwp file (cDFPT)
+  INTEGER :: iunepmatwpx2    = 152  ! Opening the epmatwp file (extra DFPT)
+  INTEGER :: iunwigner       = 153  ! Wigner-Seitz lattice vectors corresponding to epmatwp file
   !
   ! Output quantites related to Wannier (201-250)
   !
diff --git a/EPW/src/printing.f90 b/EPW/src/printing.f90
index c813a0dd0..a835617e4 100644
--- a/EPW/src/printing.f90
+++ b/EPW/src/printing.f90
@@ -16,7 +16,7 @@
   CONTAINS
     !
     !-----------------------------------------------------------------------
-    SUBROUTINE print_gkk(iq)
+    SUBROUTINE print_gkk(iq, epf17, wf, totq)
     !-----------------------------------------------------------------------
     !!
     !! Print the |g| vertex for all n,n' and modes in meV and do average
@@ -28,7 +28,7 @@
     USE modes,         ONLY : nmodes
     USE epwcom,        ONLY : nbndsub
     USE elph2,         ONLY : etf, ibndmin, nkqf, xqf, nbndfst,    &
-                              nkf, epf17, xkf, nkqtotf, wf, nktotf
+                              nkf, xkf, nkqtotf, nktotf
     USE constants_epw, ONLY : ryd2mev, ryd2ev, two, zero
     USE mp,            ONLY : mp_barrier, mp_sum
     USE mp_global,     ONLY : inter_pool_comm
@@ -41,6 +41,12 @@
     !
     INTEGER, INTENT(in) :: iq
     !! Current q-point index
+    COMPLEX(KIND = DP), INTENT(in) :: epf17(nbndfst, nbndfst, nmodes, nkf)
+    !! full ep matrix in bloch rep stored in mem
+    INTEGER, INTENT(in) :: totq
+    !! Total number of q-points in selecq.fmt
+    REAL(KIND = DP), INTENT(in) :: wf(nmodes, totq)
+    ! interpolated eigenfrequencies
     !
     ! Local variables
     INTEGER :: lower_bnd
@@ -1021,22 +1027,21 @@
     !-----------------------------------------------------------------------
     !
     !-----------------------------------------------------------------------
-    SUBROUTINE plot_band()
+    SUBROUTINE plot_band_elec()
     !-----------------------------------------------------------------------
     !!
-    !! This routine writes output files for phonon dispersion and band structure
+    !! This routine writes the output file for the electronic band structure
     !! SP : Modified so that it works with the current plotband.x of QE 5
     !!
     USE kinds,         ONLY : DP
     USE cell_base,     ONLY : at, bg
-    USE modes,         ONLY : nmodes
-    USE epwcom,        ONLY : nbndsub, filqf, filkf
-    USE elph2,         ONLY : etf, nkf, nqtotf, wf, xkf, xqf, nkqtotf, nktotf
-    USE constants_epw, ONLY : ryd2mev, ryd2ev, zero
-    USE io_var,        ONLY : iufilfreq, iufileig
+    USE epwcom,        ONLY : nbndsub, filkf
+    USE elph2,         ONLY : etf, nkf, xkf, nkqtotf, nktotf
+    USE constants_epw, ONLY : ryd2ev, zero
+    USE io_var,        ONLY : iufileig
     USE elph2,         ONLY : nkqf
     USE io_global,     ONLY : ionode_id
-    USE mp,            ONLY : mp_barrier, mp_sum
+    USE mp,            ONLY : mp_barrier
     USE mp_global,     ONLY : inter_pool_comm, my_pool_id
     USE poolgathering, ONLY : poolgather2
     !
@@ -1051,10 +1056,6 @@
     !! Index for the q-point
     INTEGER :: ibnd
     !! Band index
-    INTEGER :: imode
-    !! Mode index
-    INTEGER :: iq
-    !! Global q-point index
     INTEGER :: ierr
     !! Error status
     REAL(KIND = DP) :: dist
@@ -1068,42 +1069,6 @@
     REAL(KIND = DP), ALLOCATABLE :: etf_all(:, :)
     !! Eigenenergies on the full k grid (all pools)
     !
-    IF (filqf /= ' ') THEN
-      !
-      IF (my_pool_id == ionode_id) THEN
-        !
-        OPEN(iufilfreq, FILE = "phband.freq", FORM = 'formatted')
-        WRITE(iufilfreq, '(" &plot nbnd=", i4, ", nks=", i6, " /")') nmodes, nqtotf
-        !
-        ! crystal to cartesian coordinates
-        CALL cryst_to_cart(nqtotf, xqf, bg, 1)
-        !
-        dist  = zero
-        dprev = zero
-        dcurr = zero
-        DO iq = 1, nqtotf
-          !
-          IF (iq /= 1) THEN
-            dist = DSQRT((xqf(1, iq) - xqf(1, iq - 1)) * (xqf(1, iq) - xqf(1, iq - 1)) &
-                       + (xqf(2, iq) - xqf(2, iq - 1)) * (xqf(2, iq) - xqf(2, iq - 1)) &
-                       + (xqf(3, iq) - xqf(3, iq - 1)) * (xqf(3, iq) - xqf(3, iq - 1)))
-          ELSE
-            dist = zero
-          ENDIF
-          dcurr = dprev + dist
-          dprev = dcurr
-          WRITE(iufilfreq, '(10x, 3f10.6)') xqf(:, iq)
-          WRITE(iufilfreq, '(1000f14.4)') (wf(imode, iq) * ryd2mev, imode = 1, nmodes)
-          !
-        ENDDO
-        CLOSE(iufilfreq)
-        !
-        ! back from cartesian to crystal coordinates
-        CALL cryst_to_cart(nqtotf, xqf, at, -1)
-        !
-      ENDIF
-    ENDIF ! filqf
-    !
     IF (filkf /= ' ') THEN
       !
       DO ik = 1, nkf
@@ -1175,7 +1140,84 @@
     RETURN
     !
     !----------------------------------------------------------------------------
-    END SUBROUTINE plot_band
+    END SUBROUTINE plot_band_elec
+    !----------------------------------------------------------------------------
+    !
+    !-----------------------------------------------------------------------
+    SUBROUTINE plot_band_phon(filename, wf)
+    !-----------------------------------------------------------------------
+    !!
+    !! This routine writes output files for phonon dispersions
+    !! SP : Modified so that it works with the current plotband.x of QE 5
+    !!
+    USE kinds,         ONLY : DP
+    USE cell_base,     ONLY : at, bg
+    USE epwcom,        ONLY : filqf
+    USE elph2,         ONLY : etf, nkf, nqtotf, xqf
+    USE constants_epw, ONLY : ryd2mev, zero
+    USE io_var,        ONLY : iufilfreq
+    USE io_global,     ONLY : ionode_id
+    USE mp_global,     ONLY : my_pool_id
+    !
+    IMPLICIT NONE
+    !
+    CHARACTER(LEN = *), INTENT(in) :: filename
+    !! File name, typically 'phband.freq'
+    REAL(KIND = DP), INTENT(in) :: wf(:, :)
+    !! Interpolated eigenfrequencies
+    !
+    ! Local variables
+    INTEGER :: imode
+    !! Mode index
+    INTEGER :: iq
+    !! Global q-point index
+    REAL(KIND = DP) :: dist
+    !! Distance from G-point
+    REAL(KIND = DP) :: dprev
+    !! Previous distance
+    REAL(KIND = DP) :: dcurr
+    !! Current distance
+    !
+    IF (filqf /= ' ') THEN
+      !
+      IF (my_pool_id == ionode_id) THEN
+        !
+        OPEN(iufilfreq, FILE = TRIM(filename), FORM = 'formatted')
+        WRITE(iufilfreq, '(" &plot nbnd=", i4, ", nks=", i6, " /")') SIZE(wf, 1), nqtotf
+        !
+        ! crystal to cartesian coordinates
+        CALL cryst_to_cart(nqtotf, xqf, bg, 1)
+        !
+        dist  = zero
+        dprev = zero
+        dcurr = zero
+        DO iq = 1, nqtotf
+          !
+          IF (iq /= 1) THEN
+            dist = DSQRT((xqf(1, iq) - xqf(1, iq - 1)) * (xqf(1, iq) - xqf(1, iq - 1)) &
+                       + (xqf(2, iq) - xqf(2, iq - 1)) * (xqf(2, iq) - xqf(2, iq - 1)) &
+                       + (xqf(3, iq) - xqf(3, iq - 1)) * (xqf(3, iq) - xqf(3, iq - 1)))
+          ELSE
+            dist = zero
+          ENDIF
+          dcurr = dprev + dist
+          dprev = dcurr
+          WRITE(iufilfreq, '(10x, 3f10.6)') xqf(:, iq)
+          WRITE(iufilfreq, '(1000(10es14.6e2, :, /))') (wf(imode, iq) * ryd2mev, imode = 1, SIZE(wf, 1))
+          !
+        ENDDO
+        CLOSE(iufilfreq)
+        !
+        ! back from cartesian to crystal coordinates
+        CALL cryst_to_cart(nqtotf, xqf, at, -1)
+        !
+      ENDIF
+    ENDIF ! filqf
+    !
+    RETURN
+    !
+    !----------------------------------------------------------------------------
+    END SUBROUTINE plot_band_phon
     !----------------------------------------------------------------------------
     !
     !-----------------------------------------------------------------------
diff --git a/EPW/src/rigid_epw.f90 b/EPW/src/rigid_epw.f90
index 7d9d5d540..09c8dd4e4 100644
--- a/EPW/src/rigid_epw.f90
+++ b/EPW/src/rigid_epw.f90
@@ -118,7 +118,7 @@
     !--------------------------------------------------------------------------
     !
     !-----------------------------------------------------------------------
-    SUBROUTINE rgd_blk(nqc1, nqc2, nqc3, nat, dyn, q, tau, epsil, zeu, signe)
+    SUBROUTINE rgd_blk(nqc1, nqc2, nqc3, nat, dyn, q, tau, lpolar, epsil, zeu, Qmat, signe)
     !-----------------------------------------------------------------------
     !! This is adapted from QE PH/rigid.f90
     !!
@@ -135,18 +135,19 @@
     !! SP: 11/2019 - Addition of system_2d (we assume z is the vacuum direction).
     !! SP: 08/2020 - Restoration of nrx and parallelization.
     !! SP: 04/2021 - Addition of quadrupoles
+    !! SP: 05/2021 - Addition of out-of-plane 2d electrostatic with L
     !!
     USE kinds,         ONLY : DP
-    USE constants_epw, ONLY : pi, fpi, e2
+    USE constants_epw, ONLY : pi, fpi, e2, twopi
     USE cell_base,     ONLY : bg, omega, alat
     USE constants_epw, ONLY : eps6, ci, zero, czero, twopi, eps8
-    USE io_global,     ONLY : ionode_id
+    USE io_global,     ONLY : ionode_id, stdout
     USE mp_world,      ONLY : mpime
     USE mp_global,     ONLY : world_comm
     USE division,      ONLY : para_bounds
     USE mp,            ONLY : mp_bcast, mp_sum
-    USE epwcom,        ONLY : lpolar, system_2d
-    USE elph2,         ONLY : area, Qmat
+    USE epwcom,        ONLY : system_2d, L, perp
+    USE elph2,         ONLY : area
     !
     IMPLICIT NONE
     !
@@ -160,10 +161,14 @@
     !! Number of atoms
     REAL(KIND = DP), INTENT(in) :: q(3)
     !! q-vector from the full coarse or fine grid.
+    LOGICAL, INTENT(in) :: lpolar
+    !! if .TRUE. enable the correct Wannier interpolation in the case of polar material
     REAL(KIND = DP), INTENT(in) :: epsil(3, 3)
     !! dielectric constant tensor
     REAL(KIND = DP), INTENT(inout) :: zeu(3, 3, nat)
     !! effective charges tensor
+    REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+    !! Quadrupole tensor
     REAL(KIND = DP), INTENT(in) :: signe
     !! signe=+/-1.0 ==> add/subtract rigid-ion term
     REAL(KIND = DP), INTENT(in) :: tau(3, nat)
@@ -172,6 +177,8 @@
     !! Dynamical matrix
     !
     ! Local variables
+    LOGICAL :: criteria
+    !! Criteria to neglect components
     INTEGER :: na
     !! Atom index 1
     INTEGER :: nb
@@ -222,6 +229,34 @@
     !! Q * G
     REAL(KIND = DP) :: c
     !! vacuum size (supercell length along the z direction) in case of 2D
+    REAL(KIND = DP) :: f
+    !! Envelope function
+    REAL(KIND = DP) :: qnorm
+    !! Norm of (G+q)
+    REAL(KIND = DP) :: alpha_para
+    !! Polarizability in plane
+    REAL(KIND = DP) :: alpha_perp
+    !! Polarizability out of plane
+    REAL(KIND = DP) :: epsilon_para
+    !! Dielectic function in plane
+    REAL(KIND = DP) :: epsilon_perp
+    !! Dielectric function out of plane
+    COMPLEX(KIND = DP) :: zag_para(3)
+    !! Z * G in-plane
+    COMPLEX(KIND = DP) :: zag_perp(3)
+    !! Z * G out of plane
+    COMPLEX(KIND = DP) :: zbg_para(3)
+    !! Z * G in-plane
+    COMPLEX(KIND = DP) :: zbg_perp(3)
+    !! Z * G out of plane
+    COMPLEX(KIND = DP) :: zcg_para(3)
+    !! Z * G in-plane
+    COMPLEX(KIND = DP) :: zcg_perp(3)
+    !! Z * G out of plane
+    COMPLEX(KIND = DP) :: fnat_para(3)
+    !! Z * G * cos(arg) in plane
+    COMPLEX(KIND = DP) :: fnat_perp(3)
+    !! Z * G * cos(arg) out of plane
     COMPLEX(KIND = DP) :: fnat(3)
     !! Z with \delta_kk' summed
     COMPLEX(KIND = DP) :: qnat(3)
@@ -258,11 +293,23 @@
     !
     IF (ABS(ABS(signe) - 1.0) > eps6) CALL errore('rgd_blk', ' wrong value for signe ', 1)
     !
-    IF (system_2d) THEN
-      ! Vacuum size in Bohr unit
-      c = alat / bg(3, 3)
+    ! Vacuum size in Bohr unit
+    c = alat / bg(3, 3)
+    qnorm = SQRT(q(1)**2 + q(2)**2 + q(3)**2)
+    IF (system_2d .AND. L > 0.001 .AND. qnorm < 0.00001) THEN
+      WRITE(stdout, *) '     In-plane polarizability in cartesian axis'
+      WRITE(stdout, *) '     ', (epsil(1, 1) - 1.0) * c / fpi, '  ',epsil(1, 2) * c / fpi
+      WRITE(stdout, *) '     ', epsil(2, 1) * c / fpi, '  ',(epsil(2, 2) - 1.0) * c / fpi
+      WRITE(stdout, *) '     Out-of-plane polarizability in cartesian axis ',&
+                                (epsil(3, 3) - 1.0) * c / fpi
+      WRITE(stdout, *) ' '
+      !
+      ! (e^2 * 2\pi) / Area
+      fac = (signe * e2 * twopi) * (c / omega)
+      !
+    ELSEIF (system_2d) THEN
       ! (e^2 * 2\pi) / Area
-      fac = (signe * e2 * twopi) / area
+      fac = (signe * e2 * twopi) * (c / omega)
       ! Effective screening length
       ! reff = (epsil - 1) * c/2
       reff(:, :) = zero
@@ -330,85 +377,162 @@
       gg(2) = (m1 * bg(2, 1) + m2 * bg(2, 2) + m3 * bg(2,3)) * (twopi / alat)
       gg(3) = (m1 * bg(3, 1) + m2 * bg(3, 2) + m3 * bg(3,3)) * (twopi / alat)
       !
-      IF (system_2d) THEN
+      IF (system_2d .AND. L > 0.001) THEN
+        geg = gg(1)**2 + gg(2)**2
+        qnorm = SQRT(geg)
+        f = 1.0 - TANH(qnorm * L * 0.5)
+        alpha_para = (gg(1) * (gg(1) * (epsil(1, 1) - 1.0) + gg(2) * epsil(2, 1)) + &
+                      gg(2) * (gg(1) * epsil(1, 2) + gg(2) * (epsil(2, 2) - 1.0))) * c / fpi
+        alpha_perp = (epsil(3, 3) - 1.0) * c / fpi
+        criteria = geg > zero
+        IF (criteria) THEN
+          epsilon_para = 1.0 + twopi * f *  alpha_para / qnorm
+          epsilon_perp = 1.0 - twopi * qnorm * f * alpha_perp
+        ENDIF
+      ELSEIF (system_2d) THEN
         geg = gg(1)**2 + gg(2)**2 + gg(3)**2
         grg = zero
         IF (gg(1)**2 + gg(2)**2 > eps8) THEN
           grg = gg(1) * reff(1, 1) * gg(1) + gg(1) * reff(1, 2) * gg(2) + gg(2) * reff(2, 1) * gg(1) + gg(2) * reff(2, 2) * gg(2)
           grg = grg / (gg(1)**2 + gg(2)**2)
         ENDIF
+        criteria = geg > 0.0d0 .AND. geg / (metric * alph * 4.0d0) < gmax
       ELSE
-        !
         geg = (gg(1) * (epsil(1, 1) * gg(1) + epsil(1, 2) * gg(2) + epsil(1, 3) * gg(3)) + &
                gg(2) * (epsil(2, 1) * gg(1) + epsil(2, 2) * gg(2) + epsil(2, 3) * gg(3)) + &
                gg(3) * (epsil(3, 1) * gg(1) + epsil(3, 2) * gg(2) + epsil(3, 3) * gg(3)))
+        criteria = geg > 0.0d0 .AND. geg / (metric * alph * 4.0d0) < gmax
       ENDIF
       !
-      IF (geg > 0.0d0 .AND. geg / (metric * alph * 4.0d0) < gmax) THEN
+      IF (criteria) THEN
         !
-        IF (system_2d) THEN
-          facgd = fac * EXP(-geg / (metric * alph * 4.0d0)) / SQRT(geg) / (1.0 + grg * SQRT(geg))
+        IF (system_2d .AND. L > 0.001) THEN
+          facgd = fac * f / qnorm
+        ELSEIF (system_2d) THEN
+          facgd = fac * EXP(-geg / (metric * alph * 4.0d0)) / (SQRT(geg) * (1.0 + grg * SQRT(geg)))
         ELSE
           facgd = fac * EXP(-geg / (metric * alph * 4.0d0)) / geg
         ENDIF
         !
-        DO na = 1, nat
-          zag(:) = zero
-          DO i = 1, 3
-            DO ipol = 1, 3
-              zag(i) = zag(i) + gg(ipol) * zeu(ipol, i, na)
-            ENDDO
-          ENDDO
-          !
-          qag(:) = zero
-          DO i = 1, 3
-            DO ipol = 1, 3
-              DO jpol = 1, 3
-                qag(i) = qag(i) + gg(ipol) * gg(jpol) * Qmat(na, i, ipol, jpol)
+        IF (system_2d .AND. L > 0.001) THEN
+          DO na = 1, nat
+            zag_para(:) = zero
+            zag_perp(:) = zero
+            DO i = 1, 3
+              ! Dipole
+              DO ipol = 1, 2
+                zag_para(i) = zag_para(i) + gg(ipol) * zeu(ipol, i, na)
+              ENDDO
+              zag_perp(i) = qnorm * zeu(3, i, na)
+              !
+              ! quadrupole
+              DO ipol = 1, 2
+                DO jpol = 1, 2
+                  zag_para(i) = zag_para(i) - 0.5 * ci *  gg(ipol) * gg(jpol) * Qmat(na, i, ipol, jpol)
+                ENDDO
+              ENDDO
+              zag_para(i) = zag_para(i) + 0.5 * ci * Qmat(na, i, 3, 3) * qnorm * qnorm
+              DO ipol = 1, 2
+                zag_perp(i) = zag_perp(i) - ci * qnorm * gg(ipol) * Qmat(na, i, 3, ipol)
               ENDDO
             ENDDO
-          ENDDO
-          !
-          fnat(:) = zero
-          qnat(:) = zero
-          DO nb = 1, nat
-            arg = alat * (gg(1) * (tau(1, na) - tau(1, nb)) + &
-                          gg(2) * (tau(2, na) - tau(2, nb)) + &
-                          gg(3) * (tau(3, na) - tau(3, nb)))
-            ! Dipole-dipole
-            zcg(:) = zero
-            DO j = 1, 3 ! Cartesian direction alpha
-              DO jpol = 1, 3 !
-                zcg(j) = zcg(j) + gg(jpol) * zeu(jpol, j, nb)
+            fnat_para(:) = czero
+            fnat_perp(:) = czero
+            DO nb = 1, nat
+              ! alat is needed to express tau in Bohr
+              arg = alat * (gg(1) * (tau(1, na) - tau(1, nb)) + &
+                            gg(2) * (tau(2, na) - tau(2, nb)))
+              zcg_para(:) = czero
+              zcg_perp(:) = czero
+              DO i = 1, 3
+                ! Dipole
+                DO ipol = 1, 2
+                  zcg_para(i) = zcg_para(i) + gg(ipol) * zeu(ipol, i, nb)
+                ENDDO
+                zcg_perp(i) = qnorm * zeu(3, i, nb)
+                !
+                ! quadrupole
+                DO ipol = 1, 2
+                  DO jpol = 1, 2
+                    zcg_para(i) = zcg_para(i) - 0.5 * ci * gg(ipol) * gg(jpol) * Qmat(nb, i, ipol, jpol)
+                  ENDDO
+                ENDDO
+                zcg_para(i) = zcg_para(i) + 0.5 * ci * Qmat(nb, i, 3, 3) * qnorm * qnorm
+                DO ipol = 1, 2
+                  zcg_perp(i) = zcg_perp(i) - ci * qnorm * gg(ipol) * Qmat(nb, i, 3, ipol)
+                ENDDO
+              ENDDO ! i
+              fnat_para(:) = fnat_para(:) + zcg_para(:) * CMPLX(COS(arg), SIN(arg), KIND=DP)
+              fnat_perp(:) = fnat_perp(:) + zcg_perp(:) * CMPLX(COS(arg), SIN(arg), KIND=DP)
+            ENDDO !nb
+            DO j = 1, 3
+              DO i = 1, 3
+                dyn_tmp((na - 1) * 3 + i, (na - 1) * 3 + j) = dyn_tmp((na - 1) * 3 + i, (na - 1) * 3 + j) - facgd * &
+                   (CONJG(zag_para(i)) * fnat_para(j)) / epsilon_para
+                IF (perp) dyn_tmp((na - 1) * 3 + i, (na - 1) * 3 + j) = dyn_tmp((na - 1) * 3 + i, (na - 1) * 3 + j) + facgd * &
+                   (CONJG(zag_perp(i)) * fnat_perp(j)) / epsilon_perp
+              ENDDO ! i
+            ENDDO ! j
+          ENDDO ! nat
+        ELSE
+          DO na = 1, nat
+            zag(:) = zero
+            DO i = 1, 3
+              DO ipol = 1, 3
+                zag(i) = zag(i) + gg(ipol) * zeu(ipol, i, na)
               ENDDO
-              fnat(j) = fnat(j) + zcg(j) * CMPLX(COS(arg), SIN(arg), KIND = DP)
             ENDDO
             !
-            qcg(:) = zero
-            DO j = 1, 3 ! Cartesian direction alpha
-              DO jpol = 1, 3
-                DO kpol = 1, 3
-                  qcg(j) = qcg(j) + gg(jpol) * gg(kpol) *  Qmat(nb, j, jpol, kpol)
+            qag(:) = zero
+            DO i = 1, 3
+              DO ipol = 1, 3
+                DO jpol = 1, 3
+                  qag(i) = qag(i) + gg(ipol) * gg(jpol) * Qmat(na, i, ipol, jpol)
                 ENDDO
               ENDDO
-              qnat(j) = qnat(j) + qcg(j) * CMPLX(COS(arg), SIN(arg), KIND = DP)
             ENDDO
             !
-          ENDDO ! nb
-          DO j = 1, 3
-            DO i = 1, 3
+            fnat(:) = zero
+            qnat(:) = zero
+            DO nb = 1, nat
+              arg = alat * (gg(1) * (tau(1, na) - tau(1, nb)) + &
+                            gg(2) * (tau(2, na) - tau(2, nb)) + &
+                            gg(3) * (tau(3, na) - tau(3, nb)))
               ! Dipole-dipole
-              Qdd = zag(i) * fnat(j)
-              ! Dipole-quad
-              Qdq = 0.5d0 * (zag(i) * qnat(j) - fnat(i) * qag(i))
-              ! Quad-quad
-              Qqq = 0.25d0 * qag(i) * qnat(j)
+              zcg(:) = zero
+              DO j = 1, 3 ! Cartesian direction alpha
+                DO jpol = 1, 3 !
+                  zcg(j) = zcg(j) + gg(jpol) * zeu(jpol, j, nb)
+                ENDDO
+                fnat(j) = fnat(j) + zcg(j) * CMPLX(COS(arg), SIN(arg), KIND = DP)
+              ENDDO
               !
-              dyn_tmp((na - 1) * 3 + i, (na - 1) * 3 + j) = dyn_tmp((na - 1) * 3 + i, (na - 1) * 3 + j) &
-                                           - facgd * (Qdd + ci * Qdq + Qqq)
-            ENDDO ! i
-          ENDDO ! j
-        ENDDO ! nat
+              qcg(:) = zero
+              DO j = 1, 3 ! Cartesian direction alpha
+                DO jpol = 1, 3
+                  DO kpol = 1, 3
+                    qcg(j) = qcg(j) + gg(jpol) * gg(kpol) *  Qmat(nb, j, jpol, kpol)
+                  ENDDO
+                ENDDO
+                qnat(j) = qnat(j) + qcg(j) * CMPLX(COS(arg), SIN(arg), KIND = DP)
+              ENDDO
+              !
+            ENDDO ! nb
+            DO j = 1, 3
+              DO i = 1, 3
+                ! Dipole-dipole
+                Qdd = zag(i) * fnat(j)
+                ! Dipole-quadrupole
+                Qdq = 0.5d0 * (zag(i) * qnat(j) - fnat(i) * qag(i))
+                ! Quadrupole-quadrupole
+                Qqq = 0.25d0 * qag(i) * qnat(j)
+                !
+                dyn_tmp((na - 1) * 3 + i, (na - 1) * 3 + j) = dyn_tmp((na - 1) * 3 + i, (na - 1) * 3 + j) &
+                                             - facgd * (Qdd + ci * Qdq + Qqq)
+              ENDDO ! i
+            ENDDO ! j
+          ENDDO ! nat
+        ENDIF ! system_2d .AND. L > 0.001
       ENDIF ! geg
       !
       ! Case q =/ 0
@@ -416,76 +540,156 @@
       gg(2) = gg(2) + q(2) * (twopi / alat)
       gg(3) = gg(3) + q(3) * (twopi / alat)
       !
-      IF (system_2d) THEN
+      IF (system_2d .AND. L > 0.001) THEN
+        geg = gg(1)**2 + gg(2)**2
+        qnorm = SQRT(geg)
+        f = 1.0 - TANH(qnorm * L * 0.5)
+        alpha_para = (gg(1) * (gg(1) * (epsil(1, 1) - 1.0) + gg(2) * epsil(2, 1))  + &
+                      gg(2) * (gg(1) * epsil(1, 2) + gg(2) * (epsil(2, 2) - 1.0))) * c / fpi
+        alpha_perp = (epsil(3, 3) - 1.0) * c / fpi
+        criteria = geg > zero
+        IF (criteria) THEN
+          epsilon_para = 1.0 + twopi * f *  alpha_para / qnorm
+          epsilon_perp = 1.0 - twopi * qnorm * f * alpha_perp
+        ENDIF
+      ELSEIF (system_2d) THEN
         geg = gg(1)**2 + gg(2)**2 + gg(3)**2
         grg = zero
         IF (gg(1)**2 + gg(2)**2 > eps8) THEN
           grg = gg(1) * reff(1, 1) * gg(1) + gg(1) * reff(1, 2) * gg(2) + gg(2) * reff(2, 1) * gg(1) + gg(2) * reff(2, 2) * gg(2)
           grg = grg / (gg(1)**2 + gg(2)**2)
         ENDIF
+        criteria = geg > zero .AND. geg / (metric * alph * 4.0d0) < gmax
       ELSE
         geg = (gg(1) * (epsil(1, 1) * gg(1) + epsil(1, 2) * gg(2) + epsil(1, 3) * gg(3)) + &
                gg(2) * (epsil(2, 1) * gg(1) + epsil(2, 2) * gg(2) + epsil(2, 3) * gg(3)) + &
                gg(3) * (epsil(3, 1) * gg(1) + epsil(3, 2) * gg(2) + epsil(3, 3) * gg(3)))
+        criteria = geg > zero .AND. geg / (metric * alph * 4.0d0) < gmax
       ENDIF
       !
-      IF (geg > 0.0d0 .AND. geg / (metric * alph * 4.0d0) < gmax) THEN
+      IF (criteria) THEN
         !
-        IF (system_2d) THEN
+        IF (system_2d .AND. L > 0.001) THEN
+          facgd = fac * f / qnorm
+        ELSEIF (system_2d) THEN
           facgd = fac * EXP(-geg / (metric * alph * 4.0d0)) / (SQRT(geg) * (1.0 + grg * SQRT(geg)))
         ELSE
           facgd = fac * EXP(-geg / (metric * alph * 4.0d0)) / geg
         ENDIF
         !
-        DO nb = 1, nat ! kappa
-          DO na = 1, nat ! kappa'
-            arg = alat * (gg(1) * (tau(1, na) - tau(1 ,nb)) + &
-                          gg(2) * (tau(2, na) - tau(2, nb)) + &
-                          gg(3) * (tau(3, na) - tau(3, nb)) )
-            !
-            facg = facgd * CMPLX(COS(arg), SIN(arg), DP)
+        IF (system_2d .AND. L > 0.001) THEN
+          DO nb = 1, nat
+            zbg_para(:) = czero
+            zbg_perp(:) = czero
+            DO i = 1, 3
+              ! Dipole
+              DO ipol = 1, 2
+                zbg_para(i) = zbg_para(i) + gg(ipol) * zeu(ipol, i, nb)
+              ENDDO
+              zbg_perp(i) = qnorm * zeu(3, i, nb)
+              !
+              ! Quadrupole
+              DO ipol = 1, 2
+                DO jpol = 1, 2
+                  zbg_para(i) = zbg_para(i) - 0.5 * ci *  gg(ipol) * gg(jpol) * Qmat(nb, i, ipol, jpol)
+                ENDDO
+              ENDDO
+              zbg_para(i) = zbg_para(i) + 0.5 * ci * Qmat(nb, i, 3, 3) * qnorm * qnorm
+              !
+              DO ipol = 1, 2
+                zbg_perp(i) = zbg_perp(i) - ci * qnorm * gg(ipol) * Qmat(nb, i, 3, ipol)
+              ENDDO
+            ENDDO ! i
             !
-            DO j = 1, 3 ! Cartesian direction alpha
-              DO i = 1, 3 ! Carestian direction beta
-                ! Dipole - dipole term
-                Qdd = zero
-                DO ipol = 1, 3
-                  DO jpol = 1, 3
-                    Qdd = Qdd + gg(ipol) * zeu(ipol, j, nb) * gg(jpol) * zeu(jpol, i, na)
-                  ENDDO
+            DO na = 1, nat
+              ! alat is needed to express tau in Bohr unit
+              arg = alat * (gg(1) * (tau(1, na) - tau(1, nb)) + &
+                            gg(2) * (tau(2, na) - tau(2, nb)))
+              zag_para(:) = czero
+              zag_perp(:) = czero
+              DO i = 1, 3
+                ! Dipole
+                DO ipol = 1, 2
+                  zag_para(i) = zag_para(i) + gg(ipol) * zeu(ipol, i, na)
                 ENDDO
+                zag_perp(i) = qnorm * zeu(3, i, na)
                 !
-                ! Dipole - quadrupole term
-                Qdq = zero
-                DO ipol = 1, 3
-                  DO jpol = 1, 3
-                    DO kpol = 1, 3
-                      Qdq = Qdq + 0.5 * (gg(ipol) * zeu(ipol, j, nb) * gg(jpol) * gg(kpol) * Qmat(na, i, jpol, kpol) &
-                                       - gg(ipol) * gg(jpol) * Qmat(nb, j, ipol, jpol) * gg(kpol) * zeu(kpol, i, na))
-                    ENDDO
+                ! Quadrupole
+                DO ipol = 1, 2
+                  DO jpol = 1, 2
+                    zag_para(i) = zag_para(i) - 0.5 * ci * gg(ipol) * gg(jpol) * Qmat(na, i, ipol, jpol)
                   ENDDO
                 ENDDO
+                zag_para(i) = zag_para(i) + 0.5 * ci * Qmat(na, i, 3, 3) * qnorm * qnorm
                 !
-                ! Quadrupole - quadrupole term
-                Qqq = zero
-                DO ipol = 1, 3
-                  DO jpol = 1, 3
-                    DO kpol = 1, 3
-                      DO lpol = 1, 3
-                        Qqq = Qqq + 0.25 *  gg(ipol) * gg(jpol) * Qmat(nb, j, ipol, jpol) * &
-                                            gg(kpol) * gg(lpol) * Qmat(na, i, kpol, lpol)
+                DO ipol = 1, 2
+                  zag_perp(i) = zag_perp(i) - ci * qnorm * gg(ipol) * Qmat(na, i, 3, ipol)
+                ENDDO
+              ENDDO ! i
+              !
+              facg = facgd * CMPLX(COS(arg), SIN(arg), KIND=DP)
+              DO j = 1, 3
+                DO i = 1, 3
+                  dyn_tmp((na - 1) * 3 + i, (nb - 1) * 3 + j) = dyn_tmp((na - 1) * 3 + i, (nb - 1) * 3 + j) + facg * &
+                     (CONJG(zag_para(i)) * zbg_para(j)) / epsilon_para
+                  IF (perp) dyn_tmp((na - 1) * 3 + i, (nb - 1) * 3 + j) = dyn_tmp((na - 1) * 3 + i, (nb - 1) * 3 + j) - facg * &
+                     (CONJG(zag_perp(i)) * zbg_perp(j)) / epsilon_perp
+                ENDDO ! i
+              ENDDO ! j
+            ENDDO ! na
+          ENDDO ! nb
+        ELSE ! system_2d .AND. L > 0.001
+          !
+          DO nb = 1, nat ! kappa
+            DO na = 1, nat ! kappa'
+              arg = alat * (gg(1) * (tau(1, na) - tau(1 ,nb)) + &
+                            gg(2) * (tau(2, na) - tau(2, nb)) + &
+                            gg(3) * (tau(3, na) - tau(3, nb)))
+              !
+              facg = facgd * CMPLX(COS(arg), SIN(arg), DP)
+              !
+              DO j = 1, 3 ! Cartesian direction alpha
+                DO i = 1, 3 ! Carestian direction beta
+                  ! Dipole - dipole term
+                  Qdd = zero
+                  DO ipol = 1, 3
+                    DO jpol = 1, 3
+                      Qdd = Qdd + gg(ipol) * zeu(ipol, j, nb) * gg(jpol) * zeu(jpol, i, na)
+                    ENDDO
+                  ENDDO
+                  !
+                  ! Dipole - quadrupole term
+                  Qdq = zero
+                  DO ipol = 1, 3
+                    DO jpol = 1, 3
+                      DO kpol = 1, 3
+                        Qdq = Qdq + 0.5 * (gg(ipol) * zeu(ipol, j, nb) * gg(jpol) * gg(kpol) * Qmat(na, i, jpol, kpol) &
+                                         - gg(ipol) * gg(jpol) * Qmat(nb, j, ipol, jpol) * gg(kpol) * zeu(kpol, i, na))
                       ENDDO
                     ENDDO
                   ENDDO
-                ENDDO
-                !
-                dyn_tmp((na - 1) * 3 + i, (nb - 1) * 3 + j) = dyn_tmp((na - 1) * 3 + i, (nb - 1) * 3 + j) &
-                                             + facg * (Qdd + ci * Qdq + Qqq)
-              ENDDO ! i
-            ENDDO ! j
-          ENDDO ! na
-        ENDDO ! nb
-      ENDIF
+                  !
+                  ! Quadrupole - quadrupole term
+                  Qqq = zero
+                  DO ipol = 1, 3
+                    DO jpol = 1, 3
+                      DO kpol = 1, 3
+                        DO lpol = 1, 3
+                          Qqq = Qqq + 0.25 *  gg(ipol) * gg(jpol) * Qmat(nb, j, ipol, jpol) * &
+                                              gg(kpol) * gg(lpol) * Qmat(na, i, kpol, lpol)
+                        ENDDO
+                      ENDDO
+                    ENDDO
+                  ENDDO
+                  !
+                  dyn_tmp((na - 1) * 3 + i, (nb - 1) * 3 + j) = dyn_tmp((na - 1) * 3 + i, (nb - 1) * 3 + j) &
+                                               + facg * (Qdd + ci * Qdq + Qqq)
+                ENDDO ! i
+              ENDDO ! j
+            ENDDO ! na
+          ENDDO ! nb
+        ENDIF ! system_2d .AND. L > 0.001
+      ENDIF ! criteria
     ENDDO ! mm
     !
     CALL mp_sum(dyn_tmp, world_comm)
@@ -496,7 +700,7 @@
     !-------------------------------------------------------------------------------
     !
     !-------------------------------------------------------------------------------
-    SUBROUTINE rgd_blk_epw(nqc1, nqc2, nqc3, q, uq, epmat, nmodes, epsil, zeu, bmat, signe)
+    SUBROUTINE rgd_blk_epw(nqc1, nqc2, nqc3, q, uq, epmat, nmodes, lpolar, epsil, zeu, Qmat, bmat, signe)
     !-------------------------------------------------------------------------------
     !!
     !! Compute the long range term for the e-ph vertex
@@ -526,8 +730,8 @@
     USE cell_base,     ONLY : bg, omega, alat
     USE ions_base,     ONLY : tau, nat
     USE constants_epw, ONLY : twopi, fpi, e2, ci, czero, eps12, zero, eps8
-    USE epwcom,        ONLY : shortrange, lpolar, system_2d
-    USE elph2,         ONLY : area, Qmat
+    USE epwcom,        ONLY : shortrange, system_2d, L
+    USE elph2,         ONLY : area
     USE io_global,     ONLY : stdout
     !
     IMPLICIT NONE
@@ -542,10 +746,14 @@
     !! Max number of modes
     REAL(KIND = DP), INTENT(in) :: q(3)
     !! q-vector from the full coarse or fine grid.
+    LOGICAL, INTENT(in) :: lpolar
+    !! if .TRUE. enable the correct Wannier interpolation in the case of polar material
     REAL(KIND = DP), INTENT(in) :: epsil(3, 3)
     !! dielectric constant tensor
     REAL(KIND = DP), INTENT(inout) :: zeu(3, 3, nat)
     !! effective charges tensor
+    REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+    !! Quadrupole tensor
     REAL(KIND = DP), INTENT(in) :: signe
     !! signe=+/-1.0 ==> add/subtract long range term
     COMPLEX(KIND = DP), INTENT(in) :: uq(nmodes, nmodes)
@@ -556,6 +764,8 @@
     !! Overlap matrix elements $$<U_{mk+q}|U_{nk}>$$
     !
     ! Local variables
+    LOGICAL :: criteria
+    !! Criteria to neglect components
     INTEGER :: na
     !! Atom index 1
     INTEGER :: i
@@ -589,7 +799,17 @@
     REAL(KIND = DP) :: grg
     !! G-vector * reff * G-vector
     REAL(KIND = DP) :: c
-    !! vacuum size (supercell length along the z direction) in case of 2D
+    !! vacuum size (supercell length along the z direction)
+    REAL(KIND = DP) :: f
+    !! Envelope function
+    REAL(KIND = DP) :: qnorm
+    !! Norm of (G+q)
+    REAL(KIND = DP) :: alpha_para
+    !! Polarizability in plane
+    REAL(KIND = DP) :: epsilon_para
+    !! Dielectic function in plane
+    COMPLEX(KIND = DP) :: zbg_para(3)
+    !! Z * G in-plane
     COMPLEX(KIND = DP) :: fac
     !! General prefactor
     COMPLEX(KIND = DP) :: facqd
@@ -606,11 +826,14 @@
     !
     IF(ABS(ABS(signe) - 1.0) > eps12) CALL errore('rgd_blk_epw', 'Wrong value for signe ', 1)
     !
-    IF (system_2d) THEN
-      ! Vacuum size in Bohr unit
-      c = alat / bg(3, 3)
-      ! (e^2 * 2\pi * ci) / Area
-      fac = (signe * e2 * twopi * ci) / area
+    ! Vacuum size in Bohr unit
+    c = alat / bg(3, 3)
+    IF (system_2d .AND. L > 0.001) THEN
+      ! (e^2 * 2\pi * i) / Area
+      fac = (signe * e2 * twopi * ci) * (c / omega)
+    ELSEIF (system_2d) THEN
+      ! (e^2 * 2\pi * i) / Area
+      fac = (signe * e2 * twopi * ci) * (c / omega)
       ! Effective screening length
       ! reff = (epsil - 1) * c/2
       reff(:, :) = zero
@@ -653,7 +876,17 @@
           gg(2) = (m1 * bg(2, 1) + m2 * bg(2, 2) + m3 * bg(2, 3) + q(2)) * (twopi / alat)
           gg(3) = (m1 * bg(3, 1) + m2 * bg(3, 2) + m3 * bg(3, 3) + q(3)) * (twopi / alat)
           !
-          IF (system_2d) THEN
+          IF (system_2d .AND. L > 0.001) THEN
+            qeq = gg(1)**2 + gg(2)**2
+            qnorm = SQRT(qeq)
+            f = 1.0 - TANH(qnorm * L * 0.5)
+            alpha_para = (gg(1) * (gg(1) * (epsil(1, 1) - 1.0) + gg(2) * epsil(2, 1)) + &
+                          gg(2) * (gg(1) * epsil(1, 2) + gg(2) * (epsil(2, 2) - 1.0))) * c / fpi
+            criteria = qeq > zero
+            IF (criteria) THEN
+              epsilon_para = 1.0 + twopi * f *  alpha_para / qnorm
+            ENDIF
+          ELSEIF (system_2d) THEN
             qeq = gg(1)**2 + gg(2)**2 + gg(3)**2
             grg = zero
             IF (gg(1)**2 + gg(2)**2 > eps8) THEN
@@ -661,43 +894,74 @@
                     gg(2) * reff(2, 1) * gg(1) + gg(2) * reff(2, 2) * gg(2)
               grg = grg / (gg(1)**2 + gg(2)**2)
             ENDIF
+            criteria = qeq > 0.0d0 .AND. qeq / (metric * alph * 4.0d0) < gmax
           ELSE
             qeq = (gg(1) * (epsil(1, 1) * gg(1) + epsil(1, 2) * gg(2) + epsil(1, 3) * gg(3)) + &
                    gg(2) * (epsil(2, 1) * gg(1) + epsil(2, 2) * gg(2) + epsil(2, 3) * gg(3)) + &
                    gg(3) * (epsil(3, 1) * gg(1) + epsil(3, 2) * gg(2) + epsil(3, 3) * gg(3)))
+            criteria = qeq > 0.0d0 .AND. qeq / (metric * alph * 4.0d0) < gmax
           ENDIF
-          IF (qeq > 0.0d0 .AND. qeq / (metric * alph * 4.0d0) < gmax) THEN
+          !
+          IF (criteria) THEN
             !
-            IF (system_2d) THEN
+            IF (system_2d .AND. L > 0.001) THEN
+              facqd = fac * f / qnorm
+            ELSEIF (system_2d) THEN
               facqd = fac * EXP(-qeq / (metric * alph * 4.0d0)) / (SQRT(qeq) * (1.0 + grg * SQRT(qeq)))
             ELSE
               ! facqd = fac * EXP(-qeq / (metric * alph * 4.0d0)) / qeq  <-- this is correct
               facqd = fac * EXP(-qeq * DSQRT(metric) / (metric * alph * 4.0d0)) / qeq ! <-- this is to keep as previous
             ENDIF
             !
-            DO na = 1, nat
-              arg = - alat * (gg(1) * tau(1, na) + gg(2) * tau(2, na) + gg(3) * tau(3, na))
-              facq = facqd * CMPLX(COS(arg), SIN(arg), KIND = DP)
-              ! Cartesian direction
-              DO i = 1, 3
-                zaq = zero
-                DO ipol = 1, 3
-                  zaq = zaq + gg(ipol) * zeu(ipol, i, na)
-                ENDDO
-                !
-                Qqq = zero
-                DO ipol = 1, 3
-                  DO jpol = 1, 3
-                    Qqq = Qqq + 0.5 * gg(ipol) * gg(jpol) * Qmat(na, i, ipol, jpol)
+            IF (system_2d .AND. L > 0.001) THEN
+              DO na = 1, nat
+                arg = - alat * (gg(1) * tau(1, na) + gg(2) * tau(2, na))
+                facq = facqd * CMPLX(COS(arg), SIN(arg), KIND = DP)
+                zbg_para(:) = czero
+                DO i = 1, 3
+                  ! Dipole
+                  DO ipol = 1, 2
+                    zbg_para(i) = zbg_para(i) + gg(ipol) * zeu(ipol, i, na)
+                  ENDDO
+                  !
+                  ! Quadrupole
+                  DO ipol = 1, 2
+                    DO jpol = 1, 2
+                      zbg_para(i) = zbg_para(i) - 0.5 * ci *  gg(ipol) * gg(jpol) * Qmat(na, i, ipol, jpol)
+                    ENDDO
                   ENDDO
+                  zbg_para(i) = zbg_para(i) + 0.5 * ci * Qmat(na, i, 3, 3) * qnorm * qnorm
+                ENDDO ! i
+                DO i = 1, 3
+                  epmat = epmat + facq * (zbg_para(i) / epsilon_para) * uq(3 * (na - 1) + i, :) * bmat
+                  epmatl = epmatl + facq * (zbg_para(i) / epsilon_para) * uq(3 * (na - 1) + i, :) * bmat
                 ENDDO
-                !
-                epmat = epmat + facq * (zaq - ci * Qqq) * uq(3 * (na - 1) + i, :) * bmat
-                epmatl = epmatl + facq * (zaq - ci * Qqq) * uq(3 * (na - 1) + i, :) * bmat
-                !
-              ENDDO !ipol
-            ENDDO !nat
-          ENDIF
+              ENDDO ! na
+            ELSE
+              DO na = 1, nat
+                arg = - alat * (gg(1) * tau(1, na) + gg(2) * tau(2, na) + gg(3) * tau(3, na))
+                facq = facqd * CMPLX(COS(arg), SIN(arg), KIND = DP)
+                ! Cartesian direction
+                DO i = 1, 3
+                  zaq = zero
+                  DO ipol = 1, 3
+                    zaq = zaq + gg(ipol) * zeu(ipol, i, na)
+                  ENDDO
+                  !
+                  Qqq = zero
+                  DO ipol = 1, 3
+                    DO jpol = 1, 3
+                      Qqq = Qqq + 0.5 * gg(ipol) * gg(jpol) * Qmat(na, i, ipol, jpol)
+                    ENDDO
+                  ENDDO
+                  !
+                  epmat = epmat + facq * (zaq - ci * Qqq) * uq(3 * (na - 1) + i, :) * bmat
+                  epmatl = epmatl + facq * (zaq - ci * Qqq) * uq(3 * (na - 1) + i, :) * bmat
+                  !
+                ENDDO !ipol
+              ENDDO !nat
+            ENDIF ! system_2d
+          ENDIF ! criteria
           !
         ENDDO ! m3
       ENDDO ! m2
@@ -720,7 +984,7 @@
     !-------------------------------------------------------------------------------
     !
     !-------------------------------------------------------------------------------
-    SUBROUTINE rgd_blk_epw_fine(nqc1, nqc2, nqc3, q, uq, epmat, nmodes, epsil, zeu, bmat, signe)
+    SUBROUTINE rgd_blk_epw_fine(nqc1, nqc2, nqc3, q, uq, epmat, nmodes, lpolar, epsil, zeu, Qmat, bmat, signe)
     !-------------------------------------------------------------------------------
     !!
     !! Compute the long range term for the e-ph vertex
@@ -751,8 +1015,8 @@
     USE cell_base,     ONLY : bg, omega, alat
     USE ions_base,     ONLY : tau, nat
     USE constants_epw, ONLY : twopi, fpi, e2, ci, czero, eps12, zero, eps8
-    USE epwcom,        ONLY : shortrange, nbndsub, lpolar, system_2d
-    USE elph2,         ONLY : area, Qmat
+    USE epwcom,        ONLY : shortrange, nbndsub, system_2d, L
+    USE elph2,         ONLY : area
     !
     IMPLICIT NONE
     !
@@ -766,10 +1030,14 @@
     !! Max number of modes
     REAL (KIND = DP), INTENT(in) :: q(3)
     !! q-vector from the full coarse or fine grid.
+    LOGICAL, INTENT(in) :: lpolar
+    !! if .TRUE. enable the correct Wannier interpolation in the case of polar material
     REAL (KIND = DP), INTENT(in) :: epsil(3, 3)
     !! dielectric constant tensor
     REAL (KIND = DP), INTENT(inout) :: zeu(3, 3, nat)
     !! effective charges tensor
+    REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+    !! Quadrupole tensor
     REAL (KIND = DP), INTENT(in) :: signe
     !! signe=+/-1.0 ==> add/subtract long range term
     COMPLEX (KIND = DP), INTENT(in) :: uq(nmodes, nmodes)
@@ -780,6 +1048,8 @@
     !! Overlap matrix elements $$<U_{mk+q}|U_{nk}>$$
     !
     ! Local variables
+    LOGICAL :: criteria
+    !! Criteria to neglect components
     INTEGER :: na
     !! Atom index 1
     INTEGER :: i
@@ -816,6 +1086,16 @@
     !! In the case of Si, its a single value
     REAL(KIND = DP) :: c
     !! vacuum size (supercell length along the z direction) in case of 2D
+    REAL(KIND = DP) :: f
+    !! Envelope function
+    REAL(KIND = DP) :: qnorm
+    !! Norm of (G+q)
+    REAL(KIND = DP) :: alpha_para
+    !! Polarizability in plane
+    REAL(KIND = DP) :: epsilon_para
+    !! Dielectic function in plane
+    COMPLEX(KIND = DP) :: zbg_para(3)
+    !! Z * G in-plane
     COMPLEX(KIND = DP) :: fac
     !! General prefactor
     COMPLEX(KIND = DP) :: facqd
@@ -832,11 +1112,14 @@
     !
     IF (ABS(ABS(signe) - 1.0) > eps12) CALL errore ('rgd_blk_epw_fine', 'Wrong value for signe ', 1)
     !
-    IF (system_2d) THEN
-      ! Vacuum size in Bohr unit
-      c = alat / bg(3, 3)
+    ! Vacuum size in Bohr unit
+    c = alat / bg(3, 3)
+    IF (system_2d .AND. L > 0.001) THEN
+      ! (e^2 * 2\pi * i) / Area
+      fac = (signe * e2 * twopi * ci) * (c / omega)
+    ELSEIF (system_2d) THEN
       ! (e^2 * 2\pi * ci) / Area
-      fac = (signe * e2 * twopi * ci) / area
+      fac = (signe * e2 * twopi * ci) * (c / omega)
       ! Effective screening length
       ! reff = (epsil - 1) * c/2
       reff(:, :) = zero
@@ -880,7 +1163,17 @@
           gg(2) = (m1 * bg(2, 1) + m2 * bg(2, 2) + m3 * bg(2, 3) + q(2)) * (twopi / alat)
           gg(3) = (m1 * bg(3, 1) + m2 * bg(3, 2) + m3 * bg(3, 3) + q(3)) * (twopi / alat)
           !
-          IF (system_2d) THEN
+          IF (system_2d .AND. L > 0.001) THEN
+            qeq = gg(1)**2 + gg(2)**2
+            qnorm = SQRT(qeq)
+            f = 1.0 - TANH(qnorm * L * 0.5)
+            alpha_para = (gg(1) * (gg(1) * (epsil(1, 1) - 1.0) + gg(2) * epsil(2, 1)) + &
+                          gg(2) * (gg(1) * epsil(1, 2) + gg(2) * (epsil(2, 2) - 1.0))) * c / fpi
+            criteria = qeq > zero
+            IF (criteria) THEN
+              epsilon_para = 1.0 + twopi * f *  alpha_para / qnorm
+            ENDIF
+          ELSEIF (system_2d) THEN
             qeq = gg(1)**2 + gg(2)**2 + gg(3)**2
             grg = zero
             IF (gg(1)**2 + gg(2)**2 > eps8) THEN
@@ -888,48 +1181,81 @@
                     gg(2) * reff(2, 1) * gg(1) + gg(2) * reff(2, 2) * gg(2)
               grg = grg / (gg(1)**2 + gg(2)**2)
             ENDIF
+            criteria = qeq > 0.0d0 .AND. qeq / (metric * alph * 4.0d0) < gmax
           ELSE
             !
             qeq = (gg(1) * (epsil(1, 1) * gg(1) + epsil(1, 2) * gg(2) + epsil(1, 3) * gg(3)) + &
                    gg(2) * (epsil(2, 1) * gg(1) + epsil(2, 2) * gg(2) + epsil(2, 3) * gg(3)) + &
                    gg(3) * (epsil(3, 1) * gg(1) + epsil(3, 2) * gg(2) + epsil(3, 3) * gg(3)))
+            criteria = qeq > 0.0d0 .AND. qeq / (metric * alph * 4.0d0) < gmax
           ENDIF
           !
-          IF (qeq > 0.0d0 .AND. qeq / (metric * alph * 4.0d0) < gmax) THEN
+          IF (criteria) THEN
             !
-            IF (system_2d) THEN
+            IF (system_2d .AND. L > 0.001) THEN
+              facqd = fac * f / qnorm
+            ELSEIF (system_2d) THEN
               facqd = fac * EXP(-qeq / (metric * alph * 4.0d0)) / (SQRT(qeq) * (1.0 + grg * SQRT(qeq)))
             ELSE
               ! facqd = fac * EXP(-qeq / (metric * alph * 4.0d0)) / qeq  <-- this is correct
               facqd = fac * EXP(-qeq * DSQRT(metric) / (metric * alph * 4.0d0)) / qeq ! <-- this is to keep as previous
             ENDIF
             !
-            DO na = 1, nat
-              arg = - alat * (gg(1) * tau(1, na) + gg(2) * tau(2, na) + gg(3) * tau(3, na))
-              facq = facqd * CMPLX(COS(arg), SIN(arg), KIND = DP)
-              ! Cartesian index direction
-              DO i = 1, 3
-                zaq = zero
-                DO ipol = 1, 3
-                  zaq = zaq + gg(ipol) * zeu(ipol, i, na)
-                ENDDO
-                !
-                Qqq = zero
-                DO ipol = 1, 3
-                  DO jpol = 1, 3
-                    Qqq = Qqq + 0.5 * gg(ipol) * gg(jpol) * Qmat(na, i, ipol, jpol)
+            IF (system_2d .AND. L > 0.001) THEN
+              DO na = 1, nat
+                arg = - alat * (gg(1) * tau(1, na) + gg(2) * tau(2, na))
+                facq = facqd * CMPLX(COS(arg), SIN(arg), KIND = DP)
+                zbg_para(:) = czero
+                DO i = 1, 3
+                  ! Dipole
+                  DO ipol = 1, 2
+                    zbg_para(i) = zbg_para(i) + gg(ipol) * zeu(ipol, i, na)
                   ENDDO
-                ENDDO
-                !
-                DO imode = 1, nmodes
-                  CALL ZAXPY(nbndsub**2, facq * (zaq - ci * Qqq) * uq(3 * (na - 1) + i, imode),&
-                              bmat(:, :), 1, epmat(:, :, imode), 1)
-                  CALL ZAXPY(nbndsub**2, facq * (zaq - ci * Qqq) * uq(3 * (na - 1) + i, imode), &
-                              bmat(:, :), 1, epmatl(:, :, imode), 1)
-                ENDDO
-                !
-              ENDDO !ipol
-            ENDDO !nat
+                  !
+                  ! Quadrupole
+                  DO ipol = 1, 2
+                    DO jpol = 1, 2
+                      zbg_para(i) = zbg_para(i) - 0.5 * ci *  gg(ipol) * gg(jpol) * Qmat(na, i, ipol, jpol)
+                    ENDDO
+                  ENDDO
+                  zbg_para(i) = zbg_para(i) + 0.5 * ci * Qmat(na, i, 3, 3) * qnorm * qnorm
+                  !
+                  DO imode = 1, nmodes
+                    CALL ZAXPY(nbndsub**2, facq * (zbg_para(i) / epsilon_para) * uq(3 * (na - 1) + i, imode), &
+                                bmat(:, :), 1, epmat(:, :, imode), 1)
+                    CALL ZAXPY(nbndsub**2, facq * (zbg_para(i) / epsilon_para) * uq(3 * (na - 1) + i, imode), &
+                                bmat(:, :), 1, epmatl(:, :, imode), 1)
+                  ENDDO
+                ENDDO ! i
+              ENDDO ! na
+            ELSE
+              DO na = 1, nat
+                arg = - alat * (gg(1) * tau(1, na) + gg(2) * tau(2, na) + gg(3) * tau(3, na))
+                facq = facqd * CMPLX(COS(arg), SIN(arg), KIND = DP)
+                ! Cartesian index direction
+                DO i = 1, 3
+                  zaq = zero
+                  DO ipol = 1, 3
+                    zaq = zaq + gg(ipol) * zeu(ipol, i, na)
+                  ENDDO
+                  !
+                  Qqq = zero
+                  DO ipol = 1, 3
+                    DO jpol = 1, 3
+                      Qqq = Qqq + 0.5 * gg(ipol) * gg(jpol) * Qmat(na, i, ipol, jpol)
+                    ENDDO
+                  ENDDO
+                  !
+                  DO imode = 1, nmodes
+                    CALL ZAXPY(nbndsub**2, facq * (zaq - ci * Qqq) * uq(3 * (na - 1) + i, imode),&
+                                bmat(:, :), 1, epmat(:, :, imode), 1)
+                    CALL ZAXPY(nbndsub**2, facq * (zaq - ci * Qqq) * uq(3 * (na - 1) + i, imode), &
+                                bmat(:, :), 1, epmatl(:, :, imode), 1)
+                  ENDDO
+                  !
+                ENDDO !ipol
+              ENDDO !nat
+            ENDIF !system_2d
           ENDIF
           !
         ENDDO ! m3
@@ -1196,7 +1522,7 @@
     !-----------------------------------------------------------------------
     !
     !-----------------------------------------------------------------------
-    SUBROUTINE rgd_blk_der(nqc1, nqc2, nqc3, nat, dyn_der, q, tau, epsil, zeu, signe)
+    SUBROUTINE rgd_blk_der(nqc1, nqc2, nqc3, nat, dyn_der, q, tau, epsil, zeu, Qmat, signe)
     !-----------------------------------------------------------------------
     !!
     !! Compute the rigid-ion (long-range) derivative term for q
@@ -1227,6 +1553,8 @@
     !! dielectric constant tensor
     REAL(KIND = DP), INTENT(in) :: zeu(3, 3, nat)
     !! effective charges tensor
+    REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+    !! Quadrupole tensor
     REAL(KIND = DP), INTENT(in) :: signe
     !! signe=+/-1.0 ==> add/subtract rigid-ion term
     REAL(KIND = DP), INTENT(in) :: tau(3, nat)
@@ -1371,7 +1699,7 @@
     !-------------------------------------------------------------------------------
     !
     !-------------------------------------------------------------------------------
-    SUBROUTINE rgd_blk_epw_fine_mem(imode, nqc1, nqc2, nqc3, q, uq, epmat, nmodes, epsil, zeu, bmat, signe)
+    SUBROUTINE rgd_blk_epw_fine_mem(imode, nqc1, nqc2, nqc3, q, uq, epmat, nmodes, lpolar, epsil, zeu, Qmat, bmat, signe)
     !-------------------------------------------------------------------------------
     !!
     !! Compute the long range term for the e-ph vertex
@@ -1400,8 +1728,8 @@
     USE cell_base,     ONLY : bg, omega, alat
     USE ions_base,     ONLY : tau, nat
     USE constants_epw, ONLY : twopi, fpi, e2, ci, czero, eps12, zero, eps8
-    USE epwcom,        ONLY : shortrange, nbndsub, lpolar, system_2d
-    USE elph2,         ONLY : area, Qmat
+    USE epwcom,        ONLY : shortrange, nbndsub, system_2d
+    USE elph2,         ONLY : area
     !
     IMPLICIT NONE
     !
@@ -1417,10 +1745,14 @@
     !! Max number of modes
     REAL(KIND = DP), INTENT(in) :: q(3)
     !! q-vector from the full coarse or fine grid.
+    LOGICAL, INTENT(in) :: lpolar
+    !! if .TRUE. enable the correct Wannier interpolation in the case of polar material
     REAL(KIND = DP), INTENT(in) :: epsil(3, 3)
     !! dielectric constant tensor
     REAL(KIND = DP), INTENT(inout) :: zeu(3, 3, nat)
     !! effective charges tensor
+    REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+    !! Quadrupole tensor
     REAL(KIND = DP), INTENT(in) :: signe
     !! signe=+/-1.0 ==> add/subtract long range term
     COMPLEX(KIND = DP), INTENT(in) :: uq(nmodes, nmodes)
diff --git a/EPW/src/rotate.f90 b/EPW/src/rotate.f90
index 570848ccd..48b7f311c 100644
--- a/EPW/src/rotate.f90
+++ b/EPW/src/rotate.f90
@@ -16,7 +16,7 @@
   CONTAINS
     !
     !--------------------------------------------------------------------------
-    SUBROUTINE rotate_eigenm(iq_first, nqc, isym, s, invs, irt, rtau, xq, cz1, cz2)
+    SUBROUTINE rotate_eigenm(dynq, iq_first, nqc, isym, s, invs, irt, rtau, xq, cz1, cz2)
     !--------------------------------------------------------------------------
     !!
     !!  Here:
@@ -50,8 +50,8 @@
     !--------------------------------------------------------------------------
     USE kinds,         ONLY : DP
     USE io_global,     ONLY : stdout
-    USE elph2,         ONLY : dynq
     USE modes,         ONLY : nmodes
+    USE epwcom,        ONLY : nqc1, nqc2, nqc3
     USE constants_epw, ONLY : cone, czero, twopi, rydcm1, eps10, cmm12meV
     USE control_flags, ONLY : iverbosity
     USE cell_base,     ONLY : at, bg
@@ -59,6 +59,8 @@
     !
     IMPLICIT NONE
     !
+    COMPLEX(KIND = DP) :: dynq(nmodes, nmodes, nqc1 * nqc2 * nqc3)
+    !! dynamical matrix for every q (nmode, nmodes, nqtot)
     INTEGER, INTENT(in) :: iq_first
     !! Originating q point of the star
     INTEGER, INTENT(in) :: nqc
@@ -297,7 +299,7 @@
     !--------------------------------------------------------------------------
     !
     !---------------------------------------------------------------------------
-    SUBROUTINE rotate_epmat(cz1, cz2, xq, iq, lwin, lwinq, exband)
+    SUBROUTINE rotate_epmat(epmatq, epmatq0, cz1, cz2, xq, iq, lwin, lwinq, exband, lpolar, qrpl, epsi, zstar, Qmat)
     !---------------------------------------------------------------------------
     !!
     !! 1). rotate the electron-phonon matrix from the cartesian representation
@@ -310,16 +312,22 @@
     !! SP - Sep. 2019: Cleaning.
     !--------------------------------------------------------------------------
     USE kinds,         ONLY : DP
-    USE elph2,         ONLY : epmatq, zstar, epsi, bmat, nbndep, qrpl
-    USE epwcom,        ONLY : lpolar, nqc1, nqc2, nqc3
+    USE elph2,         ONLY : bmat, nbndep
+    USE epwcom,        ONLY : nqc1, nqc2, nqc3
     USE modes,         ONLY : nmodes
     USE constants_epw, ONLY : cone, czero, one, ryd2mev, eps8
     USE pwcom,         ONLY : nbnd, nks
-    USE ions_base,     ONLY : amass, ityp
+    USE ions_base,     ONLY : amass, ityp, nat
     USE rigid_epw,     ONLY : rgd_blk_epw
     !
     IMPLICIT NONE
     !
+    COMPLEX(KIND = DP), INTENT(INOUT) :: &
+      epmatq(nbndep, nbndep, nks, nmodes, nqc1 * nqc2 * nqc3)
+    !! e-p matrix for every q (nbnd, nbnd, nks, nmodes, nqtot)
+    COMPLEX(KIND = DP), INTENT(OUT) :: &
+      epmatq0(nbndep, nbndep, nks, nmodes, nqc1 * nqc2 * nqc3)
+    !! e-p matrix for every q (nbnd, nbnd, nks, nmodes, nqtot) (including long-range part)
     LOGICAL, INTENT(in) :: lwin(nbndep, nks)
     !! Bands at k within outer energy window
     LOGICAL, INTENT(in) :: lwinq(nbndep, nks)
@@ -334,6 +342,16 @@
     !! eigenvectors for the first q in the star
     COMPLEX(KIND = DP), INTENT(inout) :: cz2(nmodes, nmodes)
     !!  Rotated eigenvectors for the current q in the star
+    LOGICAL, INTENT(in) :: lpolar
+    !! if .TRUE. enable the correct Wannier interpolation in the case of polar material
+    LOGICAL, INTENT(in) :: qrpl
+    !! If true use quadrupole during interpolation
+    REAL(KIND = DP), INTENT(in) :: epsi(3, 3)
+    !! dielectric constant tensor
+    REAL(KIND = DP), INTENT(inout) :: zstar(3, 3, nat)
+    !! effective charges tensor
+    REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+    !! Quadrupole tensor
     !
     ! Local variables
     INTEGER :: mu
@@ -415,11 +433,14 @@
           CALL ZGEMV('t', nmodes, nmodes, cone, cz1, nmodes,  &
                      epmatq_opt(ibnd, jbnd, ik, :), 1, czero, eptmp, 1)
           !
+          ! rotate epmat in the cartesian representation for this q in the star (including long-range part)
+          !
+          CALL ZGEMV('t', nmodes, nmodes, cone, cz2, nmodes, &
+                    eptmp, 1, czero, epmatq0(ibnd, jbnd, ik, :, iq), 1)
+          !
           IF (lpolar .OR. qrpl) THEN
-            IF ((ABS(xq(1)) > eps8) .OR. (ABS(xq(2)) > eps8) .OR. (ABS(xq(3)) > eps8)) THEN
-              CALL rgd_blk_epw(nqc1, nqc2, nqc3, xq, cz2t, eptmp, &
-                       nmodes, epsi, zstar, bmat(ibnd, jbnd, ik, iq), -one)
-            ENDIF
+            CALL rgd_blk_epw(nqc1, nqc2, nqc3, xq, cz2t, eptmp, &
+              nmodes, lpolar, epsi, zstar, Qmat, bmat(ibnd, jbnd, ik, iq), -one)
           ENDIF
           !
           ! rotate epmat in the cartesian representation for this q in the star
diff --git a/EPW/src/selfen.f90 b/EPW/src/selfen.f90
index aaea04cd8..fa96e5a3c 100644
--- a/EPW/src/selfen.f90
+++ b/EPW/src/selfen.f90
@@ -945,6 +945,635 @@
     !-----------------------------------------------------------------------
     !
     !-----------------------------------------------------------------------
+    SUBROUTINE unscreen_dynq(xq)
+    !-----------------------------------------------------------------------
+    !!
+    !! Renormalize dynamical matrix on coarse mesh.
+    !! See also Calandra, Profeta, and Mauri, PRB 82, 165111 (2010).
+    !!
+    !-----------------------------------------------------------------------
+    USE kinds,      ONLY : DP
+    USE cell_base,  ONLY : at, bg
+    USE constants_epw, ONLY : zero, czero, one, two, eps12
+    USE elph2,      ONLY : epmatq0, epmatqc0, dynq, dynqc, dynqr, dynqcr, nbndep, ibndstart
+    USE epwcom,     ONLY : cdfpt_min, cdfpt_max, efermi_read, fermi_energy, &
+                           nkc1, nkc2, nkc3, nqc1, nqc2, nqc3, temp_inf, type_inf, bare
+    USE klist,      ONLY : degauss, ngauss
+    USE klist_epw,  ONLY : et_all, et_loc, xk_loc
+    USE modes,      ONLY : nmodes
+    USE mp,         ONLY : mp_sum
+    USE mp_global,  ONLY : inter_pool_comm
+    USE pwcom,      ONLY : ef, nbnd, nelec, nks, nkstot, wk
+    !
+    IMPLICIT NONE
+    !
+    REAL(KIND = DP), INTENT(IN) :: xq(3, nqc1 * nqc2 * nqc3)
+    !! qpoint list, coarse mesh
+    !
+    INTEGER :: kmesh(3, nks), qmesh(3, nqc1 * nqc2 * nqc3), dummy(nkstot)
+    REAL(KIND = DP) :: emesh(nbnd, nkc3, nkc2, nkc1)
+    REAL(KIND = DP) :: ef_inf
+    REAL(KIND = DP), EXTERNAL :: efermig, wgauss, w0gauss
+    !
+    dummy = 0
+    !
+    CALL cryst_to_cart(nqc1 * nqc2 * nqc3, xq, at, -1)
+    CALL cryst_to_cart(nks, xk_loc, at, -1)
+    !
+    qmesh(1, :) = nint(xq(1, :) * nkc1)
+    qmesh(2, :) = nint(xq(2, :) * nkc2)
+    qmesh(3, :) = nint(xq(3, :) * nkc3)
+    !
+    kmesh(1, :) = nint(xk_loc(1, :) * nkc1)
+    kmesh(2, :) = nint(xk_loc(2, :) * nkc2)
+    kmesh(3, :) = nint(xk_loc(3, :) * nkc3)
+    !
+    CALL cryst_to_cart(nqc1 * nqc2 * nqc3, xq, bg, +1)
+    CALL cryst_to_cart(nks, xk_loc, bg, +1)
+    !
+    emesh = RESHAPE(et_all, SHAPE(emesh))
+    !
+    dynqr = dynq - pi(epmatq0, epmatq0, ef, degauss, ngauss)
+    !
+    IF (bare) dynqc = dynq - pi(epmatqc0, epmatq0, ef, degauss, ngauss)
+    !
+    IF (temp_inf > zero) THEN
+      IF (efermi_read) THEN
+        ef_inf = fermi_energy
+      ELSE
+        ef_inf = efermig(et_loc, nbnd, nks, nelec, wk, temp_inf, type_inf, 0, dummy)
+      ENDIF
+      !
+      dynqcr = dynqc + pi(epmatqc0, epmatq0, ef_inf, temp_inf, type_inf)
+      dynqr = dynqr + pi(epmatq0, epmatq0, ef_inf, temp_inf, type_inf)
+    ELSE
+      dynqcr = dynqc + pi(epmatqc0, epmatq0, ef, degauss, ngauss)
+    ENDIF
+    !
+    CONTAINS
+      !
+      FUNCTION pi(ga, gb, mu, temp, ntemp)
+        COMPLEX(KIND = DP) :: pi(nmodes, nmodes, nqc1 * nqc2 * nqc3)
+        !
+        COMPLEX(KIND = DP), INTENT(IN) :: ga(nbndep, nbndep, nks, nmodes, nqc1 * nqc2 * nqc3)
+        COMPLEX(KIND = DP), INTENT(IN) :: gb(nbndep, nbndep, nks, nmodes, nqc1 * nqc2 * nqc3)
+        REAL(KIND = DP), INTENT(IN) :: mu, temp
+        INTEGER, INTENT(IN) :: ntemp
+        !
+        INTEGER :: ik, iq
+        INTEGER :: kk1, kk2, kk3, ibndep, ibnd, icart
+        INTEGER :: kq1, kq2, kq3, jbndep, jbnd, jcart
+        REAL(KIND = DP) :: ekk, ekq, fkk, fkq, chi0
+        COMPLEX(KIND = DP) :: g2(nmodes, nmodes)
+        !
+        pi = czero
+        !
+        DO iq = 1, nqc1 * nqc2 * nqc3
+          DO ik = 1, nks
+            kk1 = kmesh(1, ik) + 1
+            kk2 = kmesh(2, ik) + 1
+            kk3 = kmesh(3, ik) + 1
+            !
+            kq1 = MODULO(kmesh(1, ik) + qmesh(1, iq), nkc1) + 1
+            kq2 = MODULO(kmesh(2, ik) + qmesh(2, iq), nkc2) + 1
+            kq3 = MODULO(kmesh(3, ik) + qmesh(3, iq), nkc3) + 1
+            !
+            DO ibndep = 1, nbndep
+              ibnd = ibndep - 1 + ibndstart
+              !
+              IF (emesh(ibnd, kk3, kk2, kk1) < cdfpt_min) CYCLE
+              IF (emesh(ibnd, kk3, kk2, kk1) > cdfpt_max) CYCLE
+              !
+              DO jbndep = 1, nbndep
+                jbnd = jbndep - 1 + ibndstart
+                !
+                IF (emesh(jbnd, kq3, kq2, kq1) < cdfpt_min) CYCLE
+                IF (emesh(jbnd, kq3, kq2, kq1) > cdfpt_max) CYCLE
+                !
+                ekk = emesh(ibnd, kk3, kk2, kk1) - mu
+                ekq = emesh(jbnd, kq3, kq2, kq1) - mu
+                !
+                IF (temp > zero) THEN
+                  IF (ABS(ekq - ekk) > eps12) THEN
+                    fkk = wgauss(-ekk / temp, ntemp)
+                    fkq = wgauss(-ekq / temp, ntemp)
+                    !
+                    chi0 = (fkq - fkk) / (ekq - ekk)
+                  ELSE
+                    chi0 = -w0gauss(-ekk / temp, ntemp) / temp
+                  ENDIF
+                ELSE
+                  IF (ekk > zero .NEQV. ekq > zero) THEN
+                    chi0 = -one / ABS(ekq - ekk)
+                  ELSE
+                    chi0 = zero
+                  END IF
+                ENDIF
+                !
+                DO icart = 1, nmodes
+                  DO jcart = 1, nmodes
+                    g2(jcart, icart) = (&
+                      CONJG(ga(jbndep, ibndep, ik, jcart, iq)) &
+                          * gb(jbndep, ibndep, ik, icart, iq) +&
+                      CONJG(gb(jbndep, ibndep, ik, jcart, iq)) &
+                          * ga(jbndep, ibndep, ik, icart, iq)) / two
+                  ENDDO
+                ENDDO
+                !
+                pi(:, :, iq) = pi(:, :, iq) + g2 * chi0
+              ENDDO
+            ENDDO
+          ENDDO
+        ENDDO
+        !
+        pi = two / nkstot * pi
+        !
+        CALL mp_sum(pi, inter_pool_comm)
+      END FUNCTION pi
+      !
+      !---------------------------------------------------------------------
+    END SUBROUTINE unscreen_dynq
+    !-----------------------------------------------------------------------
+    !
+    !-----------------------------------------------------------------------
+    SUBROUTINE renorm_phon_q(iq, w2, uf, w2c, ufc, w2x, ufx, w2r, ufr, w2cr, ufcr, ufr1, ufr2)
+    !-----------------------------------------------------------------------
+    !!
+    !! Renormalize dynamical matrix on fine mesh.
+    !! See also Calandra, Profeta, and Mauri, PRB 82, 165111 (2010).
+    !!
+    !-----------------------------------------------------------------------
+    USE kinds,      ONLY : DP
+    USE constants_epw, ONLY : zero, czero, one, ci, two, pi, eps5, eps12
+    USE elph2,      ONLY : etf, wfr1, wfr2, wfw1, wfw2, epf17, epf17c, epf17x, &
+                           nbndfst, ibndmin, nkf, nktotf, efw0, efw_inf, efw, gtemp
+    USE epwcom,     ONLY : cdfpt_min, cdfpt_max, types, nstemp, degaussw, degaussq, &
+                           specfun_ph, wmin_specfun, wmax_specfun, nw_specfun, corr, &
+                           temp_inf, type_inf, unscreen_fine, lxdfpt
+    USE ions_base,  ONLY : amass, ityp
+    USE klist,      ONLY : degauss, ngauss
+    USE matrix_inversion, ONLY: invmat
+    USE modes,      ONLY : nmodes
+    USE mp,         ONLY : mp_barrier, mp_sum
+    USE mp_global,  ONLY : inter_pool_comm
+    USE rigid,      ONLY : cdiagh2
+    !
+    IMPLICIT NONE
+    !
+    INTEGER, INTENT(in) :: iq
+    !! Current q-point index
+    REAL(KIND = DP), INTENT(in) :: w2(nmodes)
+    !! Eigenvalues of dynamical matrix
+    COMPLEX(KIND = DP), INTENT(in) :: uf(nmodes, nmodes)
+    !! Eigendisplacements [including 1/sqrt(M)]
+    REAL(KIND = DP), INTENT(in) :: w2c(nmodes)
+    !! Eigenvalues of dynamical matrix (cDFPT)
+    COMPLEX(KIND = DP), INTENT(in) :: ufc(nmodes, nmodes)
+    !! Eigendisplacements [including 1/sqrt(M)] (cDFPT)
+    REAL(KIND = DP), INTENT(in) :: w2x(nmodes)
+    !! Eigenvalues of dynamical matrix (extra DFPT) [currently not used]
+    COMPLEX(KIND = DP), INTENT(in) :: ufx(nmodes, nmodes)
+    !! Eigendisplacements [including 1/sqrt(M)] (extra DFPT)
+    REAL(KIND = DP), INTENT(in) :: w2r(nmodes)
+    !! Eigenvalues of dynamical matrix (renormalized)
+    COMPLEX(KIND = DP), INTENT(in) :: ufr(nmodes, nmodes)
+    !! Eigendisplacements [including 1/sqrt(M)] (renormalized)
+    REAL(KIND = DP), INTENT(in) :: w2cr(nmodes)
+    !! Eigenvalues of dynamical matrix (cDFPT, renormalized)
+    COMPLEX(KIND = DP), INTENT(in) :: ufcr(nmodes, nmodes)
+    !! Eigendisplacements [including 1/sqrt(M)] (cDFPT, renormalized)
+    COMPLEX(KIND = DP), INTENT(out) :: ufr1(nmodes, nmodes, nstemp)
+    !! Eigendisplacements [including 1/sqrt(M)] (cDFPT+Pi)
+    COMPLEX(KIND = DP), INTENT(out) :: ufr2(nmodes, nmodes, nstemp)
+    !! Eigendisplacements [including 1/sqrt(M)] (DFPT-Pi+Pi)
+    !
+    INTEGER :: ik, ikk, ikq
+    !! k-point indices
+    INTEGER :: ibnd, jbnd, ibndfst, jbndfst
+    !! Electronic band indices
+    INTEGER :: imode, jmode
+    !! Phononic band indices
+    INTEGER :: icart, jcart
+    !! Cartesian displacement directions
+    INTEGER :: itemp
+    !! Counter on electronic smearings
+    INTEGER :: iw
+    !! Counter on the frequency
+    COMPLEX(KIND = DP) :: d1(nmodes, nmodes)
+    !! High-smearing/unscreened dynamical matrix (cDFPT+Pi)
+    COMPLEX(KIND = DP) :: d2(nmodes, nmodes)
+    !! High-smearing/unscreened dynamical matrix (DFPT-Pi+Pi)
+    COMPLEX(KIND = DP) :: d_renorm(nmodes, nmodes)
+    !! Renormalized dynamical matrix in Cartesian basis
+    COMPLEX(KIND = DP) :: pipf(nmodes, nmodes, nstemp)
+    !! Phonon self-energy in Cartesian basis (cDFPT-DFPT, target smearing)
+    COMPLEX(KIND = DP) :: pipf0(nmodes, nmodes)
+    !! Phonon self-energy in Cartesian basis (cDFPT-DFPT, original smearing)
+    COMPLEX(KIND = DP) :: pipf_inf(nmodes, nmodes)
+    !! Phonon self-energy in Cartesian basis (cDFPT-DFPT, high smearing)
+    COMPLEX(KIND = DP) :: pipfw(nmodes, nmodes, nw_specfun, nstemp)
+    !! Phonon self-energy in Cartesian basis (cDFPT-DFPT, dynamical)
+    COMPLEX(KIND = DP) :: piff(nmodes, nmodes, nstemp)
+    !! Phonon self-energy in Cartesian basis (DFPT only, target smearing)
+    COMPLEX(KIND = DP) :: piff0(nmodes, nmodes)
+    !! Phonon self-energy in Cartesian basis (DFPT only, original smearing)
+    COMPLEX(KIND = DP) :: piff_inf(nmodes, nmodes)
+    !! Phonon self-energy in Cartesian basis (DFPT only, high smearing)
+    COMPLEX(KIND = DP) :: piffw(nmodes, nmodes, nw_specfun, nstemp)
+    !! Phonon self-energy in Cartesian basis (DFPT only, dynamical)
+    COMPLEX(KIND = DP) :: ef(nmodes, nmodes)
+    !! Eigenvectors of dynamical matrix [with 1/sqrt(M)]
+    COMPLEX(KIND = DP) :: efc(nmodes, nmodes)
+    !! Eigenvectors of dynamical matrix [with 1/sqrt(M)] (cDFPT)
+    COMPLEX(KIND = DP) :: efx(nmodes, nmodes)
+    !! Eigenvectors of dynamical matrix [with 1/sqrt(M)] (extra DFPT)
+    COMPLEX(KIND = DP) :: efr(nmodes, nmodes)
+    !! Eigenvectors of dynamical matrix [with 1/sqrt(M)] (renormalized)
+    COMPLEX(KIND = DP) :: efcr(nmodes, nmodes)
+    !! Eigenvectors of dynamical matrix [with 1/sqrt(M)] (cDFPT, renormalized)
+    COMPLEX(KIND = DP) :: g_cdfpt(nmodes)
+    !! Electron-phonon coupling in Cartesian basis (cDFPT)
+    COMPLEX(KIND = DP) :: g_xdfpt(nmodes)
+    !! Electron-phonon coupling in Cartesian basis (extra DFPT)
+    COMPLEX(KIND = DP) :: g_dfpt(nmodes)
+    !! Electron-phonon coupling in Cartesian basis (DFPT)
+    COMPLEX(KIND = DP) :: g_screen(nmodes)
+    !! Electron-phonon coupling in Cartesian basis (corrected for target smearing)
+    COMPLEX(KIND = DP) :: g2pf(nmodes, nmodes)
+    !! Electron-phonon coupling squared (cDFPT-DFPT)
+    COMPLEX(KIND = DP) :: g2ff(nmodes, nmodes)
+    !! Electron-phonon coupling squared (DFPT-DFPT)
+    REAL(KIND = DP) :: u_crpa
+    !! Effective cRPA Coulomb interaction for coupling correction
+    REAL(KIND = DP) :: enum0, deno0, enum(nmodes, nstemp), deno(nmodes, nstemp)
+    !! Enumerator and denominator of coupling correction factor
+    COMPLEX(KIND = DP) :: cchi
+    !! Dynamical susceptibility
+    COMPLEX(KIND = DP) :: ceta, cdelta
+    !! Small imaginary numbers
+    REAL(KIND = DP) :: prefactor
+    !! Number of spins divided by number of k points
+    REAL(KIND = DP) :: sqm(nmodes)
+    !! Square root of atomic masses
+    REAL(KIND = DP) :: ekk, ekq, fkk, fkq, chi0, chi_inf, chi, chi0sum, chisum(nstemp)
+    !! Energies, occupations, and susceptibility
+    REAL(KIND = DP) :: ww(nw_specfun)
+    !! Current frequency
+    REAL(KIND = DP) :: dw
+    !! Frequency intervals
+    REAL(KIND = DP), EXTERNAL :: wgauss, w0gauss
+    !! Step and delta function
+    !
+    DO icart = 1, nmodes
+      sqm(icart) = DSQRT(amass(ityp((icart - 1) / 3 + 1)))
+    ENDDO
+    !
+    DO icart = 1, nmodes
+      ef(icart, :) = uf(icart, :) * sqm(icart)
+      efc(icart, :) = ufc(icart, :) * sqm(icart)
+      IF (lxdfpt) efx(icart, :) = ufx(icart, :) * sqm(icart)
+      efr(icart, :) = ufr(icart, :) * sqm(icart)
+      efcr(icart, :) = ufcr(icart, :) * sqm(icart)
+    ENDDO
+    !
+    d1 = czero
+    d2 = czero
+    !
+    DO icart = 1, nmodes
+      DO jcart = 1, nmodes
+        DO imode = 1, nmodes
+          IF (temp_inf > zero) THEN
+            d1(jcart, icart) = d1(jcart, icart) &
+              + efcr(jcart, imode) * w2cr(imode) * CONJG(efcr(icart, imode))
+          ELSE
+            d1(jcart, icart) = d1(jcart, icart) &
+              + efc(jcart, imode) * w2c(imode) * CONJG(efc(icart, imode))
+          ENDIF
+          !
+          IF (unscreen_fine) THEN
+            d2(jcart, icart) = d2(jcart, icart) &
+              + ef(jcart, imode) * w2(imode) * CONJG(ef(icart, imode))
+          ELSE
+            d2(jcart, icart) = d2(jcart, icart) &
+              + efr(jcart, imode) * w2r(imode) * CONJG(efr(icart, imode))
+          ENDIF
+        ENDDO
+      ENDDO
+    ENDDO
+    !
+    IF (specfun_ph) THEN
+      dw = (wmax_specfun - wmin_specfun) / (nw_specfun - 1)
+      !
+      DO iw = 1, nw_specfun
+        ww(iw) = wmin_specfun + (iw - 1) * dw
+      ENDDO
+    ENDIF
+    !
+    ceta = ci * degaussw
+    cdelta = ci * degaussq
+    prefactor = two / nktotf
+    !
+    IF (temp_inf <= zero .AND. corr /= 0) THEN
+      IF (corr == 1) THEN
+        chi0sum = zero
+        chisum = zero
+        enum0 = zero
+        deno0 = zero
+      ELSE
+        enum = zero
+        deno = zero
+      ENDIF
+      !
+      CALL bubble(run=1)
+      !
+      IF (corr == 1) THEN
+        CALL mp_sum(chi0sum, inter_pool_comm)
+        CALL mp_sum(chisum, inter_pool_comm)
+        CALL mp_sum(enum0, inter_pool_comm)
+        CALL mp_sum(deno0, inter_pool_comm)
+        !
+        chi0sum = prefactor * chi0sum
+        chisum = prefactor * chisum
+        !
+        u_crpa = enum0 / deno0
+      ELSE
+        CALL mp_sum(deno, inter_pool_comm)
+        CALL mp_sum(enum, inter_pool_comm)
+      ENDIF
+    ENDIF
+    !
+    pipf = czero
+    piff = czero
+    !
+    IF (unscreen_fine) THEN
+      pipf0 = czero
+      piff0 = czero
+    ELSEIF (temp_inf > zero) THEN
+      pipf_inf = czero
+      piff_inf = czero
+    ENDIF
+    !
+    IF (specfun_ph) THEN
+      pipfw = czero
+      piffw = czero
+    ENDIF
+    !
+    CALL bubble(run=2)
+    !
+    CALL mp_sum(pipf, inter_pool_comm)
+    CALL mp_sum(piff, inter_pool_comm)
+    !
+    IF (unscreen_fine) THEN
+      CALL mp_sum(pipf0, inter_pool_comm)
+      CALL mp_sum(piff0, inter_pool_comm)
+    ELSEIF (temp_inf > zero) THEN
+      CALL mp_sum(pipf_inf, inter_pool_comm)
+      CALL mp_sum(piff_inf, inter_pool_comm)
+    ENDIF
+    !
+    IF (specfun_ph) THEN
+      CALL mp_sum(pipfw, inter_pool_comm)
+      CALL mp_sum(piffw, inter_pool_comm)
+    ENDIF
+    !
+    IF (temp_inf < zero) THEN ! misue to print phonon self-energy
+      d1 = czero
+      d2 = czero
+    ENDIF
+    !
+    IF (unscreen_fine) THEN
+      d1 = d2 - prefactor * pipf0
+      d2 = d2 - prefactor * piff0
+    ELSEIF (temp_inf > zero) THEN
+      d1 = d1 - prefactor * pipf_inf
+      d2 = d2 - prefactor * piff_inf
+    ENDIF
+    !
+    DO itemp = 1, nstemp
+      d_renorm = d1 + prefactor * pipf(:, :, itemp)
+      CALL spectrum(d_renorm, wfr1(:, iq, itemp), ufr1(:, :, itemp))
+      !
+      d_renorm = d2 + prefactor * piff(:, :, itemp)
+      CALL spectrum(d_renorm, wfr2(:, iq:, itemp), ufr2(:, :, itemp))
+      !
+      IF (specfun_ph) THEN
+        DO iw = 1, nw_specfun
+          d_renorm = d1 + prefactor * pipfw(:, :, iw, itemp)
+          CALL specfun(d_renorm, ww(iw), wfw1(iw, iq, itemp))
+          !
+          d_renorm = d2 + prefactor * piffw(:, :, iw, itemp)
+          CALL specfun(d_renorm, ww(iw), wfw2(iw, iq, itemp))
+        ENDDO
+      ENDIF
+    ENDDO
+    !
+    CONTAINS
+      !
+      SUBROUTINE bubble(run)
+        INTEGER, INTENT(IN) :: run
+        !
+        DO ik = 1, nkf
+          ikk = 2 * ik - 1
+          ikq = ikk + 1
+          !
+          DO ibndfst = 1, nbndfst
+            ibnd = ibndmin - 1 + ibndfst
+            !
+            IF (etf(ibnd, ikk) < cdfpt_min) CYCLE
+            IF (etf(ibnd, ikk) > cdfpt_max) CYCLE
+            !
+            DO jbndfst = 1, nbndfst
+              jbnd = ibndmin - 1 + jbndfst
+              !
+              IF (etf(jbnd, ikq) < cdfpt_min) CYCLE
+              IF (etf(jbnd, ikq) > cdfpt_max) CYCLE
+              !
+              g_dfpt = czero
+              g_cdfpt = czero
+              IF (lxdfpt) g_xdfpt = czero
+              !
+              DO icart = 1, nmodes
+                DO imode = 1, nmodes
+                  g_dfpt(icart) = g_dfpt(icart) &
+                    + epf17(jbndfst, ibndfst, imode, ik) * CONJG(ef(icart, imode))
+                  g_cdfpt(icart) = g_cdfpt(icart) &
+                    + epf17c(jbndfst, ibndfst, imode, ik) * CONJG(efc(icart, imode))
+                  IF (lxdfpt) g_xdfpt(icart) = g_xdfpt(icart) &
+                    + epf17x(jbndfst, ibndfst, imode, ik) * CONJG(efx(icart, imode))
+                ENDDO
+              ENDDO
+              !
+              ekk = etf(ibnd, ikk) - efw0
+              ekq = etf(jbnd, ikq) - efw0
+              !
+              IF (degauss > zero) THEN
+                IF (ABS(ekq - ekk) > eps12) THEN
+                  fkk = wgauss(-ekk / degauss, ngauss)
+                  fkq = wgauss(-ekq / degauss, ngauss)
+                  !
+                  chi0 = (fkq - fkk) / (ekq - ekk)
+                ELSE
+                  chi0 = -w0gauss(-ekk / degauss, ngauss) / degauss
+                ENDIF
+              ELSE
+                IF (ekk > zero .NEQV. ekq > zero) THEN
+                  chi0 = -one / ABS(ekq - ekk)
+                ELSE
+                  chi0 = zero
+                END IF
+              ENDIF
+              !
+              SELECT CASE (run)
+              CASE (1)
+                IF (temp_inf <= zero .AND. corr == 1) THEN
+                  chi0sum = chi0sum + chi0
+                  !
+                  enum0 = enum0 + SUM(ABS(g_dfpt - g_cdfpt))
+                  deno0 = deno0 + SUM(ABS(g_dfpt * chi0))
+                ENDIF
+                !
+              CASE (2)
+                DO icart = 1, nmodes
+                  DO jcart = 1, nmodes
+                    g2pf(jcart, icart) = (CONJG(g_cdfpt(jcart)) * g_dfpt(icart) &
+                      + CONJG(g_dfpt(jcart)) * g_cdfpt(icart)) / two
+                    g2ff(jcart, icart) = CONJG(g_dfpt(jcart)) * g_dfpt(icart)
+                  ENDDO
+                ENDDO
+                !
+                IF (unscreen_fine) THEN
+                  pipf0 = pipf0 + g2pf * chi0
+                  piff0 = piff0 + g2ff * chi0
+                ELSEIF (temp_inf > zero) THEN
+                  ekk = etf(ibnd, ikk) - efw_inf
+                  ekq = etf(jbnd, ikq) - efw_inf
+                  !
+                  IF (ABS(ekq - ekk) > eps12) THEN
+                    fkk = wgauss(-ekk / temp_inf, type_inf)
+                    fkq = wgauss(-ekq / temp_inf, type_inf)
+                    !
+                    chi_inf = (fkq - fkk) / (ekq - ekk)
+                  ELSE
+                    chi_inf = -w0gauss(-ekk / temp_inf, type_inf) / temp_inf
+                  ENDIF
+                  !
+                  pipf_inf = pipf_inf + g2pf * chi_inf
+                  piff_inf = piff_inf + g2ff * chi_inf
+                ENDIF
+              END SELECT
+              !
+              IF (lxdfpt) THEN
+                DO icart = 1, nmodes
+                  DO jcart = 1, nmodes
+                    g2pf(jcart, icart) = (CONJG(g_cdfpt(jcart)) * g_xdfpt(icart) &
+                      + CONJG(g_xdfpt(jcart)) * g_cdfpt(icart)) / two
+                    g2ff(jcart, icart) = CONJG(g_xdfpt(jcart)) * g_xdfpt(icart)
+                  ENDDO
+                ENDDO
+              ENDIF
+              !
+              DO itemp = 1, nstemp
+                ekk = etf(ibnd, ikk) - efw(itemp)
+                ekq = etf(jbnd, ikq) - efw(itemp)
+                !
+                fkk = wgauss(-ekk / gtemp(itemp), types(itemp))
+                fkq = wgauss(-ekq / gtemp(itemp), types(itemp))
+                !
+                IF (ABS(ekq - ekk) > eps12) THEN
+                  chi = (fkq - fkk) / (ekq - ekk)
+                ELSE
+                  chi = -w0gauss(-ekk / gtemp(itemp), types(itemp)) / gtemp(itemp)
+                ENDIF
+                !
+                SELECT CASE (run)
+                CASE (1)
+                  IF (temp_inf <= zero .AND. corr /= 0) THEN
+                    IF (corr == 1) THEN
+                      chisum(itemp) = chisum(itemp) + chi
+                    ELSEIF (corr > 1 .OR. corr == -ibnd .AND. corr == -jbnd) THEN
+                      enum(:, itemp) = enum(:, itemp) + abs(chi * g_cdfpt)
+                      deno(:, itemp) = deno(:, itemp) + abs(chi * (g_cdfpt - g_dfpt) &
+                        + chi0 * g_dfpt)
+                    ENDIF
+                  ENDIF
+                  !
+                CASE (2)
+                  IF (temp_inf <= zero .AND. &
+                      (corr > 0 .OR. corr == -ibnd .AND. corr == -jbnd)) THEN
+                    IF (corr == 1) THEN
+                      g_screen = g_dfpt * (chi0sum * u_crpa - one) &
+                        / (chisum(itemp) * u_crpa - one)
+                    ELSE
+                      g_screen = g_cdfpt + enum(:, itemp) / deno(:, itemp) &
+                        * (g_dfpt - g_cdfpt)
+                    ENDIF
+                    !
+                    DO icart = 1, nmodes
+                      DO jcart = 1, nmodes
+                        g2pf(jcart, icart) = (CONJG(g_cdfpt(jcart)) * g_screen(icart) &
+                          + CONJG(g_screen(jcart)) * g_cdfpt(icart)) / two
+                      ENDDO
+                    ENDDO
+                  ENDIF
+                  !
+                  pipf(:, :, itemp) = pipf(:, :, itemp) + g2pf * chi
+                  piff(:, :, itemp) = piff(:, :, itemp) + g2ff * chi
+                  !
+                  IF (specfun_ph) THEN
+                    DO iw = 1, nw_specfun
+                      cchi = (fkk - fkq) / (ekk - ekq + ww(iw) + ceta)
+                      !
+                      pipfw(:, :, iw, itemp) = pipfw(:, :, iw, itemp) + g2pf * cchi
+                      piffw(:, :, iw, itemp) = piffw(:, :, iw, itemp) + g2ff * cchi
+                    ENDDO
+                  ENDIF
+                END SELECT
+              ENDDO
+            ENDDO
+          ENDDO
+        ENDDO
+      END SUBROUTINE bubble
+      !
+      SUBROUTINE spectrum(d, w, u)
+        COMPLEX(KIND = DP), INTENT(IN) :: d(nmodes, nmodes)
+        REAL(KIND = DP), INTENT(OUT) :: w(nmodes)
+        COMPLEX(KIND = DP), INTENT(OUT) :: u(nmodes, nmodes)
+        !
+        REAL(KIND = DP) :: w2(nmodes)
+        COMPLEX(KIND = DP) :: e(nmodes, nmodes)
+        !
+        CALL cdiagh2(nmodes, d, nmodes, w2, e)
+        w = SIGN(DSQRT(ABS(w2)), w2)
+        !
+        DO icart = 1, nmodes
+          u(icart, :) = e(icart, :) / sqm(icart)
+        ENDDO
+      END SUBROUTINE spectrum
+      !
+      SUBROUTINE specfun(d, w, a)
+        COMPLEX(KIND = DP), INTENT(INOUT) :: d(nmodes, nmodes)
+        REAL(KIND = DP), INTENT(IN) :: w
+        REAL(KIND = DP), INTENT(OUT) :: a
+        !
+        DO icart = 1, nmodes
+          d(icart, icart) = d(icart, icart) - (w + cdelta) ** 2
+        ENDDO
+        !
+        CALL invmat(nmodes, d)
+        !
+        a = zero
+        !
+        DO imode = 1, nmodes
+          a = a + w / pi * AIMAG(d(imode, imode))
+        ENDDO
+        !
+      END SUBROUTINE specfun
+      !
+      !---------------------------------------------------------------------
+    END SUBROUTINE renorm_phon_q
+    !-----------------------------------------------------------------------
+    !
+    !-----------------------------------------------------------------------
     SUBROUTINE selfen_pl_q(iqq, iq, totq, first_cycle)
     !-----------------------------------------------------------------------
     !!
diff --git a/EPW/src/stop_epw.f90 b/EPW/src/stop_epw.f90
index cb74df2cc..9d9f9bd63 100644
--- a/EPW/src/stop_epw.f90
+++ b/EPW/src/stop_epw.f90
@@ -20,7 +20,7 @@
   USE mp_global, ONLY : inter_pool_comm, mp_global_end
   USE io_global, ONLY : stdout
   USE printing,  ONLY : print_clock_epw
-  USE epwcom,    ONLY : eliashberg, plselfen, specfun_pl, scattering, iterative_bte, lpolar
+  USE epwcom,    ONLY : eliashberg, plselfen, specfun_pl, scattering, iterative_bte, lpolar, lpolarc, lpolarx
   USE elph2,     ONLY : adapt_smearing
   USE io_var,    ONLY : epwbib
   USE mp_world,  ONLY : mpime
@@ -84,7 +84,7 @@
     ENDIF         
     ! 
     ! Polar analytic interpolation
-    IF (lpolar) THEN
+    IF (lpolar .OR. lpolarc .OR. lpolarx) THEN
       WRITE(epwbib, '(a)') "                                                                                         "
       WRITE(epwbib, '(a)') " % Since you used the [lpolar] input, please consider also citing                        "
       WRITE(epwbib, '(a)') " @Article{Verdi2015,                                                                     "
diff --git a/EPW/src/utilities.f90 b/EPW/src/utilities.f90
index d691846c8..a5b351283 100644
--- a/EPW/src/utilities.f90
+++ b/EPW/src/utilities.f90
@@ -996,7 +996,7 @@
     USE kinds,         ONLY : DP
     USE io_global,     ONLY : stdout
     USE elph2,         ONLY : etf, ibndmin, ibndmax, nkqf
-    USE epwcom,        ONLY : fsthick, nbndsub
+    USE epwcom,        ONLY : fsthick, nbndsub, lcdfpt, cdfpt_min, cdfpt_max
     USE pwcom,         ONLY : ef
     USE mp,            ONLY : mp_max, mp_min
     USE mp_global,     ONLY : inter_pool_comm
@@ -1017,6 +1017,10 @@
     !! Maximum eigenvalue
     REAL(KIND = DP) :: tmp
     !
+    IF (lcdfpt) THEN
+      fsthick = MAX(ABS(cdfpt_min - ef), ABS(cdfpt_max - ef))
+      WRITE(stdout,'(/31x,a,f9.3,a)') 'fsthick = ', fsthick * ryd2ev, ' eV'
+    ENDIF
     !
     ibndmin = 100000
     ibndmax = 0
diff --git a/EPW/src/wan2bloch.f90 b/EPW/src/wan2bloch.f90
index baf8b319b..45f3f7696 100644
--- a/EPW/src/wan2bloch.f90
+++ b/EPW/src/wan2bloch.f90
@@ -285,7 +285,7 @@
     !--------------------------------------------------------------------------
     !
     !--------------------------------------------------------------------------
-    SUBROUTINE dynwan2bloch(nmodes, nrr_q, irvec_q, ndegen_q, xxq, cuf, eig)
+    SUBROUTINE dynwan2bloch(rdw, nmodes, nrr_q, irvec_q, ndegen_q, xxq, cuf, eig, lpolar, qrpl, epsi, zstar, Qmat)
     !--------------------------------------------------------------------------
     !!
     !! From the Hamiltonian in Wannier representation, find the corresponding
@@ -300,8 +300,7 @@
     USE kinds,         ONLY : DP
     USE cell_base,     ONLY : at, bg
     USE ions_base,     ONLY : amass, tau, nat, ityp
-    USE elph2,         ONLY : rdw, epsi, zstar, qrpl
-    USE epwcom,        ONLY : lpolar, lphase, use_ws, nqc1, nqc2, nqc3
+    USE epwcom,        ONLY : lphase, use_ws, nqc1, nqc2, nqc3
     USE constants_epw, ONLY : twopi, ci, czero, zero, one, eps12
     USE rigid,         ONLY : cdiagh2
     USE low_lvl,       ONLY : utility_zdotu
@@ -309,6 +308,8 @@
     !
     IMPLICIT NONE
     !
+    COMPLEX(KIND = DP), INTENT(in) :: rdw(nmodes, nmodes, nrr_q)
+    !! dynamical matrix in wannier basis (real)
     INTEGER, INTENT(in) :: nmodes
     !! number of modes (possibly of the optimal subspace)
     INTEGER, INTENT(in) :: nrr_q
@@ -323,6 +324,16 @@
     !! interpolated dynamical matrix eigenvalues for this kpoint
     COMPLEX(KIND = DP), INTENT(out) :: cuf(nmodes, nmodes)
     !! Rotation matrix, fine mesh
+    LOGICAL, INTENT(in) :: lpolar
+    !! if .TRUE. enable the correct Wannier interpolation in the case of polar material
+    LOGICAL, INTENT(in) :: qrpl
+    !! If true use quadrupole during interpolation
+    REAL(KIND = DP), INTENT(in) :: epsi(3, 3)
+    !! dielectric constant tensor
+    REAL(KIND = DP), INTENT(inout) :: zstar(3, 3, nat)
+    !! effective charges tensor
+    REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+    !! Quadrupole tensor
     !
     ! Local variables
     INTEGER :: imode
@@ -396,7 +407,7 @@
     !  add the long-range term to D(q)
     IF (lpolar .OR. qrpl) THEN
       ! xq has to be in 2pi/a
-      CALL rgd_blk(nqc1, nqc2, nqc3, nat, chf, xq, tau, epsi, zstar, +1.d0)
+      CALL rgd_blk(nqc1, nqc2, nqc3, nat, chf, xq, tau, lpolar, epsi, zstar, Qmat, +1.d0)
       !
     ENDIF
     !
@@ -466,7 +477,7 @@
     !--------------------------------------------------------------------------
     !
     !--------------------------------------------------------------------------
-    SUBROUTINE dynifc2blochf(nmodes, rws, nrws, xxq, cuf, eig)
+    SUBROUTINE dynifc2blochf(ifc, nmodes, rws, nrws, xxq, cuf, eig, lpolar, qrpl, epsi, zstar, Qmat)
     !--------------------------------------------------------------------------
     !!
     !!  From the IFCs in the format of q2r, find the corresponding
@@ -476,8 +487,8 @@
     USE kinds,     ONLY : DP
     USE cell_base, ONLY : at, bg
     USE ions_base, ONLY : amass, tau, nat, ityp
-    USE elph2,     ONLY : ifc, epsi, zstar, wscache, qrpl
-    USE epwcom,    ONLY : lpolar, nqc1, nqc2, nqc3, lphase
+    USE elph2,     ONLY : wscache
+    USE epwcom,    ONLY : nqc1, nqc2, nqc3, lphase
     USE io_global, ONLY : stdout
     USE rigid_epw, ONLY : rgd_blk
     USE low_lvl,       ONLY : utility_zdotu
@@ -485,6 +496,8 @@
     !
     IMPLICIT NONE
     !
+    REAL(KIND = DP), INTENT(in) :: ifc(nqc1, nqc2, nqc3, 3, 3, nat, nat)
+    !! Interatomic force constant in real space
     INTEGER, INTENT(in) :: nmodes
     !! number of modes
     INTEGER, INTENT(in) :: nrws
@@ -497,6 +510,16 @@
     !! interpolated phonon eigenvalues for this qpoint
     COMPLEX(KIND = DP), INTENT(out) :: cuf(nmodes, nmodes)
     !! Rotation matrix, fine mesh
+    LOGICAL, INTENT(in) :: lpolar
+    !! if .TRUE. enable the correct Wannier interpolation in the case of polar material
+    LOGICAL, INTENT(in) :: qrpl
+    !! If true use quadrupole during interpolation
+    REAL(KIND = DP), INTENT(in) :: epsi(3, 3)
+    !! dielectric constant tensor
+    REAL(KIND = DP), INTENT(inout) :: zstar(3, 3, nat)
+    !! effective charges tensor
+    REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+    !! Quadrupole tensor
     !
     ! Local variables
     LOGICAL, SAVE :: first = .TRUE.
@@ -653,7 +676,7 @@
     !
     IF (lpolar .OR. qrpl) THEN
       ! xq has to be in 2pi/a
-      CALL rgd_blk(nqc1, nqc2, nqc3, nat, chf, xq, tau, epsi, zstar, +1.d0)
+      CALL rgd_blk(nqc1, nqc2, nqc3, nat, chf, xq, tau, lpolar, epsi, zstar, Qmat, +1.d0)
       !
     ENDIF
     !
@@ -718,7 +741,7 @@
     !--------------------------------------------------------------------------
     !
     !--------------------------------------------------------------------------
-    SUBROUTINE dynifc2blochc(nmodes, rws, nrws, xxq, chf)
+    SUBROUTINE dynifc2blochc(nmodes, rws, nrws, xxq, chf, lpolar, qrpl, epsi, zstar, Qmat)
     !--------------------------------------------------------------------------
     !!
     !! From the IFCs in the format of q2r, find the corresponding
@@ -728,8 +751,8 @@
     USE kinds,     ONLY : DP
     USE cell_base, ONLY : at, bg
     USE ions_base, ONLY : tau, nat
-    USE elph2,     ONLY : ifc, epsi, zstar, wscache, qrpl
-    USE epwcom,    ONLY : lpolar, nqc1, nqc2, nqc3
+    USE elph2,     ONLY : ifc, wscache
+    USE epwcom,    ONLY : nqc1, nqc2, nqc3
     USE constants_epw, ONLY : twopi, czero, zero, eps8
     USE io_global, ONLY : stdout
     USE rigid_epw, ONLY : rgd_blk
@@ -746,6 +769,16 @@
     !! Crystal q-point coordinates for the interpolation
     COMPLEX(KIND = DP), INTENT(out) :: chf(nmodes, nmodes)
     !! dyn mat (not divided by the masses)
+    LOGICAL, INTENT(in) :: lpolar
+    !! if .TRUE. enable the correct Wannier interpolation in the case of polar material
+    LOGICAL, INTENT(in) :: qrpl
+    !! If true use quadrupole during interpolation
+    REAL(KIND = DP), INTENT(in) :: epsi(3, 3)
+    !! dielectric constant tensor
+    REAL(KIND = DP), INTENT(inout) :: zstar(3, 3, nat)
+    !! effective charges tensor
+    REAL(KIND = DP), INTENT(in) :: Qmat(nat, 3, 3, 3)
+    !! Quadrupole tensor
     !
     ! Local variables
     LOGICAL, SAVE :: first = .TRUE.
@@ -863,7 +896,7 @@
     !
     IF (lpolar .OR. qrpl) THEN
       ! xq has to be in 2pi/a
-      CALL rgd_blk(nqc1, nqc2, nqc3, nat, chf, xq, tau, epsi, zstar, +1.d0)
+      CALL rgd_blk(nqc1, nqc2, nqc3, nat, chf, xq, tau, lpolar, epsi, zstar, Qmat, +1.d0)
       !
     ENDIF
     !
@@ -1334,7 +1367,7 @@
     !! Samuel Ponce & Francesco Macheda
     !!
     USE kinds,         ONLY : DP
-    USE elph2,         ONLY : rdw, epsi, zstar, wscache, ifc
+    USE elph2,         ONLY : rdw, epsi, zstar, Qmat, wscache, ifc
     USE cell_base,     ONLY : at, alat, bg
     USE epwcom,        ONLY : use_ws, lpolar, lifc, nqc1, nqc2, nqc3
     USE constants_epw, ONLY : twopi, ci, czero, cone, zero, eps4, bohr2ang, one, eps8
@@ -1584,7 +1617,7 @@
     ! add the long-range term to D(q)
     IF (lpolar) THEN
       ! xq has to be in 2pi/a
-      CALL rgd_blk_der(nqc1, nqc2, nqc3, nat, chf_a, xq, tau, epsi, zstar, +1.d0)
+      CALL rgd_blk_der(nqc1, nqc2, nqc3, nat, chf_a, xq, tau, epsi, zstar, Qmat, +1.d0)
     ENDIF
     !
     !----------------------------------------------------------
@@ -1711,7 +1744,8 @@
     !--------------------------------------------------------------------------
     !
     !---------------------------------------------------------------------------
-    SUBROUTINE ephwan2blochp(nmodes, xxq, irvec_g, ndegen_g, nrr_g, cuf, epmatf, nbnd, nrr_k, dims, nat)
+    SUBROUTINE ephwan2blochp(epmatwp, iunepmatwp, iunepmatwp2, nmodes, xxq, &
+      irvec_g, ndegen_g, nrr_g, cuf, epmatf, nbnd, nrr_k, dims, nat)
     !---------------------------------------------------------------------------
     !!
     !! Even though this is for phonons, we use the same notations
@@ -1719,9 +1753,7 @@
     !!
     USE kinds,            ONLY : DP
     USE epwcom,           ONLY : etf_mem, use_ws
-    USE elph2,            ONLY : epmatwp
     USE constants_epw,    ONLY : twopi, ci, czero, cone
-    USE io_var,           ONLY : iunepmatwp, iunepmatwp2
     USE mp,               ONLY : mp_sum, mp_bcast
     USE mp_world,         ONLY : world_comm, mpime
     USE io_global,        ONLY : ionode_id
@@ -1734,6 +1766,12 @@
     !
     IMPLICIT NONE
     !
+    COMPLEX(KIND = DP), INTENT(in) :: epmatwp(nbnd, nbnd, nrr_k, nmodes, nrr_g)
+    !! e-p matrix  in wannier basis - electrons and phonons
+    INTEGER, INTENT(in) :: iunepmatwp
+    !! The unit with the e-ph matrix in Wannier-Wannier representation
+    INTEGER, INTENT(in) :: iunepmatwp2
+    !! Opening the epmatwp file
     INTEGER, INTENT(in) :: nmodes
     !! Total number of modes
     INTEGER, INTENT(in) :: nrr_g
@@ -1762,8 +1800,6 @@
     !! Real space WS index
     INTEGER :: iw
     !! Wannier function index
-    INTEGER :: iw2
-    !! Wannier function index
     INTEGER :: irn
     !! Combined WS and atom index
     INTEGER :: ir_start
@@ -1870,8 +1906,8 @@
           na = MOD(irn - 1, nat) + 1
           !
           DO iw = 1, dims
-            CALL ZAXPY(nrr_k * 3, cfac(iw, na, ir), epmatwp(iw, iw2, :, 3 * (na - 1) + 1:3 * na, ir), 1, &
-                 eptmp(iw, iw2, :, 3 * (na - 1) + 1:3 * na), 1)
+            CALL ZAXPY(nrr_k * 3, cfac(iw, na, ir), epmatwp(iw, :, :, 3 * (na - 1) + 1:3 * na, ir), 1, &
+                 eptmp(iw, :, :, 3 * (na - 1) + 1:3 * na), 1)
           ENDDO
         ENDDO
       ELSE ! use_ws
@@ -2208,7 +2244,7 @@
     !---------------------------------------------------------------------------
     !
     !---------------------------------------------------------------------------
-    SUBROUTINE ephwan2blochp_mem(imode, nmodes, xxq, irvec_g, ndegen_g, nrr_g, epmatf, nbnd, nrr_k, dims, nat)
+    SUBROUTINE ephwan2blochp_mem(imode, nmodes, xxq, irvec_g, ndegen_g, nrr_g, epmatf, nbnd, nrr_k, dims, nat, suffix)
     !---------------------------------------------------------------------------
     !!
     !! Even though this is for phonons, I use the same notations
@@ -2245,7 +2281,7 @@
     !! Is equal to the number of atoms if use_ws == .TRUE. or 1 otherwise.
     INTEGER, INTENT(in) :: irvec_g(3, nrr_g)
     !! Coordinates of WS points
-    INTEGER, INTENT(in) :: ndegen_g(nrr_g, nat, dims)
+    INTEGER, INTENT(in) :: ndegen_g(dims, nrr_g, nat)
     !! Number of degeneracy of WS points
     INTEGER, INTENT(in) :: nbnd
     !! Number of bands
@@ -2255,6 +2291,8 @@
     !! Kpoint for the interpolation (WARNING: this must be in crystal coord!)
     COMPLEX(KIND = DP), INTENT(out) :: epmatf(nbnd, nbnd, nrr_k)
     !! e-p matrix in Bloch representation, fine grid
+    CHARACTER(*), INTENT(in) :: suffix
+    !! Extra label for filenames
     !
     ! Local variables
     CHARACTER(LEN = 256) :: filint
@@ -2267,8 +2305,6 @@
     !! Ending ir for this pool
     INTEGER :: iw
     !! Counter on Wannier functions
-    INTEGER :: iw2
-    !! Counter on Wannier functions
     INTEGER :: iunepmatwp2
     !! Return the file unit
     INTEGER :: na
@@ -2289,7 +2325,7 @@
     !
     REAL(KIND = DP) :: rdotk
     !! Exponential for the FT
-    COMPLEX(KIND = DP) :: cfac(nat, nrr_g, dims)
+    COMPLEX(KIND = DP) :: cfac(nrr_g, dims)
     !! Factor for the FT
     COMPLEX(KIND = DP), ALLOCATABLE :: epmatw(:, :, :)
     !! El-ph matrix elements
@@ -2308,22 +2344,23 @@
     CALL para_bounds(ir_start, ir_stop, nrr_g)
     !
 #if defined(__MPI)
-    filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwp'
+    filint = TRIM(tmp_dir) // TRIM(prefix) // '.epmatwp' // suffix
     CALL MPI_FILE_OPEN(world_comm, filint, MPI_MODE_RDONLY, MPI_INFO_NULL, iunepmatwp2, ierr)
     IF (ierr /= 0) CALL errore('ephwan2blochp_mem', 'error in MPI_FILE_OPEN', 1)
 #endif
     !
-    cfac(:, :, :) = czero
+    cfac(:, :) = czero
     !
     IF (use_ws) THEN
+      na = (imode - 1) / 3 + 1
+      !
       DO ir = ir_start, ir_stop
         !
         ! note xxq is assumed to be already in cryst coord
         rdotk = twopi * DOT_PRODUCT(xxq, DBLE(irvec_g(:, ir)))
-        na = (imode - 1) / 3 + 1
         DO iw = 1, dims
-          IF (ndegen_g(ir, na, iw) > 0) &
-            cfac(na, ir, iw) = EXP(ci * rdotk) / DBLE(ndegen_g(ir, na, iw))
+          IF (ndegen_g(iw, ir, na) > 0) &
+            cfac(ir, iw) = EXP(ci * rdotk) / DBLE(ndegen_g(iw, ir, na))
         ENDDO
       ENDDO
     ELSE
@@ -2331,7 +2368,7 @@
         !
         ! note xxq is assumed to be already in cryst coord
         rdotk = twopi * DOT_PRODUCT(xxq, DBLE(irvec_g(:, ir)))
-        cfac(1, ir, 1) = EXP(ci * rdotk) / DBLE(ndegen_g(ir, 1, 1))
+        cfac(ir, 1) = EXP(ci * rdotk) / DBLE(ndegen_g(1, ir, 1))
       ENDDO
     ENDIF
     !
@@ -2376,12 +2413,11 @@
 #endif
       !
       IF (use_ws) THEN
-        na = (imode - 1) / 3 + 1
         DO iw = 1, dims
-          CALL ZAXPY(nbnd * nrr_k, cfac(na, ir, iw), epmatw(iw, :, :), 1, epmatf(iw, :, :), 1)
+          CALL ZAXPY(nbnd * nrr_k, cfac(ir, iw), epmatw(iw, :, :), 1, epmatf(iw, :, :), 1)
         ENDDO
       ELSE
-        CALL ZAXPY(nbnd * nbnd * nrr_k, cfac(1, ir, 1), epmatw, 1, epmatf, 1)
+        CALL ZAXPY(nbnd * nbnd * nrr_k, cfac(ir, 1), epmatw, 1, epmatf, 1)
       ENDIF
       !
     ENDDO
diff --git a/EPW/src/wigner.f90 b/EPW/src/wigner.f90
index 17353ba01..d8f9ce6e6 100644
--- a/EPW/src/wigner.f90
+++ b/EPW/src/wigner.f90
@@ -58,6 +58,11 @@
     !!
     !-----------------------------------------------------------------
     USE kinds,     ONLY : DP
+    USE epwcom,    ONLY : epwwrite
+    USE io_files,  ONLY : tmp_dir, prefix
+    USE io_global, ONLY : ionode_id
+    USE io_var,    ONLY : iunwigner
+    USE mp_world,  ONLY : mpime
     !
     IMPLICIT NONE
     !
@@ -103,6 +108,8 @@
     !! Wannier centers used for the creation of electron and el-ph WS cells
     REAL(KIND = DP), INTENT(in) :: tau(3, dims2)
     !! Atomic position in the unit cell.
+    CHARACTER(LEN = 256) :: filint
+    !! File name
     !
     ! Work Variables
     INTEGER :: ir
@@ -187,6 +194,16 @@
       wslen_g(ir)        = wslen_gg(ir)
     ENDDO
     !
+    ! Write information needed to interpret epmatwp file using external software
+    IF (epwwrite .AND. mpime == ionode_id) THEN
+      filint = TRIM(tmp_dir) // TRIM(prefix) // '.wigner'
+      OPEN(iunwigner, FILE = filint, ACTION = 'write', STATUS = 'replace', ACCESS = 'stream')
+      WRITE(iunwigner) dims, dims2
+      WRITE(iunwigner) nrr_k, irvec_k, ndegen_k
+      WRITE(iunwigner) nrr_g, irvec_g, ndegen_g
+      CLOSE(iunwigner)
+    ENDIF
+    !
     !-----------------------------------------------------------------------------
     END SUBROUTINE wigner_seitz_wrap
     !-----------------------------------------------------------------------------
diff --git a/LR_Modules/lrcom.f90 b/LR_Modules/lrcom.f90
index 2dd4bd5a1..0ef169377 100644
--- a/LR_Modules/lrcom.f90
+++ b/LR_Modules/lrcom.f90
@@ -78,6 +78,13 @@ MODULE control_lr
   REAL(DP) :: alpha_mix(100)  ! the mixing parameter
   INTEGER :: niter_ph         ! maximum number of iterations (read from input)
   INTEGER :: nbnd_occx        ! maximun value of nbnd_occ(:)
+
+  ! cDFPT
+  LOGICAL :: lcdfpt ! if .TRUE. perform a constrained DFPT calculation
+  LOGICAL :: bare ! if .TRUE. compute bare phonons and coupling
+  LOGICAL, ALLOCATABLE :: cdfpt_subspace(:, :) ! cDFPT target subspace
+  REAL(DP) :: cdfpt_min, cdfpt_max ! energy window of target subspace
+  INTEGER :: ibndprt ! index of electron band for which to print coupling
   !
 END MODULE control_lr
 !
diff --git a/LR_Modules/orthogonalize.f90 b/LR_Modules/orthogonalize.f90
index 2966a268e..e4400e850 100644
--- a/LR_Modules/orthogonalize.f90
+++ b/LR_Modules/orthogonalize.f90
@@ -40,7 +40,7 @@ SUBROUTINE orthogonalize(dvpsi, evq, ikk, ikq, dpsi, npwq, dpsi_computed)
   USE xc_lib,           ONLY : exx_is_active
   USE control_flags,    ONLY : gamma_only
   USE gvect,            ONLY : gstart
-  USE control_lr,       ONLY : alpha_pv, nbnd_occ
+  USE control_lr,       ONLY : alpha_pv, nbnd_occ, lcdfpt, cdfpt_subspace
   USE dfpt_tetra_mod,   ONLY : dfpt_tetra_beta
   !
   IMPLICIT NONE
@@ -68,7 +68,7 @@ SUBROUTINE orthogonalize(dvpsi, evq, ikk, ikq, dpsi, npwq, dpsi_computed)
   ALLOCATE(ps(nbnd,nbnd))
   ps = (0.0_DP, 0.0_DP)
   !
-  IF (ltetra .OR. lgauss) THEN
+  IF (ltetra .OR. lgauss .OR. lcdfpt) THEN
      !
      !  metallic case
      !
@@ -90,6 +90,15 @@ SUBROUTINE orthogonalize(dvpsi, evq, ikk, ikq, dpsi, npwq, dpsi_computed)
            wg1 = wgauss ((ef-et(ibnd,ikk)) / degauss, ngauss)
            w0g = w0gauss((ef-et(ibnd,ikk)) / degauss, ngauss) / degauss
            DO jbnd = 1, nbnd
+              !
+              IF (lcdfpt) THEN
+                 IF (cdfpt_subspace(ibnd, ikk) .AND. &
+                     cdfpt_subspace(jbnd, ikq)) THEN
+                    ps(jbnd, ibnd) = wg1 * ps(jbnd, ibnd)
+                    CYCLE
+                 ENDIF
+              ENDIF
+              !
               wgp = wgauss ( (ef - et (jbnd, ikq) ) / degauss, ngauss)
               deltae = et (jbnd, ikq) - et (ibnd, ikk)
               theta = wgauss (deltae / degauss, 0)
@@ -110,6 +119,16 @@ SUBROUTINE orthogonalize(dvpsi, evq, ikk, ikq, dpsi, npwq, dpsi_computed)
               !
            ENDDO
            !
+        ELSEIF (lcdfpt) THEN
+           !
+           DO jbnd = nbnd_occ(ikq) + 1, nbnd
+              IF (.NOT. (cdfpt_subspace(ibnd, ikk) .AND. &
+                         cdfpt_subspace(jbnd, ikq))) THEN
+                 ps(jbnd, ibnd) = 0.0_DP
+              ENDIF
+           ENDDO
+           CYCLE
+           !
         ELSE
            !
            wg1 = wg(ibnd,ikk) / wk(ikk)
@@ -185,7 +204,7 @@ SUBROUTINE orthogonalize(dvpsi, evq, ikk, ikq, dpsi, npwq, dpsi_computed)
   !
   ! |dvspi> =  -(|dvpsi> - S|evq><evq|dvpsi>)
   !
-  IF (lgauss .OR. ltetra ) THEN
+  IF (lgauss .OR. ltetra .OR. lcdfpt) THEN
      !
      !  metallic case
      !
diff --git a/PHonon/PH/allocate_phq.f90 b/PHonon/PH/allocate_phq.f90
index cfbc54fe3..78e80bbbf 100644
--- a/PHonon/PH/allocate_phq.f90
+++ b/PHonon/PH/allocate_phq.f90
@@ -42,7 +42,7 @@ subroutine allocate_phq
   USE qpoint,        ONLY : nksq, eigqts, xk_col
   USE eqv,           ONLY : dpsi, evq, vlocq, dmuxc, dvpsi
   USE lr_symm_base,  ONLY : rtau
-  USE control_lr,    ONLY : lgamma
+  USE control_lr,    ONLY : lgamma, lcdfpt, cdfpt_subspace
   USE ldaU,          ONLY : lda_plus_u, Hubbard_lmax, nwfcU
   USE ldaU_ph,       ONLY : dnsbare, dnsorth, dnsbare_all_modes, wfcatomk, &
                             dwfcatomk, sdwfcatomk, wfcatomkpq, dwfcatomkpq,  &
@@ -194,6 +194,9 @@ subroutine allocate_phq
      !
   ENDIF 
 
+  ! cDFPT
+  IF (lcdfpt) ALLOCATE(cdfpt_subspace(nbnd, nks))
+
   RETURN
 
 end subroutine allocate_phq
diff --git a/PHonon/PH/bcast_ph_input.f90 b/PHonon/PH/bcast_ph_input.f90
index 57fa75357..7cf24d4fd 100644
--- a/PHonon/PH/bcast_ph_input.f90
+++ b/PHonon/PH/bcast_ph_input.f90
@@ -17,7 +17,8 @@ subroutine bcast_ph_input ( )
 
   use mp, only: mp_bcast
   use mp_world, only: world_comm
-  USE control_lr, ONLY : lgamma, lrpa
+  USE control_lr, ONLY : lgamma, lrpa, lcdfpt, cdfpt_min, cdfpt_max, bare, &
+                         ibndprt
   USE control_ph, ONLY : start_irr, last_irr, start_q, last_q, nmix_ph, &
                          niter_ph, lnoloc, alpha_mix, tr2_ph, recover, &
                          ldisp, reduce_io, zue, zeu, epsil, trans, &
@@ -83,6 +84,8 @@ subroutine bcast_ph_input ( )
   call mp_bcast (do_long_range, meta_ionode_id, world_comm)
   call mp_bcast (elph_ahc, meta_ionode_id, world_comm)
   call mp_bcast (skip_upperfan, meta_ionode_id, world_comm)
+  call mp_bcast (lcdfpt, meta_ionode_id, world_comm)
+  call mp_bcast (bare, meta_ionode_id, world_comm)
   !
   ! integers
   !
@@ -112,6 +115,7 @@ subroutine bcast_ph_input ( )
   CALL mp_bcast( el_ph_nsigma, meta_ionode_id, world_comm )
   CALL mp_bcast( ahc_nbnd, meta_ionode_id, world_comm )
   CALL mp_bcast( ahc_nbndskip, meta_ionode_id, world_comm )
+  call mp_bcast( ibndprt, meta_ionode_id, world_comm )
   !
   ! real*8
   !
@@ -123,6 +127,8 @@ subroutine bcast_ph_input ( )
   call mp_bcast (max_seconds, meta_ionode_id, world_comm )
   call mp_bcast (dek, meta_ionode_id, world_comm )
   CALL mp_bcast( el_ph_sigma, meta_ionode_id, world_comm )
+  call mp_bcast (cdfpt_min, meta_ionode_id, world_comm)
+  call mp_bcast (cdfpt_max, meta_ionode_id, world_comm)
   !
   ! characters
   !
diff --git a/PHonon/PH/check_initial_status.f90 b/PHonon/PH/check_initial_status.f90
index f44b8d68d..61fd1dbbb 100644
--- a/PHonon/PH/check_initial_status.f90
+++ b/PHonon/PH/check_initial_status.f90
@@ -75,7 +75,7 @@ SUBROUTINE check_initial_status(auxdyn)
   USE disp,            ONLY : nqs, x_q, wq, comp_iq, nq1, nq2, nq3, &
                               done_iq, lgamma_iq
   USE qpoint,          ONLY : xq
-  USE control_lr,      ONLY : lgamma
+  USE control_lr,      ONLY : lgamma, lcdfpt, cdfpt_min, cdfpt_max
   USE output,          ONLY : fildyn, fildvscf
   USE control_ph,      ONLY : ldisp, recover, where_rec, rec_code, &
                               start_q, last_q, current_iq, tmp_dir_ph, &
@@ -87,7 +87,8 @@ SUBROUTINE check_initial_status(auxdyn)
   USE save_ph,         ONLY : tmp_dir_save
   USE units_ph,        ONLY : iudyn
   USE ph_restart,      ONLY : check_directory_phsave, check_available_bands,&
-                              allocate_grid_variables, ph_writefile
+                              allocate_grid_variables, ph_writefile, &
+                              write_cdfpt_subspace
   USE freq_ph,         ONLY : current_iu
   USE io_rho_xml,      ONLY : write_scf
   USE mp_images,       ONLY : nimage, intra_image_comm
@@ -155,6 +156,12 @@ SUBROUTINE check_initial_status(auxdyn)
      !
      CALL ph_writefile('init',0,0,ierr)
      !
+     !   Save the cDFPT subspace on file
+     !
+     IF (ionode .AND. lcdfpt) THEN
+        CALL write_cdfpt_subspace(cdfpt_min, cdfpt_max)
+     ENDIF
+     !
      !   Initialize the representations and write them on file.
      !
      IF (trans .OR. epsil .OR. ldvscf_interpolate) THEN
diff --git a/PHonon/PH/deallocate_phq.f90 b/PHonon/PH/deallocate_phq.f90
index 30238e9c4..b7cab1544 100644
--- a/PHonon/PH/deallocate_phq.f90
+++ b/PHonon/PH/deallocate_phq.f90
@@ -36,7 +36,7 @@ subroutine deallocate_phq
                            vsgga, segni
   USE qpoint,       ONLY : eigqts, ikks, ikqs, nksq, xk_col
   USE eqv,          ONLY : dmuxc, vlocq, dpsi, dvpsi, evq
-  USE control_lr,   ONLY : lgamma, nbnd_occ
+  USE control_lr,   ONLY : lgamma, nbnd_occ, lcdfpt, cdfpt_subspace
   USE ldaU,         ONLY : lda_plus_u
   USE ldaU_ph,      ONLY : dnsbare_all_modes, dnsorth_cart, dnsorth, dnsbare,  &
                            wfcatomk, swfcatomk, dwfcatomk, sdwfcatomk,         &
@@ -194,6 +194,11 @@ subroutine deallocate_phq
      !
   ENDIF
 
+  ! cDFPT
+  IF (lcdfpt) THEN
+    IF (ALLOCATED(cdfpt_subspace)) DEALLOCATE(cdfpt_subspace)
+  ENDIF
+
   RETURN
 
 end subroutine deallocate_phq
diff --git a/PHonon/PH/do_phonon.f90 b/PHonon/PH/do_phonon.f90
index c05807b81..042691eb4 100644
--- a/PHonon/PH/do_phonon.f90
+++ b/PHonon/PH/do_phonon.f90
@@ -127,6 +127,7 @@ SUBROUTINE do_phonon(auxdyn)
            CALL elphsum_wannier(iq)
         ELSEIF( elph_simple ) THEN
            CALL elphsum_simple()
+           CALL elph_print()
         ELSEIF( elph_epa ) THEN
            CALL elphfil_epa(iq)
         ELSEIF( elph_yambo ) THEN
diff --git a/PHonon/PH/elphon.f90 b/PHonon/PH/elphon.f90
index 35f710c56..76af71c38 100644
--- a/PHonon/PH/elphon.f90
+++ b/PHonon/PH/elphon.f90
@@ -349,7 +349,7 @@ SUBROUTINE elphel (irr, npe, imode0, dvscfins)
   USE elph_tetra_mod, ONLY : elph_tetra
   USE eqv,        ONLY : dvpsi, evq
   USE qpoint,     ONLY : nksq, ikks, ikqs, nksqtot
-  USE control_lr, ONLY : lgamma
+  USE control_lr, ONLY : lgamma, ibndprt
   USE fft_helper_subroutines
   USE ldaU,       ONLY : lda_plus_u, Hubbard_lmax
   USE ldaU_ph,    ONLY : dnsscf_all_modes, dnsscf
@@ -1804,3 +1804,35 @@ subroutine lint ( nsym, s, minus_q, at, bg, npk, k1,k2,k3, &
 
   return
 end subroutine lint
+!
+!-----------------------------------------------------------------------
+SUBROUTINE elph_print
+  !---------------------------------------------------------------------
+  !
+  ! This routine prints the electron-phonon matrix elements in Ry/Bohr
+  ! in the Cartesian basis for a selected band (ibndprt) and k = 0.
+  !
+  USE kinds, ONLY : DP
+  USE control_lr, ONLY : ibndprt
+  USE el_phon, ONLY : el_ph_mat
+  USE io_global, ONLY : stdout
+  USE ions_base, ONLY : nat
+  USE modes, ONLY : u
+  !
+  IMPLICIT NONE
+  !
+  INTEGER :: i
+  COMPLEX(dp) :: d
+  !
+  IF (ibndprt == 0) RETURN
+  !
+  WRITE (stdout, '(/, 5X, A, /)') &
+     'Printing the electron-phonon matrix elements in Ry/Bohr'
+  !
+  DO i = 1, 3 * nat
+     d = DOT_PRODUCT(u(i, :), el_ph_mat(ibndprt, ibndprt, 1, :))
+     !
+     WRITE (stdout, '(2F17.10)') REAL(d), AIMAG(d)
+  ENDDO
+  !
+END SUBROUTINE elph_print
diff --git a/PHonon/PH/io_dyn_mat_old.f90 b/PHonon/PH/io_dyn_mat_old.f90
index fe2516b68..9c15abfd3 100644
--- a/PHonon/PH/io_dyn_mat_old.f90
+++ b/PHonon/PH/io_dyn_mat_old.f90
@@ -38,7 +38,7 @@ subroutine write_dyn_on_file (xq, phi, nat, iudyn)
      do nb = 1, nat
         write (iudyn, '(2i5)') na, nb
         do icar = 1, 3
-           write (iudyn, '(3(2(f12.8,1x),2x))') (phi(icar,jcar,na,nb), jcar=1,3)
+           write (iudyn, '(3(2(f14.8,1x),2x))') (phi(icar,jcar,na,nb), jcar=1,3)
         enddo
      enddo
   enddo
diff --git a/PHonon/PH/ph_restart.f90 b/PHonon/PH/ph_restart.f90
index 3f7a67f00..5e7206108 100644
--- a/PHonon/PH/ph_restart.f90
+++ b/PHonon/PH/ph_restart.f90
@@ -30,7 +30,7 @@ MODULE ph_restart
   !
   PUBLIC :: ph_writefile, ph_readfile, allocate_grid_variables, &
        check_directory_phsave, destroy_status_run, check_available_bands, &
-       read_disp_pattern_only
+       read_disp_pattern_only, read_cdfpt_subspace, write_cdfpt_subspace
   !
   INTEGER :: iunpun
   !
@@ -1377,4 +1377,53 @@ MODULE ph_restart
       !
     END SUBROUTINE ph_restart_set_filename
     !
+    !------------------------------------------------------------------------
+    SUBROUTINE write_cdfpt_subspace( cdfpt_min, cdfpt_max )
+      !------------------------------------------------------------------------
+      !
+      !    This subroutine is used to forward the cDFPT subspace to EPW.
+      !
+      REAL(DP), INTENT(in) :: cdfpt_min, cdfpt_max
+      !
+      CHARACTER(LEN=256) :: dirname, filename
+      CHARACTER(LEN=256), EXTERNAL :: trimcheck
+      !
+      dirname = trimcheck ( TRIM( tmp_dir_ph ) // TRIM( prefix ) // '.phsave' )
+      filename = TRIM( dirname ) // 'cdfpt_subspace.xml'
+      !
+      iunpun = xml_openfile( filename )
+      !
+      CALL add_attr( 'version','1.0' )
+      CALL add_attr( 'encoding','UTF-8' )
+      CALL xmlw_writetag ( 'xml', '?' )
+      CALL xmlw_opentag ( 'Root' )
+      !
+      CALL xmlw_writetag( "CDFPT_MIN", cdfpt_min )
+      CALL xmlw_writetag( "CDFPT_MAX", cdfpt_max )
+      !
+      CALL xmlw_closetag
+      CALL xml_closefile
+      !
+    END SUBROUTINE write_cdfpt_subspace
+    !
+    !------------------------------------------------------------------------
+    SUBROUTINE read_cdfpt_subspace( filename, cdfpt_min, cdfpt_max )
+      !------------------------------------------------------------------------
+      !
+      !    This subroutine is used by EPW to read the cDFPT subspace.
+      !
+      CHARACTER(LEN=*), INTENT(in) :: filename
+      REAL(DP), INTENT(OUT) :: cdfpt_min, cdfpt_max
+      !
+      iunpun = xml_openfile( filename )
+      !
+      CALL xmlr_opentag ( 'Root' )
+      !
+      CALL xmlr_readtag( "CDFPT_MIN", cdfpt_min )
+      CALL xmlr_readtag( "CDFPT_MAX", cdfpt_max )
+      !
+      CALL xmlr_closetag
+      CALL xml_closefile
+      !
+    END SUBROUTINE read_cdfpt_subspace
 END MODULE ph_restart
diff --git a/PHonon/PH/phq_readin.f90 b/PHonon/PH/phq_readin.f90
index e9a9a20de..5ce52859e 100644
--- a/PHonon/PH/phq_readin.f90
+++ b/PHonon/PH/phq_readin.f90
@@ -66,7 +66,7 @@ SUBROUTINE phq_readin()
   USE dfile_star,    ONLY : drho_star, dvscf_star
 
   USE qpoint,        ONLY : nksq, xq
-  USE control_lr,    ONLY : lgamma, lrpa
+  USE control_lr,    ONLY : lgamma, lrpa, lcdfpt, cdfpt_min, cdfpt_max, bare, ibndprt
   ! YAMBO >
   USE YAMBO,         ONLY : elph_yambo,dvscf_yambo
   ! YAMBO <
@@ -126,7 +126,7 @@ SUBROUTINE phq_readin()
                        lshift_q, read_dns_bare, d2ns_type, diagonalization, &
                        ldvscf_interpolate, do_long_range, do_charge_neutral, &
                        wpot_dir, ahc_dir, ahc_nbnd, ahc_nbndskip, &
-                       skip_upperfan
+                       skip_upperfan, cdfpt_min, cdfpt_max, bare, ibndprt
 
   ! tr2_ph       : convergence threshold
   ! amass        : atomic masses
@@ -209,6 +209,9 @@ SUBROUTINE phq_readin()
   ! ahc_nbnd: Number of bands where the electron self-energy is to be computed.
   ! ahc_nbndskip: Number of bands to exclude when computing the self-energy.
   ! skip_upperfan: If .true., skip the calculation of upper Fan self-energy.
+  ! cdfpt_min, cdfpt_max: cDFPT target subspace (energy window)
+  ! bare: If .true., compute bare phonons and couplings.
+  ! ibndprt: Index of electron band for which to print coupling
   !
   ! Note: meta_ionode is a single processor that reads the input
   !       (ionode is also a single processor but per image)
@@ -305,6 +308,10 @@ SUBROUTINE phq_readin()
   k1       = 0
   k2       = 0
   k3       = 0
+  cdfpt_min = +1.D10
+  cdfpt_max = -1.D10
+  bare = .FALSE.
+  ibndprt = 0
   !
   ! dvscf_interpolate
   ldvscf_interpolate = .FALSE.
@@ -405,7 +412,7 @@ SUBROUTINE phq_readin()
   ENDDO
   IF (niter_ph.LT.1.OR.niter_ph.GT.maxter) CALL errore ('phq_readin', &
        ' Wrong niter_ph ', 1)
-  IF (nmix_ph.LT.1.OR.nmix_ph.GT.5) CALL errore ('phq_readin', ' Wrong &
+  IF (nmix_ph.LT.1.OR.nmix_ph.GT.100) CALL errore ('phq_readin', ' Wrong &
        &nmix_ph ', 1)
   IF (iverbosity.NE.0.AND.iverbosity.NE.1) CALL errore ('phq_readin', &
        &' Wrong  iverbosity ', 1)
@@ -647,6 +654,9 @@ SUBROUTINE phq_readin()
      fiu=0.0_DP
   END IF
   !
+  ! cDFPT
+  !
+  lcdfpt = cdfpt_min <= cdfpt_max
   !
   !   Here we finished the reading of the input file.
   !   Now allocate space for pwscf variables, read and check them.
diff --git a/PHonon/PH/phq_setup.f90 b/PHonon/PH/phq_setup.f90
index 559638b67..e484e6516 100644
--- a/PHonon/PH/phq_setup.f90
+++ b/PHonon/PH/phq_setup.f90
@@ -97,7 +97,7 @@ subroutine phq_setup
   USE lr_symm_base,  ONLY : gi, gimq, irotmq, minus_q, invsymq, nsymq, rtau
   USE qpoint,        ONLY : xq, xk_col
   USE nc_mag_aux,    ONLY : deeq_nc_save
-  USE control_lr,    ONLY : lgamma
+  USE control_lr,    ONLY : lgamma, lcdfpt, cdfpt_subspace, cdfpt_min, cdfpt_max
   USE ldaU,          ONLY : lda_plus_u, Hubbard_U, Hubbard_J0
   USE ldaU_ph,       ONLY : effU
   USE constants,     ONLY : rytoev
@@ -460,6 +460,10 @@ subroutine phq_setup
   !
   CALL stop_clock ('phq_setup')
   !
+  ! cDFPT
+  !
+  IF (lcdfpt) cdfpt_subspace = cdfpt_min / rytoev <= et .AND. et <= cdfpt_max / rytoev
+  !
   RETURN
   !
 END SUBROUTINE phq_setup
diff --git a/PHonon/PH/prepare_q.f90 b/PHonon/PH/prepare_q.f90
index 12c739998..908b873ac 100644
--- a/PHonon/PH/prepare_q.f90
+++ b/PHonon/PH/prepare_q.f90
@@ -41,7 +41,7 @@ SUBROUTINE prepare_q(auxdyn, do_band, do_iq, setup_pw, iq)
   USE dfpt_tetra_mod,  ONLY : dfpt_tetra_linit
 
   USE qpoint,          ONLY : xq
-  USE control_lr,      ONLY : lgamma
+  USE control_lr,      ONLY : lgamma, lcdfpt, bare
   USE spin_orb,        ONLY : domag
   USE noncollin_module, ONLY : noncolin
   ! YAMBO >
@@ -137,7 +137,7 @@ SUBROUTINE prepare_q(auxdyn, do_band, do_iq, setup_pw, iq)
      !
      IF ( lgamma ) THEN
         !
-        IF ( .NOT. (lgauss .OR. ltetra)) THEN
+        IF (.NOT. (lgauss .OR. ltetra) .OR. lcdfpt .OR. bare) THEN
            !
            ! ... in the case of an insulator at q=0 one has to calculate
            ! ... the dielectric constant and the Born eff. charges
diff --git a/PHonon/PH/solve_e.f90 b/PHonon/PH/solve_e.f90
index d22fc071a..645a11b30 100644
--- a/PHonon/PH/solve_e.f90
+++ b/PHonon/PH/solve_e.f90
@@ -60,7 +60,7 @@ subroutine solve_e
   USE lrus,                  ONLY : int3_paw
   USE qpoint,                ONLY : nksq, ikks, ikqs
   USE eqv,                   ONLY : dpsi, dvpsi
-  USE control_lr,            ONLY : nbnd_occ, lgamma
+  USE control_lr,            ONLY : nbnd_occ, lgamma, lcdfpt, bare
   USE dv_of_drho_lr
   USE fft_helper_subroutines
   USE fft_interfaces,        ONLY : fft_interpolate
@@ -155,8 +155,8 @@ subroutine solve_e
   !
   ! if q=0 for a metal: allocate and compute local DOS at Ef
   !
-  if ( (lgauss .or. ltetra) .or..not.lgamma) call errore ('solve_e', &
-       'called in the wrong case', 1)
+  if ((lgauss .or. ltetra) .and. .not. (lcdfpt .or. bare) .or. .not. lgamma) &
+     CALL errore('solve_e', 'called in the wrong case', 1)
   !
   !   The outside loop is over the iterations
   !
@@ -262,8 +262,10 @@ subroutine solve_e
 
            conv_root = .true.
 
-           call cgsolve_all (ch_psi_all,cg_psi,et(1,ikk),dvpsi,dpsi, &
-              h_diag,npwx,npw,thresh,ik,lter,conv_root,anorm,nbnd_occ(ikk),npol)
+           IF (.NOT. bare) THEN
+              call cgsolve_all (ch_psi_all,cg_psi,et(1,ikk),dvpsi,dpsi, &
+                 h_diag,npwx,npw,thresh,ik,lter,conv_root,anorm,nbnd_occ(ikk),npol)
+           ENDIF
 
            ltaver = ltaver + lter
            lintercall = lintercall + 1
diff --git a/PHonon/PH/solve_linter.f90 b/PHonon/PH/solve_linter.f90
index fed13a888..bde4a61c0 100644
--- a/PHonon/PH/solve_linter.f90
+++ b/PHonon/PH/solve_linter.f90
@@ -79,7 +79,7 @@ SUBROUTINE solve_linter (irr, imode0, npe, drhoscf)
   USE eqv,                  ONLY : dvpsi, dpsi, evq
   USE qpoint,               ONLY : xq, nksq, ikks, ikqs
   USE qpoint_aux,           ONLY : ikmks, ikmkmqs, becpt, alphapt
-  USE control_lr,           ONLY : nbnd_occ, lgamma
+  USE control_lr,           ONLY : nbnd_occ, lgamma, bare
   USE dv_of_drho_lr,        ONLY : dv_of_drho
   USE fft_helper_subroutines
   USE fft_interfaces,       ONLY : fft_interpolate
@@ -421,9 +421,11 @@ SUBROUTINE solve_linter (irr, imode0, npe, drhoscf)
               ENDIF
               conv_root = .true.
               
-              call cgsolve_all (ch_psi_all, cg_psi, et(1,ikmk), dvpsi, dpsi, &
-                   h_diag, npwx, npwq, thresh, ik, lter, conv_root, &
-                   anorm, nbnd_occ(ikk), npol )
+              IF (.NOT. bare) THEN
+                 call cgsolve_all (ch_psi_all, cg_psi, et(1,ikmk), dvpsi, dpsi, &
+                      h_diag, npwx, npwq, thresh, ik, lter, conv_root, &
+                      anorm, nbnd_occ(ikk), npol )
+              ENDIF
 
               IF (isolv==2) THEN
                  vrs(:,2:4)=-vrs(:,2:4)
